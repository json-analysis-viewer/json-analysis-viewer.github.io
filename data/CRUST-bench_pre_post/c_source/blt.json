{
    "name": "blt",
    "blt.c": "// See http://www.imperialviolet.org/binary/critbit.pdf\n//\n// Differences:\n//   - We only have one child pointer. We allocate sibling nodes at the same\n//     time; they lie in adjacent blocks of memory. The child pointer points\n//     to the left child. There is no waste because every node is either\n//     external or has two children.\n//   - We fold strcmp into the crit-bit finder. If there is no crit-bit\n//     then we have a match.\n//   - During lookup, if the key is shorter than the position of the\n//     crit bit in the current node, the path we take is irrelevant.\n//     Ideally, we'd take one of the shortest paths to a leaf (the only\n//     purpose is to get at a string so we can find the true crit bit),\n//     but for simplicity we always follow the left child.\n//     Our code skips a tiny bit of computation by assigning\n//     direction = 0 rather than c = 0 plus some bit twiddling.\n//   - Insertion: while walking down the tree (after we've figured out the crit\n//     bit), we're guaranteed that the byte number of the current node is less\n//     than the key length, so there's no need for special-case code to handle\n//     keys shorter than the crit bit.\n//   - We combine a couple of comparisons. Instead of byte0 < byte1 and then\n//     mask0 < mask1 if they are equal, we simplify to:\n//       (byte0 << 8) + mask0 < (byte1 << 8) + mask1\n//   - Deletion: we can return early if the key length is shorter than\n//     the current node's critical bit, as this implies the key is absent.\n//   - When following child pointers, rather than p->kid + predicate(),\n//     we prefer predicate() ? p->kid + 1 : p->kid, as this is faster on my\n//     system. We can thus relax predicate(): instead of returning 0 or 1,\n//     it's fine if it simply returns 0 or nonzero. This means we can store\n//     the plain bitmask instead of its inversion, and check the bit with\n//     a single AND.\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"blt.h\"\n\n// Returns the byte where each bit is 1 except for the bit corresponding to\n// the leading bit of x.\nstatic inline uint8_t to_mask(uint8_t x) {\n  // SWAR trick that sets every bit after the leading bit to 1.\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  // Zero all the bits after the leading bit then invert.\n  return x & ~(x >> 1);\n  if (0) {\n    // Alternative that performs better when there are few set bits.\n    // Zero all bits except leading bit with a bit-twiddling trick.\n    while (x&(x-1)) x &= x-1;\n    // Invert.\n    return 255 - x;\n  }\n}\n\n// An internal node. Leaf nodes are described by BLT_IT.\nstruct blt_node_s {\n  unsigned int byte:32;     // Byte # of difference.\n  unsigned int mask:8;      // ~mask = the crit bit within the byte.\n  unsigned int padding:23;\n  // The following bit corresponds to the last bit of the pointer to the key\n  // in the external node, which is always zero due to malloc alignment.\n  unsigned int is_internal:1;\n  struct blt_node_s *kid;\n};\ntypedef struct blt_node_s *blt_node_ptr;\n\nstatic inline blt_node_ptr follow(blt_node_ptr p, char *key) {\n  return key[p->byte] & p->mask ? p->kid + 1 : p->kid;\n}\n\nstruct BLT {\n  struct blt_node_s root[1];\n  int empty;\n};\n\nBLT *blt_new() {\n  BLT *blt = malloc(sizeof(*blt));\n  blt->empty = 1;\n  return blt;\n}\n\nvoid blt_clear(BLT *blt) {\n  void free_node(blt_node_ptr p) {\n    if (!p->is_internal) {\n      free(((BLT_IT *) p)->key);\n      return;\n    }\n    blt_node_ptr q = p->kid;\n    free_node(q);\n    free_node(q + 1);\n    free(q);\n  }\n  if (!blt->empty) free_node(blt->root);\n  free(blt);\n}\n\nsize_t blt_overhead(BLT *blt) {\n  size_t n = sizeof(BLT);\n  if (blt->empty) return n;\n  void add(blt_node_ptr p) {\n    if (p->is_internal) {\n      n += 2 * sizeof(struct blt_node_s);\n      add(p->kid);\n      add(p->kid + 1);\n    }\n  }\n  add(blt->root);\n  return n;\n}\n\nvoid blt_dump(BLT* blt, blt_node_ptr p) {\n  if (blt->empty) return;\n  if (p->is_internal) {\n    blt_dump(blt, p->kid);\n    blt_dump(blt, p->kid + 1);\n    return;\n  }\n  printf(\"  %s\\n\", (char *) ((BLT_IT *) p)->key);\n}\n\nstatic BLT_IT *blt_firstlast(blt_node_ptr p, int dir) {\n  if (!p) return 0;\n  while (p->is_internal) p = ((blt_node_ptr)p->kid) + dir;\n  return (BLT_IT *)p;\n}\n\nBLT_IT *blt_first(BLT *blt) {\n  return blt->empty ? 0 : blt_firstlast(blt->root, 0);\n}\n\nBLT_IT *blt_last (BLT *blt) {\n  return blt->empty ? 0 : blt_firstlast(blt->root, 1);\n}\n\nBLT_IT *blt_next(BLT *blt, BLT_IT *it) {\n  blt_node_ptr p = blt->root, other = 0;\n  while (p->is_internal) {\n    if (!(it->key[p->byte] & p->mask)) {\n      other = p->kid + 1;\n      p = p->kid;\n    } else {\n      p = p->kid + 1;\n    }\n  }\n  assert(!strcmp(((BLT_IT *)p)->key, it->key));\n  return blt_firstlast(other, 0);\n}\n\nBLT_IT *blt_prev(BLT *blt, BLT_IT *it) {\n  blt_node_ptr p = blt->root, other = 0;\n  while (p->is_internal) {\n    if (it->key[p->byte] & p->mask) {\n      other = p->kid;\n      p = p->kid + 1;\n    } else {\n      p = p->kid;\n    }\n  }\n  assert(!strcmp(((BLT_IT *)p)->key, it->key));\n  return blt_firstlast(other, 1);\n}\n\n// Walk down the tree as if the key is there.\nstatic inline BLT_IT *confident_get(BLT *blt, char *key) {\n  if (blt->empty) return 0;\n  blt_node_ptr p = blt->root;\n  int keylen = strlen(key);\n  while (p->is_internal) {\n    // When p->byte >= keylen, key is absent, but we must return something.\n    // Either kid works; we pick 0 each time.\n    p = p->byte < keylen && (key[p->byte] & p->mask) ? p->kid + 1 : p->kid;\n  }\n  return (void *)p;\n}\n\nBLT_IT *blt_ceilfloor(BLT *blt, char *key, int way) {\n  BLT_IT *p = confident_get(blt, key);\n  if (!p) return 0;\n  // Compare keys.\n  for(char *c = key, *pc = p->key;; c++, pc++) {\n    // XOR the current bytes being compared.\n    uint8_t x = *c ^ *pc;\n    if (x) {\n      int byte = c - key;\n      x = to_mask(x);\n      // Walk down the tree until we hit an external node or a node\n      // whose crit bit is higher.\n      blt_node_ptr p = blt->root, other = 0;\n      while (p->is_internal) {\n        if ((byte << 8) + p->mask < (p->byte << 8) + x) break;\n        int dir = !!(p->mask & key[p->byte]);\n        blt_node_ptr q = p->kid;\n        if (dir == way) other = q + 1 - way;\n        p = q + dir;\n      }\n      int ndir = !!(x & key[byte]);\n      if (ndir == way) other = p;\n      return blt_firstlast(other, way);\n    }\n    if (!*c) return (BLT_IT *)p;\n  }\n}\n\nBLT_IT *blt_ceil (BLT *blt, char *key) { return blt_ceilfloor(blt, key, 0); }\nBLT_IT *blt_floor(BLT *blt, char *key) { return blt_ceilfloor(blt, key, 1); }\n\nBLT_IT *blt_setp(BLT *blt, char *key, int *is_new) {\n  BLT_IT *p = confident_get(blt, key);\n  if (!p) {  // Empty tree case.\n    blt->empty = 0;\n    BLT_IT *leaf = (BLT_IT *) blt->root;\n    leaf->key = strdup(key);\n    leaf->data = 0;\n    if (is_new) *is_new = 1;\n    return leaf;\n  }\n  // Compare keys.\n  for(char *c = key, *pc = p->key;; c++, pc++) {\n    // XOR the current bytes being compared.\n    uint8_t x = *c ^ *pc;\n    if (x) {\n      // Allocate 2 adjacent nodes and copy the leaf into the appropriate side.\n      blt_node_ptr n = malloc(2 * sizeof(*n));\n      x = to_mask(x);\n      BLT_IT *leaf = (BLT_IT *)n;\n      blt_node_ptr other = n;\n      if (*c & x) leaf++; else other++;\n\n      leaf->key = strdup(key);\n      leaf->data = 0;\n\n      // Find the first node in the path whose critbit is higher than ours,\n      // or the external node.\n      int byte = c - key;\n      blt_node_ptr p = (blt_node_ptr) blt->root;\n      while(p->is_internal) {\n        if ((byte << 8) + p->mask < (p->byte << 8) + x) break;\n        p = follow(p, key);\n      }\n\n      // Copy the node's contents to the other side of our 2 new adjacent nodes,\n      // then replace it with our critbit and pointer to the new nodes.\n      *other = *p;\n      p->byte = byte;\n      p->mask = x;\n      p->kid = n;\n      p->is_internal = 1;\n      if (is_new) *is_new = 1;\n      return leaf;\n    }\n    if (!*c) {\n      if (is_new) *is_new = 0;\n      return p;\n    }\n  }\n}\n\nBLT_IT *blt_set(BLT *blt, char *key) { return blt_setp(blt, key, 0); }\n\nBLT_IT *blt_put(BLT *blt, char *key, void *data) {\n  BLT_IT *it = blt_set(blt, key);\n  it->data = data;\n  return it;\n}\n\nint blt_put_if_absent(BLT *blt, char *key, void *data) {\n  int is_new;\n  BLT_IT *it = blt_setp(blt, key, &is_new);\n  if (is_new) it->data = data;\n  return !is_new;\n}\n\nint blt_delete(BLT *blt, char *key) {\n  if (blt->empty) return 0;\n  int keylen = strlen(key);\n  blt_node_ptr p = blt->root, p0 = 0;\n  while (p->is_internal) {\n    if (p->byte > keylen) return 0;\n    p0 = p;\n    p = follow(p, key);\n  }\n  BLT_IT *leaf = (BLT_IT *)p;\n  if (strcmp(key, leaf->key)) return 0;\n  free(leaf->key);\n  if (!p0) {\n    blt->empty = 1;\n    return 1;\n  }\n  blt_node_ptr q = p0->kid;\n  *p0 = *(p == q ? q + 1 : q);\n  free(q);\n  return 1;\n}\n\nint blt_allprefixed(BLT *blt, char *key, int (*fun)(BLT_IT *)) {\n  if (blt->empty) return 1;\n  blt_node_ptr p = blt->root, top = p;\n  int keylen = strlen(key);\n  while (p->is_internal) {\n    if (p->byte >= keylen) {\n      p = p->kid;\n    } else {\n      p = follow(p, key);\n      top = p;\n    }\n  }\n  if (strncmp(key, ((BLT_IT *)p)->key, keylen)) return 1;\n  int traverse(blt_node_ptr p) {\n    if (p->is_internal) {\n      int status = traverse(p->kid);\n      if (status != 1) return status;\n      status = traverse(p->kid + 1);\n      if (status != 1) return status;\n      return 1;\n    }\n    return fun((BLT_IT *)p);\n  }\n  return traverse(top);\n}\n\nBLT_IT *blt_get(BLT *blt, char *key) {\n  if (blt->empty) return 0;\n  blt_node_ptr p = blt->root;\n  int keylen = strlen(key);\n  while (p->is_internal) {\n    // We could shave off a few percent by skipping checks like the\n    // following, but buffer overreads are bad form.\n    if (p->byte > keylen) return 0;\n    p = follow(p, key);\n  }\n  BLT_IT *r = (BLT_IT *)p;\n  return strcmp(key, r->key) ? 0 : r;\n}\n\nint blt_empty(BLT *blt) {\n  return blt->empty;\n}\n\nint blt_size(BLT *blt) {\n  int r = 0;\n  void f(BLT_IT *it) { r++; }\n  blt_forall(blt, f);\n  return r;\n}\n",
    "blt.h": "// = Crit-bit trees =\n//\n// Usage:\n//\n//   // Create a new tree.\n//   BLT* blt = blt_new();\n//\n//   // Insert a couple of keys.\n//   blt_put(blt, \"hello\", pointer1);\n//   blt_put(blt, \"world\", pointer2);\n//\n//   // Check they have the values we expect.\n//   if (blt_get(blt, \"hello\")->data != pointer1 ||\n//       blt_get(blt, \"hello\")->data != pointer2) exit(1);\n//\n//   // Delete the tree.\n//   blt_clear(blt);\n\nstruct BLT;\ntypedef struct BLT BLT;\nstruct BLT_IT {\n  char *key;\n  void *data;\n};\ntypedef struct BLT_IT BLT_IT;\n\n// Creates a new tree.\nBLT *blt_new();\n\n// Destroys a tree.\nvoid blt_clear(BLT *blt);\n\n// Retrieves the leaf node at a given key.\n// Returns NULL if there is no such key.\nBLT_IT *blt_get(BLT *blt, char *key);\n\n// Creates or retrieves the leaf node at a given key.\nBLT_IT *blt_set(BLT *blt, char *key);\n\n// Creates or retrieves the leaf node at a given key.\n// If is_new is not NULL, sets *is_new to 1 if a new node was created,\n// and 0 otherwise.\nBLT_IT *blt_setp(BLT *blt, char *key, int *is_new);\n\n// Inserts a given key and data pair.\n// Returns the leaf node containing them.\nBLT_IT *blt_put(BLT *blt, char *key, void *data);\n\n// Inserts a given key and data pair if key is absent.\n// Returns 0 on success. Returns 1 if key is already present.\nint blt_put_if_absent(BLT *blt, char *key, void *data);\n\n// Deletes a given key from the tree.\n// Returns 1 if a key was deleted, and 0 otherwise.\nint blt_delete(BLT *blt, char *key);\n\n// Iterates through all leaf nodes with a given prefix in order and runs the\n// given callback on each one.\n// If the callback returns 1, continues iteration, otherwise halts and returns\n// the value returned by the callback.\nint blt_allprefixed(BLT *blt, char *key, int (*fun)(BLT_IT *));\n\n// Iterates through all leaf nodes in order and runs the given callback.\nstatic inline void blt_forall(BLT *blt, void (*fun)(BLT_IT *)) {\n  int f(BLT_IT *it) { return fun(it), 1; }\n  blt_allprefixed(blt, \"\", f);\n}\n\n// Returns the leaf node with the smallest key.\nBLT_IT *blt_first(BLT *blt);\n\n// Returns the leaf node with the largest key.\nBLT_IT *blt_last (BLT *blt);\n\n// Returns the leaf node with the next largest key.\nBLT_IT *blt_next(BLT *blt, BLT_IT *it);\n\n// Returns the leaf node with the next smallest key.\nBLT_IT *blt_prev(BLT *blt, BLT_IT *it);\n\n// If the given key is present, returns its leaf node.\n// Otherwise returns the leaf node with the next largest key if it exists,\n// and NULL otherwise.\nBLT_IT *blt_ceil (BLT *blt, char *key);\n\n// If the given key is present, returns its leaf node.\n// Otherwise returns the leaf node with the next smallest key if it exists,\n// and NULL otherwise.\nBLT_IT *blt_floor(BLT *blt, char *key);\n\n// Returns the number of bytes used by the tree, excluding memory taken by\n// the bytes of the keys.\nsize_t blt_overhead(BLT *blt);\n\n// Returns 1 if tree is empty, 0 otherwise.\nint blt_empty(BLT *blt);\n\n// Returns number of keys.\nint blt_size(BLT *blt);\n",
    "bm.c": "// Simple benchmark library.\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nstatic struct timespec bm_tp[2];\n\nvoid bm_init() {\n  clock_gettime(CLOCK_MONOTONIC, bm_tp);\n}\n\nvoid bm_report(char *msg) {\n  clock_gettime(CLOCK_MONOTONIC, bm_tp + 1);\n  printf(\"%s: %ld.%09lds\\n\", msg,\n      bm_tp[1].tv_sec - bm_tp[0].tv_sec - (bm_tp[1].tv_nsec < bm_tp[0].tv_nsec),\n      bm_tp[1].tv_nsec - bm_tp[0].tv_nsec\n          + (bm_tp[1].tv_nsec < bm_tp[0].tv_nsec) * 1000000000L);\n  clock_gettime(CLOCK_MONOTONIC, bm_tp);\n}\n\nvoid bm_read_keys(void (*cb)(char **key, int m)) {\n  char **key;\n  int max = 8, m = 0;\n  key = malloc(sizeof(*key) * max);\n  for (;;) {\n    char *s = 0;\n    size_t n;\n    ssize_t len = getline(&s, &n, stdin);\n    if (feof(stdin)) break;\n    if (len == -1) perror(\"getline\"), exit(1);\n    if (s[len - 1] == '\\n') s[len - 1] = 0;\n    key[m++] = s;\n    if (m == max) max *= 2, key = realloc(key, sizeof(*key) * max);\n  }\n  // Randomize order of array.\n  for (int i = m-1; i>1; i--) {\n    int j = random() % i;\n    char *tmp = key[i];\n    key[i] = key[j];\n    key[j] = tmp;\n  }\n  cb(key, m);\n}\n",
    "bm.h": "void bm_init();\nvoid bm_report(char *msg);\nvoid bm_read_keys(void (*cb)(char **key, int m));\n",
    "cbt.c": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"cbt.h\"\n\n#define NDEBUG\n#include <assert.h>\n\nstruct cbt_node_s {\n  short crit;\n  struct cbt_node_s *left, *right;\n};\ntypedef struct cbt_node_s cbt_node_t[1];\ntypedef struct cbt_node_s *cbt_node_ptr;\n\nstruct cbt_leaf_s {\n  short crit;\n  void *data;\n  char *key;\n  struct cbt_leaf_s *prev, *next;\n};\ntypedef struct cbt_leaf_s cbt_leaf_t[1];\ntypedef struct cbt_leaf_s *cbt_leaf_ptr;\n\nstruct cbt_s {\n  int count;\n  cbt_node_ptr root;\n  struct cbt_leaf_s *first, *last;\n  void *(*dup)(cbt_t, const void *);\n  int (*getlen)(cbt_t, const void *);\n  int (*cmp)(cbt_t, const void *, const void *);\n  int (*getcrit)(cbt_t, const void *, const void *);\n  int len;\n};\n\nenum { EXT = -1 };\n\nvoid cbt_node_free(cbt_node_ptr t) {\n  if (!t) return;\n  if (EXT == t->crit) {\n    free(((cbt_leaf_ptr) t)->key);\n  } else {\n    cbt_node_free(t->left), cbt_node_free(t->right);\n  }\n  free(t);\n}\n\nstatic void cbt_init(cbt_t cbt) {\n  cbt->count = 0;\n  cbt->root = 0;\n  cbt->first = cbt->last = 0;\n}\n\nstatic int getcrit(cbt_t unused, const void *key0, const void *key1) {\n  const char *c0 = key0, *c1 = key1;\n  int bit;\n\n  while(*c0 == *c1) {\n    if (!*c0) return 0;\n    c0++, c1++;\n  }\n\n  char c = *c0 ^ *c1;\n  for (bit = 7; !(c >> bit); bit--);\n  // Subtract bit from 7 because we number them the other way.\n  // Add 1 because we want to use the sign as an extra bit of information.\n  // We'll subtract 1 from it later.\n  int crit = ((c0 - (const char *) key0) << 3) + 7 - bit + 1;\n  if ((*c0 >> bit) & 1) return crit;\n  return -crit;\n}\n\nstatic int cmp(cbt_t unused, const void *key0, const void *key1) {\n  return strcmp(key0, key1);\n}\n\nstatic int getlen(cbt_t unused, const void *key) {\n  // The terminating NUL counts as part of the key, though when in doubt we\n  // take the left branch so it works without the \"+ 1\".\n  return strlen(key) + 1;\n}\n\nstatic void *dup(cbt_t unused, const void *key) { return strdup(key); }\n\ncbt_t cbt_new(void) {\n  cbt_t res = malloc(sizeof(*res));\n  cbt_init(res);\n  res->len = 0;\n  res->cmp = cmp;\n  res->dup = dup;\n  res->getlen = getlen;\n  res->getcrit = getcrit;\n  return res;\n}\n\nstatic int getcrit_u(cbt_t cbt, const void *key0, const void *key1) {\n  const char *cp0 = key0, *limit = key0 + cbt->len, *cp1 = key1;\n\n  for(;;) {\n    if (cp0 == limit) return 0;\n    if (*cp0 != *cp1) break;\n    cp0++, cp1++;\n  }\n\n  int bit;\n  char c = *cp0 ^ *cp1;\n  for (bit = 7; !(c >> bit); bit--);\n  // Subtract bit from 7 because we number them the other way.\n  // Add 1 because we want to use the sign as an extra bit of information.\n  // We'll subtract 1 from it later.\n  int crit = ((cp0 - (const char *) key0) << 3) + 7 - bit + 1;\n  if ((*cp0 >> bit) & 1) return crit;\n  return -crit;\n}\n\nstatic int cmp_u(cbt_t cbt, const void *key0, const void *key1) {\n  return memcmp(key0, key1, cbt->len);\n}\n\nstatic void *dup_u(cbt_t cbt, const void *key) {\n  void *res = malloc(cbt->len);\n  memcpy(res, key, cbt->len);\n  return res;\n}\n\nstatic int getlen_u(cbt_t cbt, const void *unused) { return cbt->len; }\n\ncbt_t cbt_new_u(int len) {\n  cbt_t res = malloc(sizeof(*res));\n  cbt_init(res);\n  res->len = len;\n  res->cmp = cmp_u;\n  res->getlen = getlen_u;\n  res->dup = dup_u;\n  res->getcrit = getcrit_u;\n  return res;\n}\n\nstatic int getlen_enc(cbt_t unused, const void *key) {\n  const uint8_t *u = (const uint8_t *) key;\n  return *u + (u[1] << 8);\n}\n\nstatic int cmp_enc(cbt_t cbt, const void *key0, const void *key1) {\n  int len = getlen_enc(0, key0);\n  return getlen_enc(0, key1) != len ? 1 : memcmp(key0, key1, len + 2);\n}\n\nstatic void *dup_enc(cbt_t cbt, const void *key) {\n  int len = getlen_enc(0, key) + 2;\n  void *res = malloc(len);\n  memcpy(res, key, len);\n  return res;\n}\n\nstatic int getcrit_enc(cbt_t cbt, const void *key0, const void *key1) {\n  int n = getlen_enc(0, key0), n1 = getlen_enc(0, key1);\n  if (n > n1) n = n1;\n  const char *cp0 = key0, *limit = key0 + n + 2, *cp1 = key1;\n\n  for(;;) {\n    if (cp0 == limit) return 0;\n    if (*cp0 != *cp1) break;\n    cp0++, cp1++;\n  }\n\n  int bit;\n  char c = *cp0 ^ *cp1;\n  for (bit = 7; !(c >> bit); bit--);\n  // Subtract bit from 7 because we number them the other way.\n  // Add 1 because we want to use the sign as an extra bit of information.\n  // We'll subtract 1 from it later.\n  int crit = ((cp0 - (const char *) key0) << 3) + 7 - bit + 1;\n  return (*cp0 >> bit) & 1 ? crit : -crit;\n}\n\ncbt_t cbt_new_enc() {\n  cbt_t res = malloc(sizeof(*res));\n  cbt_init(res);\n  res->len = 0;\n  res->cmp = cmp_enc;\n  res->getlen = getlen_enc;\n  res->dup = dup_enc;\n  res->getcrit = getcrit_enc;\n  return res;\n}\n\nstatic void cbt_clear(cbt_t cbt) { cbt_node_free(cbt->root); }\n\nvoid cbt_delete(cbt_t cbt) {\n  cbt_clear(cbt);\n  free(cbt);\n}\n\nint cbt_size(cbt_t cbt) { return cbt->count; }\ncbt_it cbt_first(cbt_t cbt) { return cbt->first; }\ncbt_it cbt_last(cbt_t cbt) { return cbt->last; }\ncbt_it cbt_next(cbt_it it) { return it->next; }\nvoid cbt_put(cbt_it it, void *data) { it->data = data; }\nvoid *cbt_get(cbt_it it) { return it->data; }\nchar *cbt_key(cbt_it it) { return it->key; }\n\nstatic int testbit(const void *key, int bit) {\n  // The most significant bit is 0, and the least 7.\n  return (1 << (7 - (bit & 7))) & ((const char *) key)[bit >> 3];\n}\n\ncbt_it cbt_at(cbt_t cbt, const void *key) {\n  if (!cbt->root) return 0;\n  int len = (cbt->getlen(cbt, key) << 3) - 1;\n  cbt_node_ptr p = cbt->root;\n  for (;;) {\n    if (EXT == p->crit) break;\n    if (len < p->crit) {\n      do p = p->left; while (EXT != p->crit);\n      break;\n    }\n    p = testbit(key, p->crit) ? p->right : p->left;\n  }\n  if (!cbt->cmp(cbt, ((cbt_leaf_ptr) p)->key, key)) return (cbt_leaf_ptr) p;\n  return 0;\n}\n\nint cbt_has(cbt_t cbt, const void *key) { return cbt_at(cbt, key) != 0; }\n\nvoid *cbt_get_at(cbt_t cbt, const void *key) {\n  cbt_leaf_ptr p = cbt_at(cbt, key);\n  if (!p) return 0;\n  return p->data;\n}\n\nint cbt_insert_with(cbt_it *it, cbt_t cbt, void *(*fn)(void *), const void *key) {\n  if (!cbt->root) {\n    cbt_leaf_ptr leaf = malloc(sizeof(cbt_leaf_t));\n    leaf->crit = EXT, leaf->data = fn(0), leaf->key = cbt->dup(cbt, key);\n    cbt->root = (cbt_node_ptr) leaf;\n    cbt->first = cbt->last = leaf;\n    leaf->next = leaf->prev = 0;\n    cbt->count++;\n    return *it = leaf, 1;\n  }\n\n  cbt_node_ptr t = cbt->root;\n  int keylen = (cbt->getlen(cbt, key) << 3) - 1;\n\n  while (EXT != t->crit) {\n    // If the key is shorter than the remaining keys on this subtree, we can\n    // compare it against any of them (and are guaranteed the new node must be\n    // inserted above this node). We simply let it follow the rightmost path.\n    t = keylen < t->crit || testbit(key, t->crit) ? t->right : t->left;\n  }\n\n  cbt_leaf_ptr leaf = (cbt_leaf_ptr) t;\n  int res = cbt->getcrit(cbt, key, leaf->key);\n  if (!res) {\n    leaf->data = fn(leaf->data);\n    return *it = leaf, 0;\n  }\n\n  cbt->count++;\n  cbt_leaf_ptr pleaf = malloc(sizeof(cbt_leaf_t));\n  cbt_node_ptr pnode = malloc(sizeof(cbt_node_t));\n  pleaf->crit = EXT, pleaf->data = fn(0), pleaf->key = cbt->dup(cbt, key);\n  pnode->crit = abs(res) - 1;\n\n  cbt_node_ptr t0 = 0, t1 = cbt->root;\n  while(EXT != t1->crit && pnode->crit > t1->crit) {\n    t0 = t1, t1 = testbit(key, t1->crit) ? t1->right : t1->left;\n  }\n\n  if (res > 0) {\n    // Key is bigger, therefore it goes on the right.\n    pnode->left = t1;\n    pnode->right = (cbt_node_ptr) pleaf;\n    // The rightmost child of the left subtree must be the predecessor.\n    for (t = pnode->left; t->crit != EXT; t = t->right);\n    cbt_leaf_ptr leaf = (cbt_leaf_ptr) t;\n    pleaf->next = leaf->next;\n    pleaf->prev = leaf;\n    if (leaf->next) leaf->next->prev = pleaf;\n    else cbt->last = pleaf;\n    leaf->next = pleaf;\n  } else {\n    // Key is smaller, therefore it goes on the left.\n    pnode->left = (cbt_node_ptr) pleaf;\n    pnode->right = t1;\n    // The leftmost child of the right subtree must be the successor.\n    for (t = pnode->right; t->crit != EXT; t = t->left);\n    cbt_leaf_ptr leaf = (cbt_leaf_ptr) t;\n    pleaf->prev = leaf->prev;\n    pleaf->next = leaf;\n    if (leaf->prev) leaf->prev->next = pleaf;\n    else cbt->first = pleaf;\n    leaf->prev = pleaf;\n  }\n\n  if (!t0) {\n    cbt->root = pnode;\n  } else if (t0->left == t1) {\n    t0->left = pnode;\n  } else {\n    t0->right = pnode;\n  }\n  return *it = pleaf, 1;\n}\n\ncbt_it cbt_put_with(cbt_t cbt, void *(*fn)(void *), const void *key) {\n  cbt_it it;\n  cbt_insert_with(&it, cbt, fn, key);\n  return it;\n}\n\ncbt_it cbt_put_at(cbt_t cbt, void *data, const void *key) {\n  void *returndata(void *p) { return data; }\n  return cbt_put_with(cbt, returndata, key);\n}\n\nvoid *cbt_remove(cbt_t cbt, const void *key) {\n  assert(cbt->root);\n  assert(cbt_has(cbt, key));\n  cbt_node_ptr t0 = 0, t00 = 0, t = cbt->root;\n  while (EXT != t->crit) {\n    assert((cbt->getlen(cbt, key) << 3) - 1 >= t->crit);\n    t00 = t0, t0 = t, t = testbit(key, t->crit) ? t->right : t->left;\n  }\n  cbt->count--;\n  cbt_leaf_ptr p = (cbt_leaf_ptr) t;\n  if (!t0) {\n    cbt->root = 0;\n  } else {\n    cbt_node_ptr sibling = t0->left == t ? t0->right : t0->left;\n    if (!t00) {  // One-level down: reassign root.\n      cbt->root = sibling;\n    } else {  // Reassign grandparent.\n      if (t00->left == t0) {\n        t00->left = sibling;\n      } else {\n        t00->right = sibling;\n      }\n    }\n    free(t0);\n  }\n  if (p->next) p->next->prev = p->prev;\n  else cbt->last = p->prev;\n  if (p->prev) p->prev->next = p->next;\n  else cbt->first = p->next;\n  free(p->key);\n  void *data = p->data;\n  free(p);\n  return data;\n}\n\nstatic void clear_recurse(cbt_node_ptr t, void (*fn)(void *, const void *)) {\n  if (EXT == t->crit) {\n    cbt_leaf_ptr p = (cbt_leaf_ptr) t;\n    if (fn) fn(p->data, p->key);\n    free(p->key);\n    free(p);\n    return;\n  }\n  clear_recurse(t->left, fn);\n  clear_recurse(t->right, fn);\n  free(t);\n}\n\nvoid cbt_remove_all_with(cbt_t cbt, void (*fn)(void *data, const void *key)) {\n  if (cbt->root) {\n    clear_recurse(cbt->root, fn);\n    cbt->root = 0;\n    cbt->count = 0;\n    cbt->first = cbt->last = 0;\n  }\n}\n\nvoid cbt_remove_all(cbt_t cbt) {\n  if (cbt->root) cbt_remove_all_with(cbt, 0);\n}\n\nvoid cbt_forall(cbt_t cbt, void (*fn)(cbt_it)) {\n  cbt_leaf_ptr p;\n  for (p = cbt->first; p; p = p->next) fn(p);\n}\n\nvoid cbt_forall_at(cbt_t cbt, void (*fn)(void *data, const void *key)) {\n  cbt_leaf_ptr p;\n  for (p = cbt->first; p; p = p->next) fn(p->data, p->key);\n}\n\nsize_t cbt_overhead(cbt_t cbt) {\n  size_t n = sizeof(struct cbt_s);\n  if (!cbt->root) return n;\n  void add(cbt_node_ptr p) {\n    if (p->crit == EXT) {\n      n += sizeof(struct cbt_leaf_s);\n    } else {\n      n += sizeof(struct cbt_node_s);\n      add(p->left);\n      add(p->right);\n    }\n  }\n  add(cbt->root);\n  return n;\n}\n",
    "cbt.h": "// Crit-bit trees and linked list.\n// No parent pointers.\n//\n// Uses pointer casting and different structs instead of unions.\n// In a trie, internal nodes never become external nodes, and vice versa.\n//\n// Removing linked list code and data saves a little.\n\n#define __CBT_H__\n\nstruct cbt_s;\ntypedef struct cbt_s *cbt_t;\n\nstruct cbt_leaf_s;\n// Iterator.\ntypedef struct cbt_leaf_s *cbt_it;\n\n// Never mix keys from different types of trees.\n\n// Default: ASCIIZ keys.\ncbt_t cbt_new(void);\n\n// \"u\" mode: all keys are the same length but can contain any data.\n// e.g. SHA1 hashes.\ncbt_t cbt_new_u(int len);\n\n// \"enc\" mode: First 2 bytes encode length of remaining data. First byte\n// is the least significant.\ncbt_t cbt_new_enc();\n\nvoid cbt_delete(cbt_t cbt);\n\nvoid *cbt_get_at(cbt_t cbt, const void *key);\ncbt_it cbt_put_at(cbt_t cbt, void *data, const void *key);\n\nint cbt_size(cbt_t cbt);\n\nstatic inline int cbt_is_off(cbt_it it) { return !it; }\n\ncbt_it cbt_first(cbt_t cbt);\ncbt_it cbt_last(cbt_t cbt);\ncbt_it cbt_next(cbt_it it);\nvoid cbt_put(cbt_it it, void *data);\nvoid *cbt_get(cbt_it it);\nchar *cbt_key(cbt_it it);\n\ncbt_it cbt_at(cbt_t cbt, const void *key);\nint cbt_has(cbt_t cbt, const void *key);\n\nvoid cbt_forall(cbt_t cbt, void (*fn)(cbt_it));\nvoid cbt_forall_at(cbt_t cbt, void (*fn)(void *data, const void *key));\n\nvoid *cbt_remove(cbt_t cbt, const void *key);\nvoid cbt_remove_all(cbt_t cbt);\nvoid cbt_remove_all_with(cbt_t cbt, void (*fn)(void *data, const void *key));\n\nstatic inline void cbt_clear_with(cbt_t cbt,\n    void (*fn)(void *data, const void *key)) {\n  cbt_remove_all_with(cbt, fn);\n}\n\ncbt_it cbt_put_with(cbt_t cbt, void *(*fn)(void *), const void *key);\n\n// Finds or creates an entry with the given key and writes it to *it.\n// Returns 1 if a new cbt_it was created.\nint cbt_insert(cbt_it *it, cbt_t cbt, const void *key);\n\nsize_t cbt_overhead(cbt_t cbt);\n",
    "c": "",
    "c_pre_post_conditions": "// --------------------------------------------------------------------------------\n// blt.c\n// --------------------------------------------------------------------------------\n\n// Function: blt_new\n// Pre-condition:  none\n// Post-condition: returns a freshly\u2010malloc\u2019d BLT* such that\n//                 blt_empty(ret)==1 and blt_size(ret)==0.\n\n// Function: blt_clear\n// Pre-condition:  blt was returned by blt_new and has not yet been freed\n// Post-condition: all memory allocated for the tree (keys and nodes) and\n//                 the BLT header itself is released.\n\n// Function: blt_overhead\n// Pre-condition:  blt != NULL\n// Post-condition: returns the total number of bytes allocated by blt,\n//                 excluding the bytes of the stored key\u2010strings.\n\n// Function: blt_empty\n// Pre-condition:  blt != NULL\n// Post-condition: returns 1 iff blt contains no keys, 0 otherwise.\n\n// Function: blt_size\n// Pre-condition:  blt != NULL\n// Post-condition: returns the exact number of stored keys in order.\n\n// Function: blt_put(BLT *blt, char *key, void *data)\n// Pre-condition:  blt != NULL, key points at a valid NUL\u2010terminated string\n// Post-condition: ensures that an entry for key exists in blt, stores\n//                 data in that entry, and returns its BLT_IT*; if key\n//                 was already present, only its .data field is updated.\n\n// Function: blt_put_if_absent(BLT *blt, char *key, void *data)\n// Pre-condition:  blt != NULL, key is a valid C\u2010string\n// Post-condition: if key was absent, inserts it with .data==data and\n//                 returns 0; if key was already present, does not change\n//                 its data and returns 1.\n\n// Function: blt_get(BLT *blt, char *key)\n// Pre-condition:  blt != NULL, key is a valid C\u2010string\n// Post-condition: if key is present, returns its BLT_IT* (with .key==key);\n//                 otherwise returns NULL and does not modify blt.\n\n// Function: blt_delete(BLT *blt, char *key)\n// Pre-condition:  blt != NULL, key is a valid C\u2010string\n// Post-condition: if key was present, removes that leaf, frees its key\u2010string\n//                 and any collapsed internal node, returns 1; if absent,\n//                 does nothing and returns 0.\n\n// Function: blt_first(BLT *blt)\n// Pre-condition:  blt != NULL\n// Post-condition: returns the BLT_IT* with the lexicographically smallest key,\n//                 or NULL if blt is empty.\n\n// Function: blt_last(BLT *blt)\n// Pre-condition:  blt != NULL\n// Post-condition: returns the BLT_IT* with the lexicographically largest key,\n//                 or NULL if blt is empty.\n\n// Function: blt_next(BLT *blt, BLT_IT *it)\n// Pre-condition:  blt != NULL, it points to a valid leaf in blt\n// Post-condition: returns the leaf whose key is the next larger string,\n//                 or NULL if it was already the largest.\n\n// Function: blt_prev(BLT *blt, BLT_IT *it)\n// Pre-condition:  blt != NULL, it points to a valid leaf in blt\n// Post-condition: returns the leaf whose key is the next smaller string,\n//                 or NULL if it was already the smallest.\n\n// Function: blt_allprefixed(BLT *blt, char *prefix, int (*cb)(BLT_IT*))\n// Pre-condition:  blt != NULL, prefix is a valid C\u2010string, cb != NULL\n// Post-condition: invokes cb(it) on each leaf whose key starts with prefix,\n//                 in lex order.  If cb ever returns \u22601, stops and returns that\n//                 value; otherwise returns 1 after processing all matches.\n//                 Does not modify blt.\n\n// Function: blt_forall(BLT *blt, void (*cb)(BLT_IT*))\n// Pre-condition:  blt != NULL, cb != NULL\n// Post-condition: calls cb(it) on every leaf in lex order, always returns.\n\n// Function: blt_ceil(BLT *blt, char *key)\n// Pre-condition:  blt != NULL, key is a valid C\u2010string\n// Post-condition: if an exact match exists, returns that leaf;\n//                 else returns the smallest leaf with key > given key;\n//                 returns NULL if no such leaf exists or blt is empty.\n\n// Function: blt_floor(BLT *blt, char *key)\n// Pre-condition:  blt != NULL, key is a valid C\u2010string\n// Post-condition: if an exact match exists, returns that leaf;\n//                 else returns the largest leaf with key < given key;\n//                 returns NULL if no such leaf exists or blt is empty.\n\n\n\n// --------------------------------------------------------------------------------\n// bm.c\n// --------------------------------------------------------------------------------\n\n// Function: bm_init(void)\n// Pre-condition:  none\n// Post-condition: records the current CLOCK_MONOTONIC time in bm_tp[0].\n\n// Function: bm_report(char *msg)\n// Pre-condition:  msg != NULL\n// Post-condition: fetches the current time into bm_tp[1], computes the\n//                 difference (bm_tp[1]\u2013bm_tp[0]), prints \u201cmsg: sec.nsec\u201d,\n//                 then resets bm_tp[0]=now for the next interval.\n\n// Function: bm_read_keys(void (*cb)(char **keys, int m))\n// Pre-condition:  cb != NULL, stdin open\n// Post-condition: reads all lines from stdin, chops off \u2018\\n\u2019, builds a\n//                 malloc\u2019d array `keys[0..m-1]` of pointers (each malloc\u2019d\n//                 via getline), random\u2010shuffles it, calls cb(keys,m).\n//                 (keys themselves and the array persist until freed by cb.)\n\n\n\n// --------------------------------------------------------------------------------\n// cbt.c\n// --------------------------------------------------------------------------------\n\n// Function: cbt_new(void)\n// Pre-condition:  none\n// Post-condition: returns a fresh cbt_t whose root==NULL, count==0, and\n//                 default strcmp/NUL\u2010terminated\u2010string policies set.\n\n// Function: cbt_new_u(int len)\n// Pre-condition:  len>0\n// Post-condition: behaves like cbt_new but will treat all keys as fixed\u2010length\n//                 byte\u2010arrays of length `len\u2019, permitting any zero bytes.\n\n// Function: cbt_new_enc(void)\n// Pre-condition:  none\n// Post-condition: behaves like cbt_new but interprets the first two bytes of\n//                 each key as a little\u2010endian length header.\n\n// Function: cbt_delete(cbt_t cbt)\n// Pre-condition:  cbt != NULL\n// Post-condition: recursively frees every node and leaf (and their key copies),\n//                 then frees the cbt struct itself.\n\n// Function: cbt_size(cbt_t cbt)\n// Pre-condition:  cbt != NULL\n// Post-condition: returns the exact number of leaves stored (==count).\n\n// Function: cbt_first(cbt_t cbt)\n// Pre-condition:  cbt != NULL\n// Post-condition: returns the leaf at the very front of the in\u2010order linked list,\n//                 or NULL if empty.\n\n// Function: cbt_last(cbt_t cbt)\n// Pre-condition:  cbt != NULL\n// Post-condition: returns the leaf at the back of the in\u2010order linked list,\n//                 or NULL if empty.\n\n// Function: cbt_next(cbt_it it)\n// Pre-condition:  it != NULL, it is a valid leaf\n// Post-condition: returns it\u2010>next; may be NULL at end.\n\n// Function: cbt_put(cbt_it it, void *data)\n// Pre-condition:  it != NULL\n// Post-condition: overwrites it\u2010>data with data; no tree\u2010structure changes.\n\n// Function: cbt_get(cbt_it it)\n// Pre-condition:  it != NULL\n// Post-condition: returns it\u2010>data; no modification.\n\n// Function: cbt_key(cbt_it it)\n// Pre-condition:  it != NULL\n// Post-condition: returns the stored key pointer owned by it; no modification.\n\n// Function: cbt_has(cbt_t cbt, const void *key)\n// Pre-condition:  cbt != NULL, key formatted according to this tree\u2019s mode\n// Post-condition: returns 1 iff an exact\u2010match leaf exists, 0 otherwise.\n\n// Function: cbt_at(cbt_t cbt, const void *key)\n// Pre-condition:  cbt != NULL, key properly formed\n// Post-condition: if an exact match leaf is present returns its cbt_it,\n//                 else returns NULL; no modification.\n\n// Function: cbt_get_at(cbt_t cbt, const void *key)\n// Pre-condition:  same as cbt_at\n// Post-condition: returns the data pointer at the matching leaf, or NULL if none.\n\n// Function: cbt_insert_with(cbt_it *out, cbt_t cbt, void *(*fn)(void*), const void *key)\n// Pre-condition: out != NULL, cbt != NULL, fn != NULL, key well\u2010formed\n// Post-condition:\n//   - if key was already present, calls fn(old_data), replaces old_data with\n//     its return and returns 0 (new node _not_ created).\n//   - if key was absent, allocates exactly one new leaf and (if needed) one\n//     new internal node, links it into the trie and the doubly\u2010linked list,\n//     sets *out to the new leaf, and returns 1.\n\n// Function: cbt_put_with(cbt_t cbt, void *(*fn)(void*), const void *key)\n// Pre-condition:  same as cbt_insert_with\n// Post-condition: as above, but discards the boolean return and returns the leaf.\n\n// Function: cbt_put_at(cbt_t cbt, void *data, const void *key)\n// Pre-condition:  cbt != NULL, key well\u2010formed\n// Post-condition: ensures key is present, sets its .data to data, returns leaf.\n\n// Function: cbt_remove(cbt_t cbt, const void *key)\n// Pre-condition:  cbt != NULL, cbt_has(cbt,key)==1\n// Post-condition: unlinks and frees exactly one leaf and (if its parent\n//                 becomes unary) frees one internal node, repairs the trie\n//                 and the linked list, decrements count, returns the old data.\n\n// Function: cbt_remove_all_with(cbt_t cbt, void (*fn)(void*,const void*))\n// Pre-condition:  cbt != NULL\n// Post-condition: if fn!=NULL calls fn(data,key) on every leaf, then frees\n//                 every node and leaf and resets root=NULL, count=0,\n//                 first=last=NULL.\n\n// Function: cbt_remove_all(cbt_t cbt)\n// Pre-condition:  cbt != NULL\n// Post-condition: as cbt_remove_all_with(cbt,NULL)\n\n// Function: cbt_forall(cbt_t cbt, void (*fn)(cbt_it))\n// Pre-condition:  cbt != NULL, fn != NULL\n// Post-condition: in ascending (linked\u2010list) order calls fn(it) for each leaf.\n\n// Function: cbt_forall_at(cbt_t cbt, void (*fn)(void*,const void*))\n// Pre-condition:  cbt != NULL, fn != NULL\n// Post-condition: in ascending order calls fn(data,key) for each leaf.\n\n// Function: cbt_overhead(cbt_t cbt)\n// Pre-condition:  cbt != NULL\n// Post-condition: returns total malloc\u2019d bytes for internal nodes, leaf structs,\n//                 and leaf\u2010key copies, plus sizeof(*cbt) itself.",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\n// Function: function_name\n// Pre-condition: description of the pre-condition\n// Post-condition: description of the post-condition\n```\n\nHere is the code:\n{{blt.c}}\n```c\n// header file\n/*// = Crit-bit trees =\n//\n// Usage:\n//\n//   // Create a new tree.\n//   BLT* blt = blt_new();\n//\n//   // Insert a couple of keys.\n//   blt_put(blt, \"hello\", pointer1);\n//   blt_put(blt, \"world\", pointer2);\n//\n//   // Check they have the values we expect.\n//   if (blt_get(blt, \"hello\")->data != pointer1 ||\n//       blt_get(blt, \"hello\")->data != pointer2) exit(1);\n//\n//   // Delete the tree.\n//   blt_clear(blt);\n\nstruct BLT;\ntypedef struct BLT BLT;\nstruct BLT_IT {\n  char *key;\n  void *data;\n};\ntypedef struct BLT_IT BLT_IT;\n\n// Creates a new tree.\nBLT *blt_new();\n\n// Destroys a tree.\nvoid blt_clear(BLT *blt);\n\n// Retrieves the leaf node at a given key.\n// Returns NULL if there is no such key.\nBLT_IT *blt_get(BLT *blt, char *key);\n\n// Creates or retrieves the leaf node at a given key.\nBLT_IT *blt_set(BLT *blt, char *key);\n\n// Creates or retrieves the leaf node at a given key.\n// If is_new is not NULL, sets *is_new to 1 if a new node was created,\n// and 0 otherwise.\nBLT_IT *blt_setp(BLT *blt, char *key, int *is_new);\n\n// Inserts a given key and data pair.\n// Returns the leaf node containing them.\nBLT_IT *blt_put(BLT *blt, char *key, void *data);\n\n// Inserts a given key and data pair if key is absent.\n// Returns 0 on success. Returns 1 if key is already present.\nint blt_put_if_absent(BLT *blt, char *key, void *data);\n\n// Deletes a given key from the tree.\n// Returns 1 if a key was deleted, and 0 otherwise.\nint blt_delete(BLT *blt, char *key);\n\n// Iterates through all leaf nodes with a given prefix in order and runs the\n// given callback on each one.\n// If the callback returns 1, continues iteration, otherwise halts and returns\n// the value returned by the callback.\nint blt_allprefixed(BLT *blt, char *key, int (*fun)(BLT_IT *));\n\n// Iterates through all leaf nodes in order and runs the given callback.\nstatic inline void blt_forall(BLT *blt, void (*fun)(BLT_IT *)) {\n  int f(BLT_IT *it) { return fun(it), 1; }\n  blt_allprefixed(blt, \"\", f);\n}\n\n// Returns the leaf node with the smallest key.\nBLT_IT *blt_first(BLT *blt);\n\n// Returns the leaf node with the largest key.\nBLT_IT *blt_last (BLT *blt);\n\n// Returns the leaf node with the next largest key.\nBLT_IT *blt_next(BLT *blt, BLT_IT *it);\n\n// Returns the leaf node with the next smallest key.\nBLT_IT *blt_prev(BLT *blt, BLT_IT *it);\n\n// If the given key is present, returns its leaf node.\n// Otherwise returns the leaf node with the next largest key if it exists,\n// and NULL otherwise.\nBLT_IT *blt_ceil (BLT *blt, char *key);\n\n// If the given key is present, returns its leaf node.\n// Otherwise returns the leaf node with the next smallest key if it exists,\n// and NULL otherwise.\nBLT_IT *blt_floor(BLT *blt, char *key);\n\n// Returns the number of bytes used by the tree, excluding memory taken by\n// the bytes of the keys.\nsize_t blt_overhead(BLT *blt);\n\n// Returns 1 if tree is empty, 0 otherwise.\nint blt_empty(BLT *blt);\n\n// Returns number of keys.\nint blt_size(BLT *blt);\n*/\n// See http://www.imperialviolet.org/binary/critbit.pdf\n//\n// Differences:\n//   - We only have one child pointer. We allocate sibling nodes at the same\n//     time; they lie in adjacent blocks of memory. The child pointer points\n//     to the left child. There is no waste because every node is either\n//     external or has two children.\n//   - We fold strcmp into the crit-bit finder. If there is no crit-bit\n//     then we have a match.\n//   - During lookup, if the key is shorter than the position of the\n//     crit bit in the current node, the path we take is irrelevant.\n//     Ideally, we'd take one of the shortest paths to a leaf (the only\n//     purpose is to get at a string so we can find the true crit bit),\n//     but for simplicity we always follow the left child.\n//     Our code skips a tiny bit of computation by assigning\n//     direction = 0 rather than c = 0 plus some bit twiddling.\n//   - Insertion: while walking down the tree (after we've figured out the crit\n//     bit), we're guaranteed that the byte number of the current node is less\n//     than the key length, so there's no need for special-case code to handle\n//     keys shorter than the crit bit.\n//   - We combine a couple of comparisons. Instead of byte0 < byte1 and then\n//     mask0 < mask1 if they are equal, we simplify to:\n//       (byte0 << 8) + mask0 < (byte1 << 8) + mask1\n//   - Deletion: we can return early if the key length is shorter than\n//     the current node's critical bit, as this implies the key is absent.\n//   - When following child pointers, rather than p->kid + predicate(),\n//     we prefer predicate() ? p->kid + 1 : p->kid, as this is faster on my\n//     system. We can thus relax predicate(): instead of returning 0 or 1,\n//     it's fine if it simply returns 0 or nonzero. This means we can store\n//     the plain bitmask instead of its inversion, and check the bit with\n//     a single AND.\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"blt.h\"\n\n// Returns the byte where each bit is 1 except for the bit corresponding to\n// the leading bit of x.\nstatic inline uint8_t to_mask(uint8_t x) {\n  // SWAR trick that sets every bit after the leading bit to 1.\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  // Zero all the bits after the leading bit then invert.\n  return x & ~(x >> 1);\n  if (0) {\n    // Alternative that performs better when there are few set bits.\n    // Zero all bits except leading bit with a bit-twiddling trick.\n    while (x&(x-1)) x &= x-1;\n    // Invert.\n    return 255 - x;\n  }\n}\n\n// An internal node. Leaf nodes are described by BLT_IT.\nstruct blt_node_s {\n  unsigned int byte:32;     // Byte # of difference.\n  unsigned int mask:8;      // ~mask = the crit bit within the byte.\n  unsigned int padding:23;\n  // The following bit corresponds to the last bit of the pointer to the key\n  // in the external node, which is always zero due to malloc alignment.\n  unsigned int is_internal:1;\n  struct blt_node_s *kid;\n};\ntypedef struct blt_node_s *blt_node_ptr;\n\nstatic inline blt_node_ptr follow(blt_node_ptr p, char *key) {\n  return key[p->byte] & p->mask ? p->kid + 1 : p->kid;\n}\n\nstruct BLT {\n  struct blt_node_s root[1];\n  int empty;\n};\n\nBLT *blt_new() {\n  BLT *blt = malloc(sizeof(*blt));\n  blt->empty = 1;\n  return blt;\n}\n\nvoid blt_clear(BLT *blt) {\n  void free_node(blt_node_ptr p) {\n    if (!p->is_internal) {\n      free(((BLT_IT *) p)->key);\n      return;\n    }\n    blt_node_ptr q = p->kid;\n    free_node(q);\n    free_node(q + 1);\n    free(q);\n  }\n  if (!blt->empty) free_node(blt->root);\n  free(blt);\n}\n\nsize_t blt_overhead(BLT *blt) {\n  size_t n = sizeof(BLT);\n  if (blt->empty) return n;\n  void add(blt_node_ptr p) {\n    if (p->is_internal) {\n      n += 2 * sizeof(struct blt_node_s);\n      add(p->kid);\n      add(p->kid + 1);\n    }\n  }\n  add(blt->root);\n  return n;\n}\n\nvoid blt_dump(BLT* blt, blt_node_ptr p) {\n  if (blt->empty) return;\n  if (p->is_internal) {\n    blt_dump(blt, p->kid);\n    blt_dump(blt, p->kid + 1);\n    return;\n  }\n  printf(\"  %s\\n\", (char *) ((BLT_IT *) p)->key);\n}\n\nstatic BLT_IT *blt_firstlast(blt_node_ptr p, int dir) {\n  if (!p) return 0;\n  while (p->is_internal) p = ((blt_node_ptr)p->kid) + dir;\n  return (BLT_IT *)p;\n}\n\nBLT_IT *blt_first(BLT *blt) {\n  return blt->empty ? 0 : blt_firstlast(blt->root, 0);\n}\n\nBLT_IT *blt_last (BLT *blt) {\n  return blt->empty ? 0 : blt_firstlast(blt->root, 1);\n}\n\nBLT_IT *blt_next(BLT *blt, BLT_IT *it) {\n  blt_node_ptr p = blt->root, other = 0;\n  while (p->is_internal) {\n    if (!(it->key[p->byte] & p->mask)) {\n      other = p->kid + 1;\n      p = p->kid;\n    } else {\n      p = p->kid + 1;\n    }\n  }\n  assert(!strcmp(((BLT_IT *)p)->key, it->key));\n  return blt_firstlast(other, 0);\n}\n\nBLT_IT *blt_prev(BLT *blt, BLT_IT *it) {\n  blt_node_ptr p = blt->root, other = 0;\n  while (p->is_internal) {\n    if (it->key[p->byte] & p->mask) {\n      other = p->kid;\n      p = p->kid + 1;\n    } else {\n      p = p->kid;\n    }\n  }\n  assert(!strcmp(((BLT_IT *)p)->key, it->key));\n  return blt_firstlast(other, 1);\n}\n\n// Walk down the tree as if the key is there.\nstatic inline BLT_IT *confident_get(BLT *blt, char *key) {\n  if (blt->empty) return 0;\n  blt_node_ptr p = blt->root;\n  int keylen = strlen(key);\n  while (p->is_internal) {\n    // When p->byte >= keylen, key is absent, but we must return something.\n    // Either kid works; we pick 0 each time.\n    p = p->byte < keylen && (key[p->byte] & p->mask) ? p->kid + 1 : p->kid;\n  }\n  return (void *)p;\n}\n\nBLT_IT *blt_ceilfloor(BLT *blt, char *key, int way) {\n  BLT_IT *p = confident_get(blt, key);\n  if (!p) return 0;\n  // Compare keys.\n  for(char *c = key, *pc = p->key;; c++, pc++) {\n    // XOR the current bytes being compared.\n    uint8_t x = *c ^ *pc;\n    if (x) {\n      int byte = c - key;\n      x = to_mask(x);\n      // Walk down the tree until we hit an external node or a node\n      // whose crit bit is higher.\n      blt_node_ptr p = blt->root, other = 0;\n      while (p->is_internal) {\n        if ((byte << 8) + p->mask < (p->byte << 8) + x) break;\n        int dir = !!(p->mask & key[p->byte]);\n        blt_node_ptr q = p->kid;\n        if (dir == way) other = q + 1 - way;\n        p = q + dir;\n      }\n      int ndir = !!(x & key[byte]);\n      if (ndir == way) other = p;\n      return blt_firstlast(other, way);\n    }\n    if (!*c) return (BLT_IT *)p;\n  }\n}\n\nBLT_IT *blt_ceil (BLT *blt, char *key) { return blt_ceilfloor(blt, key, 0); }\nBLT_IT *blt_floor(BLT *blt, char *key) { return blt_ceilfloor(blt, key, 1); }\n\nBLT_IT *blt_setp(BLT *blt, char *key, int *is_new) {\n  BLT_IT *p = confident_get(blt, key);\n  if (!p) {  // Empty tree case.\n    blt->empty = 0;\n    BLT_IT *leaf = (BLT_IT *) blt->root;\n    leaf->key = strdup(key);\n    leaf->data = 0;\n    if (is_new) *is_new = 1;\n    return leaf;\n  }\n  // Compare keys.\n  for(char *c = key, *pc = p->key;; c++, pc++) {\n    // XOR the current bytes being compared.\n    uint8_t x = *c ^ *pc;\n    if (x) {\n      // Allocate 2 adjacent nodes and copy the leaf into the appropriate side.\n      blt_node_ptr n = malloc(2 * sizeof(*n));\n      x = to_mask(x);\n      BLT_IT *leaf = (BLT_IT *)n;\n      blt_node_ptr other = n;\n      if (*c & x) leaf++; else other++;\n\n      leaf->key = strdup(key);\n      leaf->data = 0;\n\n      // Find the first node in the path whose critbit is higher than ours,\n      // or the external node.\n      int byte = c - key;\n      blt_node_ptr p = (blt_node_ptr) blt->root;\n      while(p->is_internal) {\n        if ((byte << 8) + p->mask < (p->byte << 8) + x) break;\n        p = follow(p, key);\n      }\n\n      // Copy the node's contents to the other side of our 2 new adjacent nodes,\n      // then replace it with our critbit and pointer to the new nodes.\n      *other = *p;\n      p->byte = byte;\n      p->mask = x;\n      p->kid = n;\n      p->is_internal = 1;\n      if (is_new) *is_new = 1;\n      return leaf;\n    }\n    if (!*c) {\n      if (is_new) *is_new = 0;\n      return p;\n    }\n  }\n}\n\nBLT_IT *blt_set(BLT *blt, char *key) { return blt_setp(blt, key, 0); }\n\nBLT_IT *blt_put(BLT *blt, char *key, void *data) {\n  BLT_IT *it = blt_set(blt, key);\n  it->data = data;\n  return it;\n}\n\nint blt_put_if_absent(BLT *blt, char *key, void *data) {\n  int is_new;\n  BLT_IT *it = blt_setp(blt, key, &is_new);\n  if (is_new) it->data = data;\n  return !is_new;\n}\n\nint blt_delete(BLT *blt, char *key) {\n  if (blt->empty) return 0;\n  int keylen = strlen(key);\n  blt_node_ptr p = blt->root, p0 = 0;\n  while (p->is_internal) {\n    if (p->byte > keylen) return 0;\n    p0 = p;\n    p = follow(p, key);\n  }\n  BLT_IT *leaf = (BLT_IT *)p;\n  if (strcmp(key, leaf->key)) return 0;\n  free(leaf->key);\n  if (!p0) {\n    blt->empty = 1;\n    return 1;\n  }\n  blt_node_ptr q = p0->kid;\n  *p0 = *(p == q ? q + 1 : q);\n  free(q);\n  return 1;\n}\n\nint blt_allprefixed(BLT *blt, char *key, int (*fun)(BLT_IT *)) {\n  if (blt->empty) return 1;\n  blt_node_ptr p = blt->root, top = p;\n  int keylen = strlen(key);\n  while (p->is_internal) {\n    if (p->byte >= keylen) {\n      p = p->kid;\n    } else {\n      p = follow(p, key);\n      top = p;\n    }\n  }\n  if (strncmp(key, ((BLT_IT *)p)->key, keylen)) return 1;\n  int traverse(blt_node_ptr p) {\n    if (p->is_internal) {\n      int status = traverse(p->kid);\n      if (status != 1) return status;\n      status = traverse(p->kid + 1);\n      if (status != 1) return status;\n      return 1;\n    }\n    return fun((BLT_IT *)p);\n  }\n  return traverse(top);\n}\n\nBLT_IT *blt_get(BLT *blt, char *key) {\n  if (blt->empty) return 0;\n  blt_node_ptr p = blt->root;\n  int keylen = strlen(key);\n  while (p->is_internal) {\n    // We could shave off a few percent by skipping checks like the\n    // following, but buffer overreads are bad form.\n    if (p->byte > keylen) return 0;\n    p = follow(p, key);\n  }\n  BLT_IT *r = (BLT_IT *)p;\n  return strcmp(key, r->key) ? 0 : r;\n}\n\nint blt_empty(BLT *blt) {\n  return blt->empty;\n}\n\nint blt_size(BLT *blt) {\n  int r = 0;\n  void f(BLT_IT *it) { r++; }\n  blt_forall(blt, f);\n  return r;\n}\n```\n\n{{bm.c}}\n```c\n// header file\n/*void bm_init();\nvoid bm_report(char *msg);\nvoid bm_read_keys(void (*cb)(char **key, int m));\n*/\n// Simple benchmark library.\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nstatic struct timespec bm_tp[2];\n\nvoid bm_init() {\n  clock_gettime(CLOCK_MONOTONIC, bm_tp);\n}\n\nvoid bm_report(char *msg) {\n  clock_gettime(CLOCK_MONOTONIC, bm_tp + 1);\n  printf(\"%s: %ld.%09lds\\n\", msg,\n      bm_tp[1].tv_sec - bm_tp[0].tv_sec - (bm_tp[1].tv_nsec < bm_tp[0].tv_nsec),\n      bm_tp[1].tv_nsec - bm_tp[0].tv_nsec\n          + (bm_tp[1].tv_nsec < bm_tp[0].tv_nsec) * 1000000000L);\n  clock_gettime(CLOCK_MONOTONIC, bm_tp);\n}\n\nvoid bm_read_keys(void (*cb)(char **key, int m)) {\n  char **key;\n  int max = 8, m = 0;\n  key = malloc(sizeof(*key) * max);\n  for (;;) {\n    char *s = 0;\n    size_t n;\n    ssize_t len = getline(&s, &n, stdin);\n    if (feof(stdin)) break;\n    if (len == -1) perror(\"getline\"), exit(1);\n    if (s[len - 1] == '\\n') s[len - 1] = 0;\n    key[m++] = s;\n    if (m == max) max *= 2, key = realloc(key, sizeof(*key) * max);\n  }\n  // Randomize order of array.\n  for (int i = m-1; i>1; i--) {\n    int j = random() % i;\n    char *tmp = key[i];\n    key[i] = key[j];\n    key[j] = tmp;\n  }\n  cb(key, m);\n}\n```\n\n{{cbt.c}}\n```c\n// header file\n/*// Crit-bit trees and linked list.\n// No parent pointers.\n//\n// Uses pointer casting and different structs instead of unions.\n// In a trie, internal nodes never become external nodes, and vice versa.\n//\n// Removing linked list code and data saves a little.\n\n#define __CBT_H__\n\nstruct cbt_s;\ntypedef struct cbt_s *cbt_t;\n\nstruct cbt_leaf_s;\n// Iterator.\ntypedef struct cbt_leaf_s *cbt_it;\n\n// Never mix keys from different types of trees.\n\n// Default: ASCIIZ keys.\ncbt_t cbt_new(void);\n\n// \"u\" mode: all keys are the same length but can contain any data.\n// e.g. SHA1 hashes.\ncbt_t cbt_new_u(int len);\n\n// \"enc\" mode: First 2 bytes encode length of remaining data. First byte\n// is the least significant.\ncbt_t cbt_new_enc();\n\nvoid cbt_delete(cbt_t cbt);\n\nvoid *cbt_get_at(cbt_t cbt, const void *key);\ncbt_it cbt_put_at(cbt_t cbt, void *data, const void *key);\n\nint cbt_size(cbt_t cbt);\n\nstatic inline int cbt_is_off(cbt_it it) { return !it; }\n\ncbt_it cbt_first(cbt_t cbt);\ncbt_it cbt_last(cbt_t cbt);\ncbt_it cbt_next(cbt_it it);\nvoid cbt_put(cbt_it it, void *data);\nvoid *cbt_get(cbt_it it);\nchar *cbt_key(cbt_it it);\n\ncbt_it cbt_at(cbt_t cbt, const void *key);\nint cbt_has(cbt_t cbt, const void *key);\n\nvoid cbt_forall(cbt_t cbt, void (*fn)(cbt_it));\nvoid cbt_forall_at(cbt_t cbt, void (*fn)(void *data, const void *key));\n\nvoid *cbt_remove(cbt_t cbt, const void *key);\nvoid cbt_remove_all(cbt_t cbt);\nvoid cbt_remove_all_with(cbt_t cbt, void (*fn)(void *data, const void *key));\n\nstatic inline void cbt_clear_with(cbt_t cbt,\n    void (*fn)(void *data, const void *key)) {\n  cbt_remove_all_with(cbt, fn);\n}\n\ncbt_it cbt_put_with(cbt_t cbt, void *(*fn)(void *), const void *key);\n\n// Finds or creates an entry with the given key and writes it to *it.\n// Returns 1 if a new cbt_it was created.\nint cbt_insert(cbt_it *it, cbt_t cbt, const void *key);\n\nsize_t cbt_overhead(cbt_t cbt);\n*/\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"cbt.h\"\n\n#define NDEBUG\n#include <assert.h>\n\nstruct cbt_node_s {\n  short crit;\n  struct cbt_node_s *left, *right;\n};\ntypedef struct cbt_node_s cbt_node_t[1];\ntypedef struct cbt_node_s *cbt_node_ptr;\n\nstruct cbt_leaf_s {\n  short crit;\n  void *data;\n  char *key;\n  struct cbt_leaf_s *prev, *next;\n};\ntypedef struct cbt_leaf_s cbt_leaf_t[1];\ntypedef struct cbt_leaf_s *cbt_leaf_ptr;\n\nstruct cbt_s {\n  int count;\n  cbt_node_ptr root;\n  struct cbt_leaf_s *first, *last;\n  void *(*dup)(cbt_t, const void *);\n  int (*getlen)(cbt_t, const void *);\n  int (*cmp)(cbt_t, const void *, const void *);\n  int (*getcrit)(cbt_t, const void *, const void *);\n  int len;\n};\n\nenum { EXT = -1 };\n\nvoid cbt_node_free(cbt_node_ptr t) {\n  if (!t) return;\n  if (EXT == t->crit) {\n    free(((cbt_leaf_ptr) t)->key);\n  } else {\n    cbt_node_free(t->left), cbt_node_free(t->right);\n  }\n  free(t);\n}\n\nstatic void cbt_init(cbt_t cbt) {\n  cbt->count = 0;\n  cbt->root = 0;\n  cbt->first = cbt->last = 0;\n}\n\nstatic int getcrit(cbt_t unused, const void *key0, const void *key1) {\n  const char *c0 = key0, *c1 = key1;\n  int bit;\n\n  while(*c0 == *c1) {\n    if (!*c0) return 0;\n    c0++, c1++;\n  }\n\n  char c = *c0 ^ *c1;\n  for (bit = 7; !(c >> bit); bit--);\n  // Subtract bit from 7 because we number them the other way.\n  // Add 1 because we want to use the sign as an extra bit of information.\n  // We'll subtract 1 from it later.\n  int crit = ((c0 - (const char *) key0) << 3) + 7 - bit + 1;\n  if ((*c0 >> bit) & 1) return crit;\n  return -crit;\n}\n\nstatic int cmp(cbt_t unused, const void *key0, const void *key1) {\n  return strcmp(key0, key1);\n}\n\nstatic int getlen(cbt_t unused, const void *key) {\n  // The terminating NUL counts as part of the key, though when in doubt we\n  // take the left branch so it works without the \"+ 1\".\n  return strlen(key) + 1;\n}\n\nstatic void *dup(cbt_t unused, const void *key) { return strdup(key); }\n\ncbt_t cbt_new(void) {\n  cbt_t res = malloc(sizeof(*res));\n  cbt_init(res);\n  res->len = 0;\n  res->cmp = cmp;\n  res->dup = dup;\n  res->getlen = getlen;\n  res->getcrit = getcrit;\n  return res;\n}\n\nstatic int getcrit_u(cbt_t cbt, const void *key0, const void *key1) {\n  const char *cp0 = key0, *limit = key0 + cbt->len, *cp1 = key1;\n\n  for(;;) {\n    if (cp0 == limit) return 0;\n    if (*cp0 != *cp1) break;\n    cp0++, cp1++;\n  }\n\n  int bit;\n  char c = *cp0 ^ *cp1;\n  for (bit = 7; !(c >> bit); bit--);\n  // Subtract bit from 7 because we number them the other way.\n  // Add 1 because we want to use the sign as an extra bit of information.\n  // We'll subtract 1 from it later.\n  int crit = ((cp0 - (const char *) key0) << 3) + 7 - bit + 1;\n  if ((*cp0 >> bit) & 1) return crit;\n  return -crit;\n}\n\nstatic int cmp_u(cbt_t cbt, const void *key0, const void *key1) {\n  return memcmp(key0, key1, cbt->len);\n}\n\nstatic void *dup_u(cbt_t cbt, const void *key) {\n  void *res = malloc(cbt->len);\n  memcpy(res, key, cbt->len);\n  return res;\n}\n\nstatic int getlen_u(cbt_t cbt, const void *unused) { return cbt->len; }\n\ncbt_t cbt_new_u(int len) {\n  cbt_t res = malloc(sizeof(*res));\n  cbt_init(res);\n  res->len = len;\n  res->cmp = cmp_u;\n  res->getlen = getlen_u;\n  res->dup = dup_u;\n  res->getcrit = getcrit_u;\n  return res;\n}\n\nstatic int getlen_enc(cbt_t unused, const void *key) {\n  const uint8_t *u = (const uint8_t *) key;\n  return *u + (u[1] << 8);\n}\n\nstatic int cmp_enc(cbt_t cbt, const void *key0, const void *key1) {\n  int len = getlen_enc(0, key0);\n  return getlen_enc(0, key1) != len ? 1 : memcmp(key0, key1, len + 2);\n}\n\nstatic void *dup_enc(cbt_t cbt, const void *key) {\n  int len = getlen_enc(0, key) + 2;\n  void *res = malloc(len);\n  memcpy(res, key, len);\n  return res;\n}\n\nstatic int getcrit_enc(cbt_t cbt, const void *key0, const void *key1) {\n  int n = getlen_enc(0, key0), n1 = getlen_enc(0, key1);\n  if (n > n1) n = n1;\n  const char *cp0 = key0, *limit = key0 + n + 2, *cp1 = key1;\n\n  for(;;) {\n    if (cp0 == limit) return 0;\n    if (*cp0 != *cp1) break;\n    cp0++, cp1++;\n  }\n\n  int bit;\n  char c = *cp0 ^ *cp1;\n  for (bit = 7; !(c >> bit); bit--);\n  // Subtract bit from 7 because we number them the other way.\n  // Add 1 because we want to use the sign as an extra bit of information.\n  // We'll subtract 1 from it later.\n  int crit = ((cp0 - (const char *) key0) << 3) + 7 - bit + 1;\n  return (*cp0 >> bit) & 1 ? crit : -crit;\n}\n\ncbt_t cbt_new_enc() {\n  cbt_t res = malloc(sizeof(*res));\n  cbt_init(res);\n  res->len = 0;\n  res->cmp = cmp_enc;\n  res->getlen = getlen_enc;\n  res->dup = dup_enc;\n  res->getcrit = getcrit_enc;\n  return res;\n}\n\nstatic void cbt_clear(cbt_t cbt) { cbt_node_free(cbt->root); }\n\nvoid cbt_delete(cbt_t cbt) {\n  cbt_clear(cbt);\n  free(cbt);\n}\n\nint cbt_size(cbt_t cbt) { return cbt->count; }\ncbt_it cbt_first(cbt_t cbt) { return cbt->first; }\ncbt_it cbt_last(cbt_t cbt) { return cbt->last; }\ncbt_it cbt_next(cbt_it it) { return it->next; }\nvoid cbt_put(cbt_it it, void *data) { it->data = data; }\nvoid *cbt_get(cbt_it it) { return it->data; }\nchar *cbt_key(cbt_it it) { return it->key; }\n\nstatic int testbit(const void *key, int bit) {\n  // The most significant bit is 0, and the least 7.\n  return (1 << (7 - (bit & 7))) & ((const char *) key)[bit >> 3];\n}\n\ncbt_it cbt_at(cbt_t cbt, const void *key) {\n  if (!cbt->root) return 0;\n  int len = (cbt->getlen(cbt, key) << 3) - 1;\n  cbt_node_ptr p = cbt->root;\n  for (;;) {\n    if (EXT == p->crit) break;\n    if (len < p->crit) {\n      do p = p->left; while (EXT != p->crit);\n      break;\n    }\n    p = testbit(key, p->crit) ? p->right : p->left;\n  }\n  if (!cbt->cmp(cbt, ((cbt_leaf_ptr) p)->key, key)) return (cbt_leaf_ptr) p;\n  return 0;\n}\n\nint cbt_has(cbt_t cbt, const void *key) { return cbt_at(cbt, key) != 0; }\n\nvoid *cbt_get_at(cbt_t cbt, const void *key) {\n  cbt_leaf_ptr p = cbt_at(cbt, key);\n  if (!p) return 0;\n  return p->data;\n}\n\nint cbt_insert_with(cbt_it *it, cbt_t cbt, void *(*fn)(void *), const void *key) {\n  if (!cbt->root) {\n    cbt_leaf_ptr leaf = malloc(sizeof(cbt_leaf_t));\n    leaf->crit = EXT, leaf->data = fn(0), leaf->key = cbt->dup(cbt, key);\n    cbt->root = (cbt_node_ptr) leaf;\n    cbt->first = cbt->last = leaf;\n    leaf->next = leaf->prev = 0;\n    cbt->count++;\n    return *it = leaf, 1;\n  }\n\n  cbt_node_ptr t = cbt->root;\n  int keylen = (cbt->getlen(cbt, key) << 3) - 1;\n\n  while (EXT != t->crit) {\n    // If the key is shorter than the remaining keys on this subtree, we can\n    // compare it against any of them (and are guaranteed the new node must be\n    // inserted above this node). We simply let it follow the rightmost path.\n    t = keylen < t->crit || testbit(key, t->crit) ? t->right : t->left;\n  }\n\n  cbt_leaf_ptr leaf = (cbt_leaf_ptr) t;\n  int res = cbt->getcrit(cbt, key, leaf->key);\n  if (!res) {\n    leaf->data = fn(leaf->data);\n    return *it = leaf, 0;\n  }\n\n  cbt->count++;\n  cbt_leaf_ptr pleaf = malloc(sizeof(cbt_leaf_t));\n  cbt_node_ptr pnode = malloc(sizeof(cbt_node_t));\n  pleaf->crit = EXT, pleaf->data = fn(0), pleaf->key = cbt->dup(cbt, key);\n  pnode->crit = abs(res) - 1;\n\n  cbt_node_ptr t0 = 0, t1 = cbt->root;\n  while(EXT != t1->crit && pnode->crit > t1->crit) {\n    t0 = t1, t1 = testbit(key, t1->crit) ? t1->right : t1->left;\n  }\n\n  if (res > 0) {\n    // Key is bigger, therefore it goes on the right.\n    pnode->left = t1;\n    pnode->right = (cbt_node_ptr) pleaf;\n    // The rightmost child of the left subtree must be the predecessor.\n    for (t = pnode->left; t->crit != EXT; t = t->right);\n    cbt_leaf_ptr leaf = (cbt_leaf_ptr) t;\n    pleaf->next = leaf->next;\n    pleaf->prev = leaf;\n    if (leaf->next) leaf->next->prev = pleaf;\n    else cbt->last = pleaf;\n    leaf->next = pleaf;\n  } else {\n    // Key is smaller, therefore it goes on the left.\n    pnode->left = (cbt_node_ptr) pleaf;\n    pnode->right = t1;\n    // The leftmost child of the right subtree must be the successor.\n    for (t = pnode->right; t->crit != EXT; t = t->left);\n    cbt_leaf_ptr leaf = (cbt_leaf_ptr) t;\n    pleaf->prev = leaf->prev;\n    pleaf->next = leaf;\n    if (leaf->prev) leaf->prev->next = pleaf;\n    else cbt->first = pleaf;\n    leaf->prev = pleaf;\n  }\n\n  if (!t0) {\n    cbt->root = pnode;\n  } else if (t0->left == t1) {\n    t0->left = pnode;\n  } else {\n    t0->right = pnode;\n  }\n  return *it = pleaf, 1;\n}\n\ncbt_it cbt_put_with(cbt_t cbt, void *(*fn)(void *), const void *key) {\n  cbt_it it;\n  cbt_insert_with(&it, cbt, fn, key);\n  return it;\n}\n\ncbt_it cbt_put_at(cbt_t cbt, void *data, const void *key) {\n  void *returndata(void *p) { return data; }\n  return cbt_put_with(cbt, returndata, key);\n}\n\nvoid *cbt_remove(cbt_t cbt, const void *key) {\n  assert(cbt->root);\n  assert(cbt_has(cbt, key));\n  cbt_node_ptr t0 = 0, t00 = 0, t = cbt->root;\n  while (EXT != t->crit) {\n    assert((cbt->getlen(cbt, key) << 3) - 1 >= t->crit);\n    t00 = t0, t0 = t, t = testbit(key, t->crit) ? t->right : t->left;\n  }\n  cbt->count--;\n  cbt_leaf_ptr p = (cbt_leaf_ptr) t;\n  if (!t0) {\n    cbt->root = 0;\n  } else {\n    cbt_node_ptr sibling = t0->left == t ? t0->right : t0->left;\n    if (!t00) {  // One-level down: reassign root.\n      cbt->root = sibling;\n    } else {  // Reassign grandparent.\n      if (t00->left == t0) {\n        t00->left = sibling;\n      } else {\n        t00->right = sibling;\n      }\n    }\n    free(t0);\n  }\n  if (p->next) p->next->prev = p->prev;\n  else cbt->last = p->prev;\n  if (p->prev) p->prev->next = p->next;\n  else cbt->first = p->next;\n  free(p->key);\n  void *data = p->data;\n  free(p);\n  return data;\n}\n\nstatic void clear_recurse(cbt_node_ptr t, void (*fn)(void *, const void *)) {\n  if (EXT == t->crit) {\n    cbt_leaf_ptr p = (cbt_leaf_ptr) t;\n    if (fn) fn(p->data, p->key);\n    free(p->key);\n    free(p);\n    return;\n  }\n  clear_recurse(t->left, fn);\n  clear_recurse(t->right, fn);\n  free(t);\n}\n\nvoid cbt_remove_all_with(cbt_t cbt, void (*fn)(void *data, const void *key)) {\n  if (cbt->root) {\n    clear_recurse(cbt->root, fn);\n    cbt->root = 0;\n    cbt->count = 0;\n    cbt->first = cbt->last = 0;\n  }\n}\n\nvoid cbt_remove_all(cbt_t cbt) {\n  if (cbt->root) cbt_remove_all_with(cbt, 0);\n}\n\nvoid cbt_forall(cbt_t cbt, void (*fn)(cbt_it)) {\n  cbt_leaf_ptr p;\n  for (p = cbt->first; p; p = p->next) fn(p);\n}\n\nvoid cbt_forall_at(cbt_t cbt, void (*fn)(void *data, const void *key)) {\n  cbt_leaf_ptr p;\n  for (p = cbt->first; p; p = p->next) fn(p->data, p->key);\n}\n\nsize_t cbt_overhead(cbt_t cbt) {\n  size_t n = sizeof(struct cbt_s);\n  if (!cbt->root) return n;\n  void add(cbt_node_ptr p) {\n    if (p->crit == EXT) {\n      n += sizeof(struct cbt_leaf_s);\n    } else {\n      n += sizeof(struct cbt_node_s);\n      add(p->left);\n      add(p->right);\n    }\n  }\n  add(cbt->root);\n  return n;\n}\n```\n\n\nPlease extract the invariants from the code.\n"
}