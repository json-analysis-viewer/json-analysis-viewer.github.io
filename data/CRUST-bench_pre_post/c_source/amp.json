{
    "name": "amp",
    "amp.c": "\n//\n// amp.c\n//\n// Copyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"amp.h\"\n\n/*\n * Read u32be.\n */\n\nstatic uint32_t\nread_u32_be(char *buf) {\n  uint32_t n = 0;\n  n |= buf[0] << 24;\n  n |= buf[1] << 16;\n  n |= buf[2] << 8;\n  n |= buf[3];\n  return n;\n}\n\n/*\n * Write u32be.\n */\n\nstatic void\nwrite_u32_be(char *buf, uint32_t n) {\n  buf[0] = n >> 24 & 0xff;\n  buf[1] = n >> 16 & 0xff;\n  buf[2] = n >> 8 & 0xff;\n  buf[3] = n & 0xff;\n}\n\n/*\n * Decode the `msg` header in `buf`.\n */\n\nvoid\namp_decode(amp_t *msg, char *buf) {\n  msg->version = buf[0] >> 4;\n  msg->argc = buf[0] & 0xf;\n  msg->buf = buf + 1;\n}\n\n/*\n * Decode `msg` argument, returning a buffer\n * that must be freed by the user and progressing\n * the msg->buf cursor.\n */\n\nchar *\namp_decode_arg(amp_t *msg) {\n  uint32_t len = read_u32_be(msg->buf);\n  msg->buf += 4;\n\n  char *buf = malloc(len);\n  if (!buf) return NULL;\n\n  memcpy(buf, msg->buf, len);\n  msg->buf += len;\n  return buf;\n}\n\n/*\n * Encode the AMP message argv.\n *\n *         0        1 2 3 4     <length>    ...\n *   +------------+----------+------------+\n *   | <ver/argc> | <length> | <data>     | additional arguments\n *   +------------+----------+------------+\n *\n */\n\nchar *\namp_encode(char **argv, int argc) {\n  size_t len = 1;\n  size_t lens[argc];\n\n  // length\n  for (int i = 0; i < argc; ++i) {\n    len += 4;\n    lens[i] = strlen(argv[i]);\n    len += lens[i];\n  }\n\n  // alloc\n  char *buf = malloc(len);\n  char *ret = buf;\n  if (!buf) return NULL;\n\n  // ver/argc\n  *buf++ = AMP_VERSION << 4 | argc;\n\n  // encode\n  for (int i = 0; i < argc; ++i) {\n    size_t len = lens[i];\n\n    write_u32_be(buf, len);\n    buf += 4;\n\n    memcpy(buf, argv[i], len);\n    buf += len;\n  }\n\n  return ret;\n}",
    "amp.h": "\n//\n// amp.h\n//\n// Copyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#ifndef AMP_H\n#define AMP_H\n\n/*\n * Protocol version.\n */\n\n#define AMP_VERSION 1\n\n/*\n * Message struct.\n */\n\ntypedef struct {\n  short version;\n  short argc;\n  char *buf;\n} amp_t;\n\n// prototypes\n\nchar *\namp_encode(char **argv, int argc);\n\nvoid\namp_decode(amp_t *msg, char *buf);\n\nchar *\namp_decode_arg(amp_t *msg);\n\n#endif",
    "c": "",
    "c_pre_post_conditions": "",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\nFunction: function_name\nPre-condition: description of the pre-condition\nPost-condition: description of the post-condition\n```\n\nHere is the code:\n{{amp.c}}\n```c\n// header file\n/*\n//\n// amp.h\n//\n// Copyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#ifndef AMP_H\n#define AMP_H\n\n/*\n * Protocol version.\n */\n\n#define AMP_VERSION 1\n\n/*\n * Message struct.\n */\n\ntypedef struct {\n  short version;\n  short argc;\n  char *buf;\n} amp_t;\n\n// prototypes\n\nchar *\namp_encode(char **argv, int argc);\n\nvoid\namp_decode(amp_t *msg, char *buf);\n\nchar *\namp_decode_arg(amp_t *msg);\n\n#endif*/\n\n//\n// amp.c\n//\n// Copyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"amp.h\"\n\n/*\n * Read u32be.\n */\n\nstatic uint32_t\nread_u32_be(char *buf) {\n  uint32_t n = 0;\n  n |= buf[0] << 24;\n  n |= buf[1] << 16;\n  n |= buf[2] << 8;\n  n |= buf[3];\n  return n;\n}\n\n/*\n * Write u32be.\n */\n\nstatic void\nwrite_u32_be(char *buf, uint32_t n) {\n  buf[0] = n >> 24 & 0xff;\n  buf[1] = n >> 16 & 0xff;\n  buf[2] = n >> 8 & 0xff;\n  buf[3] = n & 0xff;\n}\n\n/*\n * Decode the `msg` header in `buf`.\n */\n\nvoid\namp_decode(amp_t *msg, char *buf) {\n  msg->version = buf[0] >> 4;\n  msg->argc = buf[0] & 0xf;\n  msg->buf = buf + 1;\n}\n\n/*\n * Decode `msg` argument, returning a buffer\n * that must be freed by the user and progressing\n * the msg->buf cursor.\n */\n\nchar *\namp_decode_arg(amp_t *msg) {\n  uint32_t len = read_u32_be(msg->buf);\n  msg->buf += 4;\n\n  char *buf = malloc(len);\n  if (!buf) return NULL;\n\n  memcpy(buf, msg->buf, len);\n  msg->buf += len;\n  return buf;\n}\n\n/*\n * Encode the AMP message argv.\n *\n *         0        1 2 3 4     <length>    ...\n *   +------------+----------+------------+\n *   | <ver/argc> | <length> | <data>     | additional arguments\n *   +------------+----------+------------+\n *\n */\n\nchar *\namp_encode(char **argv, int argc) {\n  size_t len = 1;\n  size_t lens[argc];\n\n  // length\n  for (int i = 0; i < argc; ++i) {\n    len += 4;\n    lens[i] = strlen(argv[i]);\n    len += lens[i];\n  }\n\n  // alloc\n  char *buf = malloc(len);\n  char *ret = buf;\n  if (!buf) return NULL;\n\n  // ver/argc\n  *buf++ = AMP_VERSION << 4 | argc;\n\n  // encode\n  for (int i = 0; i < argc; ++i) {\n    size_t len = lens[i];\n\n    write_u32_be(buf, len);\n    buf += 4;\n\n    memcpy(buf, argv[i], len);\n    buf += len;\n  }\n\n  return ret;\n}```\n\n\nPlease extract the invariants from the code.\n"
}