{
    "name": "aes128_SIMD",
    "aes.c": "#include \"aes.h\"\n\n/*\n * theses functions are used to shift the rows of the state matrix\n * the Shift function shifts the rows to the left\n * the InvShift function shifts the rows to the right\n * the state matrix is a 4x4 matrix\n * the rows are shifted by the row number\n */\n\n\n__attribute__((always_inline))\ninline void Shift(uint8_t state[4][Nb]) {\n    for (int i = 1; i < 4; i++) {\n        uint8_t temp[Nb];\n        for (int j = 0; j < Nb; j++)\n            temp[j] = state[i][(j + i) % Nb];\n\t\tmemcpy(state[i], temp, Nb);    \n\t}\n\t_mm_sfence();\n}\n\n\n__attribute__((always_inline))\ninline void InvShift(uint8_t state[4][Nb]) {\n    for (int i = 1; i < 4; i++) {\n        uint8_t temp[Nb];\n        for (int j = 0; j < Nb; j++) {\n            temp[j] = state[i][(j - i + Nb) % Nb];\n        }\n\t\tmemcpy(state[i], temp, Nb);\t\n    }\n\t_mm_sfence();\n}\n",
    "aes.h": "#ifndef AES_H\n# define AES_H\n\n#include <stdint.h>\n#include <stdio.h>\n#include <immintrin.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define Nb 4\n#define Nk 4\n#define Nr 10\n\n__attribute__((aligned(16)))\nstatic const uint8_t sbox[256] = {\n\t0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,\n\t0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,\n\t0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,\n\t0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,\n\t0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,\n\t0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,\n\t0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,\n\t0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,\n\t0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,\n\t0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,\n\t0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,\n\t0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,\n\t0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,\n\t0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,\n\t0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,\n\t0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16\n};\n\n__attribute__((aligned(16)))\nstatic const uint8_t rsbox[256] = {\n\t0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n\t0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n\t0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n\t0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n\t0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n\t0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n\t0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n\t0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n\t0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n\t0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n\t0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n\t0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n\t0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n\t0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n\t0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n\t0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d\n};\n\n__attribute__((aligned(16)))\nstatic const uint8_t Rcon[11] = {\n\t0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36\n};\n\n/* aes utils */ \n\nuint8_t g_mult(uint8_t a, uint8_t b);\nvoid InvSub(uint8_t state[4][Nb]);\nvoid Sub(uint8_t state[4][Nb]);\n\n/* aes */\n\nvoid Shift(uint8_t state[4][Nb]);\nvoid InvShift(uint8_t state[4][Nb]);\n\n/* matrix */\n\nvoid Columns(uint8_t state[4][Nb]);\nvoid InvColumns(uint8_t state[4][Nb]);\n\n/* keys */\n\nvoid Add(uint8_t state[4][Nb], uint8_t RoundKey[4][Nb]);\nvoid Expansion(uint8_t Key[4 * Nk], uint8_t w[4 * Nb * (Nr + 1)]);\n\n/* padding */\n\nvoid PadBuffer(uint8_t *input, size_t inputLen, uint8_t **output, size_t *outputLen);\nsize_t RemovePadding(uint8_t *input, size_t inputLen); \n\n/* cipher */\n\nvoid Cipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]);\nvoid InvCipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]);\n\n/* base64 */\n\nchar* base64_encode(const unsigned char *input, int len);\n__m128i g_mult_sse(__m128i first, __m128i second);\nvoid Columns_sse(uint8_t state[4][Nb]); \nuint8_t g_mult_sse_byte(uint8_t first, uint8_t second); \n#endif\n",
    "base64.c": "#include \"aes.h\"\n\nconst char base64_table[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nchar* base64_encode(const unsigned char *input, int len) {\n    int output_len = 4 * ((len + 2) / 3);\n    char *output = (char*)malloc(output_len + 1); \n    \n    if (output == NULL) {\n        return NULL;\n    }\n\n    int i, j;\n    for (i = 0, j = 0; i < len; ) {\n        uint32_t octet_a = i < len ? input[i++] : 0;\n        uint32_t octet_b = i < len ? input[i++] : 0;\n        uint32_t octet_c = i < len ? input[i++] : 0;\n\n        uint32_t triple = (octet_a << 16) | (octet_b << 8) | octet_c;\n\n        output[j++] = base64_table[(triple >> 18) & 0x3F];\n        output[j++] = base64_table[(triple >> 12) & 0x3F];\n        output[j++] = base64_table[(triple >> 6) & 0x3F]; \n        output[j++] = base64_table[triple & 0x3F]; \n    }\n\n    for (int k = 0; k < (3 - (len % 3)) % 3; k++) {\n        output[--j] = '=';\n    }\n\n    output[output_len] = '\\0';\n    return output;\n}\n\n",
    "cipher.c": "#include \"aes.h\"\n\n/*\n\t* the Cipher and InvCipher functions are the main functions of the AES algorithm\n\t* they encrypt and decrypt the input respectively\n\t* the input is a 4xNb matrix\n\t* the output is a 4xNb matrix\n\t* the key is a 4xNk matrix\n\t* the w matrix is the expanded key\n\t* the expanded key is a 4xNb*(Nr+1) matrix\n\t* the w matrix is generated using the KeyExpansion function\n*/\n\nvoid Cipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]) {\n\tuint8_t state[4][Nb];\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tstate[i % 4][i / 4] = in[i];\n\tAdd(state, (uint8_t(*)[Nb])&w[0]);\n\tfor (int round = 1; round < Nr; ++round) {\n\t\tSub(state);\n\t\tShift(state);\n\t\tColumns(state);\n\t\tAdd(state, (uint8_t(*)[Nb])&w[round * 4 * Nb]);\n\t}\n\tSub(state);\n\tShift(state);\n\tAdd(state, (uint8_t(*)[Nb])&w[Nr * 4 * Nb]);\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tout[i] = state[i % 4][i / 4];\n}\n\nvoid InvCipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]) {\n\tuint8_t state[4][Nb];\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tstate[i % 4][i / 4] = in[i];\n\tAdd(state, (uint8_t(*)[Nb])&w[Nr * 4 * Nb]);\n\tfor (int round = Nr - 1; round > 0; --round) {\n\t\tInvShift(state);\n\t\tInvSub(state);\n\t\tAdd(state, (uint8_t(*)[Nb])&w[round * 4 * Nb]);\n\t\tInvColumns(state);\n\t}\n\tInvShift(state);\n\tInvSub(state);\n\tAdd(state, (uint8_t(*)[Nb])&w[0]);\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tout[i] = state[i % 4][i / 4];\n}\n",
    "cipher_utils.c": "#include \"aes.h\"\n\n/*\n\t* g_mult is first function that multiplies two polynomials in GF(2^8) \n\t* the polynomials are represented as 8-bit integers\n\t* the result is also an 8-bit integer\n\t* the function is used in the MixColumns and InvMixColumns functions\n*/\n\n__attribute__((always_inline))\ninline uint8_t g_mult(uint8_t first, uint8_t second) {\n    uint8_t p = 0; \n    uint8_t hi_bit_set;\n    __m128i vec_p = _mm_setzero_si128();      \n    __m128i vec_first = _mm_set1_epi8(first);\n\t_mm_prefetch(&vec_first, _MM_HINT_T0);\n    for (int i = 0; i < 8; ++i) {\n        if (second & 1) {\n            __m128i vec_p_part = _mm_set1_epi8(p);\n            vec_p = _mm_xor_si128(vec_p_part, vec_first);\n            p = _mm_extract_epi8(vec_p, 0);\n        }\n\n        hi_bit_set = first & 0x80; \n        first <<= 1; \n        \n        if (hi_bit_set) {\n            first ^= 0x1b; \n        }\n\n        second >>= 1; \n        vec_first = _mm_set1_epi8(first); \n    }\n\n    return p;\n}\n\n/*\n\t* Sub and InvSub are functions that substitute the bytes of the state matrix \n\t* the Sub function uses the sbox table\n\t* the InvSub function uses the rsbox table\n\t* the state matrix is first 4xNb matrix\n\t* the sbox and rsbox tables are 256-byte arrays\n*/\n__attribute__((always_inline))\ninline void Sub(uint8_t state[4][Nb]) {\n    for (int i = 0; i < 4; ++i) {\n        __m128i row = _mm_loadu_si128((__m128i*) &state[i][0]); \n        uint8_t *row_bytes = (uint8_t*)&row;\n        for (int j = 0; j < Nb; ++j) {\n            _mm_prefetch(&sbox[row_bytes[j]], _MM_HINT_T0); \n            row_bytes[j] = sbox[row_bytes[j]]; \n        }\n        _mm_storeu_si128((__m128i*) &state[i][0], row);\n    }\n    _mm_sfence();  \n}\n\n__attribute__((always_inline))\ninline void InvSub(uint8_t state[4][Nb]) {\n    for (int i = 0; i < 4; ++i) {\n        __m128i row = _mm_loadu_si128((__m128i*) &state[i][0]);\n\n        uint8_t *row_bytes = (uint8_t*)&row;\n        for (int j = 0; j < Nb; ++j) {\n            _mm_prefetch(&rsbox[row_bytes[j]], _MM_HINT_T0); \n            row_bytes[j] = rsbox[row_bytes[j]];\n        }\n        _mm_storeu_si128((__m128i*) &state[i][0], row);\n    }\n    _mm_sfence(); \n}\n\n",
    "keys.c": "#include \"aes.h\"\n\nvoid Add(uint8_t state[4][Nb], uint8_t RoundKey[4][Nb]) {\n\tfor (int i = 0; i < 4; ++i)\n\t\tfor (int j = 0; j < Nb; ++j)\n\t\t{\n\t\t\t_mm_prefetch(&RoundKey[i][j], _MM_HINT_T0);\n\t\t\tstate[i][j] ^= RoundKey[i][j];\n\t\t}\n}\n\nvoid Expansion(uint8_t Key[4 * Nk], uint8_t w[4 * Nb * (Nr + 1)]) {\n\tint i;\n\t__m128i temp;\n\tuint8_t temp_bytes[16] = {0};\n\tmemset(w, 0, 4 * Nb * (Nr + 1));\n\tfor (i = 0; i < Nk * 4; i += 16) {\n\t\t_mm_prefetch(&Key[i] + 16, _MM_HINT_T0);\n\t\ttemp = _mm_loadu_si128((__m128i*)&Key[i]);\n\t\t_mm_storeu_si128((__m128i*)&w[i], temp);\n\t\t_mm_storeu_si128((__m128i*)&w[i + 4], temp);\n\t\t_mm_storeu_si128((__m128i*)&w[i + 8], temp);\n\t\t_mm_storeu_si128((__m128i*)&w[i + 12], temp);\n\t}\n\n\ti = Nk;\n\twhile (i < Nb * (Nr + 1)) {\n\t\ttemp = _mm_loadu_si128((__m128i*)&w[4 * (i - 1)]);\n\t\tif (i % Nk == 0) {\n\t\t\ttemp = _mm_shuffle_epi32(temp, _MM_SHUFFLE(3, 0, 1, 2));\n\t\t\t_mm_storeu_si128((__m128i*)temp_bytes, temp);\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t_mm_prefetch(&sbox[temp_bytes[j]], _MM_HINT_T0);\n\t\t\t\ttemp_bytes[j] = sbox[temp_bytes[j]];\n\t\t\t}\n\t\t\ttemp_bytes[0] ^= Rcon[i / Nk];\n\t\t\ttemp = _mm_loadu_si128((__m128i*)temp_bytes);\n\t\t} else if (Nk > 6 && (i % Nk == 4)) {\n\t\t\t_mm_storeu_si128((__m128i*)temp_bytes, temp);\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t_mm_prefetch(&sbox[temp_bytes[j]], _MM_HINT_T0);\n\t\t\t\ttemp_bytes[j] = sbox[temp_bytes[j]];\n\t\t\t\ttemp_bytes[j + 1] = sbox[temp_bytes[j + 1]];\n\t\t\t\ttemp_bytes[j + 2] = sbox[temp_bytes[j + 2]];\n\t\t\t\ttemp_bytes[j + 3] = sbox[temp_bytes[j + 3]];\n\t\t\t}\n\t\t\ttemp = _mm_loadu_si128((__m128i*)temp_bytes);\n\t\t}\n\n\t\t__m128i w_i_Nk = _mm_loadu_si128((__m128i*)&w[4 * (i - Nk)]);\n\t\ttemp = _mm_xor_si128(temp, w_i_Nk);\n\t\t_mm_storeu_si128((__m128i*)&w[4 * i], temp);\n\n\t\ti += 4; \n\t}\n}\n",
    "matrix.c": "#include \"aes.h\"\n\n__attribute__((always_inline))\ninline void Columns(uint8_t state[4][Nb]) {\n\tuint8_t temp_state[4][Nb];\n\tfor (int c = 0; c < Nb; ++c) {\n\t\t_mm_prefetch(&state[0][c] + Nb, _MM_HINT_T0);\n\t\ttemp_state[0][c] = g_mult(0x02, state[0][c]) ^ g_mult(0x03, state[1][c]) ^ state[2][c] ^ state[3][c];\n\t\ttemp_state[1][c] = state[0][c] ^ g_mult(0x02, state[1][c]) ^ g_mult(0x03, state[2][c]) ^ state[3][c];\n\t\ttemp_state[2][c] = state[0][c] ^ state[1][c] ^ g_mult(0x02, state[2][c]) ^ g_mult(0x03, state[3][c]);\n\t\ttemp_state[3][c] = g_mult(0x03, state[0][c]) ^ state[1][c] ^ state[2][c] ^ g_mult(0x02, state[3][c]);\n\t}\n\tfor (int i = 0; i < 4; ++i)\n\t\t_mm_prefetch(&temp_state[i][0], _MM_HINT_T0);\t\n\tmemcpy(state, temp_state, 4 * Nb);\n\t_mm_sfence();\n}\n\n\n__attribute__((always_inline))\ninline void InvColumns(uint8_t state[4][Nb]) {\n\tuint8_t temp_state[4][Nb];\n\tfor (int c = 0; c < Nb; ++c) {\n\t\t_mm_prefetch(&state[0][c] + Nb, _MM_HINT_T0);\n\t\ttemp_state[0][c] = g_mult(0x0e, state[0][c]) ^ g_mult(0x0b, state[1][c]) ^ g_mult(0x0d, state[2][c]) ^ g_mult(0x09, state[3][c]);\n\t\ttemp_state[1][c] = g_mult(0x09, state[0][c]) ^ g_mult(0x0e, state[1][c]) ^ g_mult(0x0b, state[2][c]) ^ g_mult(0x0d, state[3][c]);\n\t\ttemp_state[2][c] = g_mult(0x0d, state[0][c]) ^ g_mult(0x09, state[1][c]) ^ g_mult(0x0e, state[2][c]) ^ g_mult(0x0b, state[3][c]);\n\t\ttemp_state[3][c] = g_mult(0x0b, state[0][c]) ^ g_mult(0x0d, state[1][c]) ^ g_mult(0x09, state[2][c]) ^ g_mult(0x0e, state[3][c]);\n\t}\n\tfor (int i = 0; i < 4; ++i)\n\t\t_mm_prefetch(&temp_state[i][0], _MM_HINT_T0);\n\tmemcpy(state, temp_state, 4 * Nb);\n\t_mm_sfence();\n}\n\n\n\n",
    "padding.c": "#include \"aes.h\"\n\nvoid PadBuffer(uint8_t *input, size_t inputLen, uint8_t **output, size_t *outputLen) {\n    size_t blockSize = 16;\n    size_t paddedLen = ((inputLen / blockSize) + 1) * blockSize;\n    uint8_t *paddedData = _mm_malloc(paddedLen, 16);\n    memcpy(paddedData, input, inputLen);\n    uint8_t padValue = paddedLen - inputLen;\n    memset(paddedData + inputLen, padValue, padValue);\n    *output = paddedData;\n    *outputLen = paddedLen;\n}\n\nsize_t RemovePadding(uint8_t *input, size_t inputLen) {\n    if (inputLen == 0) return 0;\n    uint8_t padValue = input[inputLen - 1];\n    if (padValue < 1 || padValue > 16) {\n        return inputLen;\n    }\n    for (size_t i = inputLen - padValue; i < inputLen; ++i) {\n        if (input[i] != padValue) {\n            return inputLen;\n        }\n    }\n    return inputLen - padValue;\n}\n",
    "c_rust": "",
    "c_rust_pre_post_conditions": "// =================================================\n// aes.rs\n// =================================================\n\nFunction: shift\nPreconditions:\n- `state` is a valid non\u2010null mutable reference to a 4\u00d7NB (`[[u8; NB]; 4]`) byte matrix.\n- NB == 4.\nPostconditions:\n- For each row i in 1..4 and each column j in 0..NB:\n    state[i][j] (after) == state_old[i][(j + i) % NB].\n- Row 0 is unchanged.\n- A full memory fence (`_mm_sfence`) is implied.\n\nFunction: inv_shift\nPreconditions:\n- `state` is a valid non\u2010null mutable reference to a 4\u00d7NB (`[[u8; NB]; 4]`) byte matrix.\n- NB == 4.\nPostconditions:\n- For each row i in 1..4 and each column j in 0..NB:\n    state[i][j] (after) == state_old[i][(j + NB - i) % NB].\n- Row 0 is unchanged.\n- A full memory fence (`_mm_sfence`) is implied.\n\n\n// =================================================\n// base64.rs\n// =================================================\n\nFunction: base64_encode\nSignature: (&[u8], usize) -> String\nPreconditions:\n- `input` is a valid slice of bytes of length \u2265 `len`.\n- `len` \u2265 0.\nPostconditions:\n- Returns a newly allocated `String` of length `4 * ((len + 2) / 3)`.\n- The string is the Base64 encoding of `input[0..len]`, using the standard\n  \u201cA\u2013Z a\u2013z 0\u20139 + /\u201d table, with \u2018=\u2019 padding in the final up to 2 bytes.\n- The returned `String` is null\u2010terminated internally (Rust string invariant).\n\nFunction: g_mult_sse_byte\nSignature: (u8, u8) -> u8\nPreconditions:\n- `first` and `second` are any valid 8\u2010bit values.\nPostconditions:\n- Returns exactly the GF(2^8) product of `first` and `second`\n  computed by the C SSE\u2010byte routine (identical to `g_mult` result).\n\nFunction: g_mult_sse\nSignature: (__m128i, __m128i) -> __m128i\nPreconditions:\n- `first` and `second` are valid SSE registers containing arbitrary bytes.\nPostconditions:\n- Each byte lane in the returned `__m128i` is the GF(2^8) product of the\n  corresponding lanes of `first` and `second`, as in the C `_mm` implementation.\n\nFunction: columns_sse\nPreconditions:\n- `state` is a valid non\u2010null mutable reference to a 4\u00d7NB (`[[u8; NB]; 4]`) matrix.\n- NB == 4.\nPostconditions:\n- Performs the AES \u201cMixColumns\u201d on `state` using SSE:\n    For each column c in 0..NB:\n      temp[0][c] = 2\u00b7s0 \u2295 3\u00b7s1 \u2295 s2 \u2295 s3\n      temp[1][c] = s0 \u2295 2\u00b7s1 \u2295 3\u00b7s2 \u2295 s3\n      temp[2][c] = s0 \u2295 s1 \u2295 2\u00b7s2 \u2295 3\u00b7s3\n      temp[3][c] = 3\u00b7s0 \u2295 s1 \u2295 s2 \u2295 2\u00b7s3\n- Writes back `temp` into `state` and issues an `_mm_sfence`.\n\n\n// =================================================\n// cipher.rs\n// =================================================\n\nFunction: cipher\nSignature: (&[u8; 4*NB], &mut [u8; 4*NB], &[u8; 4*NB*(NR+1)]) -> ()\nPreconditions:\n- `in_data` is a reference to exactly 4*NB (=16) bytes.\n- `out` is a mutable reference to 4*NB bytes.\n- `w` is a reference to the expanded key schedule of length 4*NB*(NR+1).\n- NB==4, NR==10.\nPostconditions:\n- Writes into `out` the AES encryption of `in_data` under the key schedule `w`\n  exactly as in the C `Cipher` routine.\n\nFunction: inv_cipher\nSignature: (&[u8; 4*NB], &mut [u8; 4*NB], &[u8; 4*NB*(NR+1)]) -> ()\nPreconditions:\n- Same as `cipher`.\nPostconditions:\n- Writes into `out` the AES decryption of `in_data` under the key schedule `w`\n  exactly as in the C `InvCipher` routine.\n\n\n// =================================================\n// cipher_utils.rs\n// =================================================\n\nFunction: g_mult\nSignature: (u8, u8) -> u8\nPreconditions:\n- `first` and `second` are any valid 8\u2010bit values.\nPostconditions:\n- Returns the GF(2^8) product as computed by the C `g_mult` function.\n\nFunction: sub\nSignature: (&mut [[u8; NB]; 4]) -> ()\nPreconditions:\n- `state` is a valid non\u2010null mutable 4\u00d7NB matrix.\n- NB == 4.\nPostconditions:\n- For each i,j: `state[i][j]` becomes `sbox[old state[i][j]]`.\n- Issues an `_mm_sfence`.\n\nFunction: inv_sub\nSignature: (&mut [[u8; NB]; 4]) -> ()\nPreconditions:\n- Same as `sub`.\nPostconditions:\n- For each i,j: `state[i][j]` becomes `rsbox[old state[i][j]]`.\n- Issues an `_mm_sfence`.\n\n\n// =================================================\n// keys.rs\n// =================================================\n\nFunction: add\nSignature: (&mut [[u8; NB]; 4], &[[u8; NB]; 4]) -> ()\nPreconditions:\n- `state` and `round_key` are valid 4\u00d7NB matrices.\n- NB == 4.\nPostconditions:\n- For each i,j: `state[i][j] ^= round_key[i][j]`.\n\nFunction: expansion\nSignature: (&[u8; 4*NK], &mut [u8; 4*NB*(NR+1)]) -> ()\nPreconditions:\n- `key` is a reference to 4*NK (=16) bytes.\n- `w` is a mutable reference to 4*NB*(NR+1) bytes.\n- NB==4, NK==4, NR==10.\nPostconditions:\n- Writes into `w` the AES key\u2010schedule expansion as per the C `Expansion`:\n  - Copies initial key into the first Nk words,\n  - Iteratively computes subsequent words with `sbox`, `Rcon`, and XOR logic.\n\n\n// =================================================\n// matrix.rs\n// =================================================\n\nFunction: columns\nSignature: (&mut [[u8; NB]; 4]) -> ()\nPreconditions:\n- `state` is a valid non\u2010null mutable 4\u00d7NB matrix.\n- NB == 4.\nPostconditions:\n- Performs the standard AES MixColumns exactly as the C `Columns` inline routine,\n  then issues an `_mm_sfence`.\n\nFunction: inv_columns\nSignature: (&mut [[u8; NB]; 4]) -> ()\nPreconditions:\n- Same as `columns`.\nPostconditions:\n- Performs the AES inverse MixColumns exactly as the C `InvColumns` inline routine,\n  then issues an `_mm_sfence`.\n\n\n// =================================================\n// padding.rs\n// =================================================\n\nFunction: pad_buffer\nSignature: (&[u8], usize, &mut Vec<u8>, &mut usize) -> ()\nPreconditions:\n- `input` is a valid slice of length \u2265 `input_len`.\n- `input_len` \u2265 0.\nPostconditions:\n- Allocates a new buffer `output` aligned to 16 bytes of length\n  `paddedLen = ((input_len / 16) + 1) * 16`.\n- Copies `input[0..input_len]` into `output`.\n- Pads the remaining `paddedLen \u2212 input_len` bytes with the single byte\n  value `padValue = paddedLen \u2212 input_len`.\n- Writes `paddedLen` into `*output_len`.\n\nFunction: remove_padding\nSignature: (&[u8], usize) -> usize\nPreconditions:\n- `input` is a valid slice of length \u2265 `input_len`.\n- `input_len` \u2265 0.\nPostconditions:\n- If `input_len == 0`, returns 0.\n- Let `padValue = input[input_len \u2212 1]`.\n  - If `padValue < 1 || padValue > 16`, returns `input_len`.\n  - Else if any byte in `input[input_len\u2212padValue .. input_len]` \u2260 `padValue`,\n    returns `input_len`.\n  - Otherwise returns `input_len \u2212 padValue`.",
    "rri_prompt": ""
}