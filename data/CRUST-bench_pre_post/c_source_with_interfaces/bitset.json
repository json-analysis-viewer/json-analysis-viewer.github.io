{
    "name": "bitset",
    "bitset.c": "/*\n * Copyright (c) 2020 Adil Benhlal <adil.benhlal@outlook.fr>\n *\n * bitset is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n */\n#include <errno.h>\n#include \"./include/cborg/bitset.h\"\n\nbitset_t *cb_bitset_new(size_t nb_bits) {\n  bitset_t *bs = (bitset_t *)calloc(1, sizeof(bitset_t));\n  bs->array = (uint8_t *)calloc(__bitset_size(nb_bits), sizeof(uint8_t));\n  bs->size = nb_bits;\n  return bs;\n}\n\nvoid cb_bitset_delete(bitset_t *bs) {\n  free(bs->array);\n  free(bs);\n}\n\nsize_t cb_bitset_count(bitset_t *bs) {\n  return (bs->flip ? (bs->size - bs->count) : bs->count);\n}\n\nsize_t cb_bitset_size(bitset_t *bs) { return bs->size; }\n\nbool cb_bitset_test(bitset_t *bs, size_t idx) {\n  return bs->flip ^\n         ((bs->array[__bitset_byte(idx)] & __bitset_bit_mask(idx)) != 0);\n}\n\nbool cb_bitset_any(bitset_t *bs) {\n  return (bs->flip ? (bs->count != bs->size) : (bs->count != 0));\n}\n\nbool cb_bitset_none(bitset_t *bs) { return !(cb_bitset_any(bs)); }\n\nbool cb_bitset_all(bitset_t *bs) {\n  return (bs->flip ? (bs->count == 0) : (bs->count == bs->size));\n}\n\nvoid cb_bitset_set(bitset_t *bs, size_t idx, bool value) {\n  bool flip_value = bs->flip ? !value : value;\n  size_t previous_count = __builtin_popcount(bs->array[__bitset_byte(idx)]);\n  if (flip_value) {\n    bs->array[__bitset_byte(idx)] |= __bitset_bit_mask(idx);\n  } else {\n    bs->array[__bitset_byte(idx)] &= ~__bitset_bit_mask(idx);\n  }\n  bs->count +=\n      (__builtin_popcount(bs->array[__bitset_byte(idx)]) - previous_count);\n}\n\nvoid cb_bitset_reset(bitset_t *bs) {\n  memset(bs->array, 0, __bitset_size(bs->size));\n  bs->flip = false;\n  bs->count = 0;\n}\n\nvoid cb_bitset_flip(bitset_t *bs) { bs->flip = !(bs->flip); }\n\nchar *cb_bitset_to_string(bitset_t *bs) {\n  char *res = (char *)malloc(sizeof(char) * (bs->size + 1));\n  for (size_t i = 0; i < bs->size; i++) {\n    res[i] = cb_bitset_test(bs, i) ? '1' : '0';\n  }\n  res[bs->size] = '\\0';\n  return res;\n}\n\nvoid cb_bitset_write(bitset_t *bs, const char *path) {\n  FILE *file = fopen(path, \"wb\");\n  size_t bytes_to_write = __bitset_size(bs->size);\n  size_t bytes_writen = 0;\n  size_t total_writen = 0;\n\n  if (file == NULL) {\n    fprintf(stdout, \"%s\\n\", strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n\n  fwrite(&(bs->size), sizeof(size_t), 1, file);\n  fwrite(&(bs->count), sizeof(size_t), 1, file);\n  fwrite(&(bs->flip), sizeof(bool), 1, file);\n  while ((bytes_writen = fwrite(bs->array + total_writen, sizeof(uint8_t),\n                                bytes_to_write - total_writen, file)) > 0) {\n    total_writen += bytes_writen;\n  }\n\n  fclose(file);\n}\n\nbitset_t *cb_bitset_read(const char *path) {\n  FILE *file = fopen(path, \"rb\");\n  size_t size = 0;\n\n  if (file == NULL) {\n    fprintf(stdout, \"%s\\n\", strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n\n  fread(&size, sizeof(size_t), 1, file);\n  bitset_t *bs = cb_bitset_new(size);\n  fread(&(bs->count), sizeof(size_t), 1, file);\n  fread(&(bs->flip), sizeof(bool), 1, file);\n  while (fread(bs->array, sizeof(uint8_t), bs->size, file) > 0);\n\n  fclose(file);\n  return bs;\n}\n",
    "bitset.h": "/*\n * Copyright (c) 2020 Adil Benhlal <adil.benhlal@outlook.fr>\n *\n * bitset is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n */\n\n#ifndef _CBORG_BITSET_H\n#define _CBORG_BITSET_H\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n// Returns the number of bytes needed to store a number of bits\n#define __bitset_size(nbits) ((nbits + 7) >> 3)\n\n// Returns the index of the bit in bitset->array (=idx/8)\n#define __bitset_byte(idx) ((idx) >> 3)\n\n// Returns the bit mask\n#define __bitset_bit_mask(idx) (1 << ((idx)&0x7))\n\n// TODO: format bitset using cbor\n// TODO: bitset thread-safe\n\ntypedef struct bitset_t {\n  bool flip;\n  size_t size;\n  size_t count;\n  uint8_t *array;\n} bitset_t;\n\nbitset_t *cb_bitset_new(size_t nb_bits);\n\nvoid cb_bitset_delete(bitset_t *bs);\n\nsize_t cb_bitset_count(bitset_t *bs);\n\nsize_t cb_bitset_size(bitset_t *bs);\n\nbool cb_bitset_test(bitset_t *bs, size_t idx);\n\nbool cb_bitset_any(bitset_t *bs);\n\nbool cb_bitset_none(bitset_t *bs);\n\nbool cb_bitset_all(bitset_t *bs);\n\nvoid cb_bitset_set(bitset_t *bs, size_t idx, bool value);\n\nvoid cb_bitset_reset(bitset_t *bs);\n\nvoid cb_bitset_flip(bitset_t *bs);\n\nchar *cb_bitset_to_string(bitset_t *bs);\n\nvoid cb_bitset_write(bitset_t *bs, const char *path);\n\nbitset_t *cb_bitset_read(const char *path);\n\n#endif\n",
    "c_rust": "",
    "c_rust_pre_post_conditions": "// Preconditions and postconditions for the Bitset Rust interface,\n// derived from the C implementation in bitset.c / bitset.h.\n\nFunction: new\nPreconditions:\n- nb_bits: usize (any value)  \nPostconditions:\n- Returns a Bitset with:\n  - flip == false\n  - size == nb_bits\n  - count == 0\n  - array.len() == (nb_bits + 7) >> 3\n  - every byte in array == 0\n\nFunction: delete\nPreconditions:\n- self: Bitset (must be a valid, initialized Bitset)  \nPostconditions:\n- All resources owned by the Bitset are freed\n- The Bitset must not be used after this call\n\nFunction: count\nPreconditions:\n- &self: Bitset (valid instance)  \nPostconditions:\n- Returns:\n  - if self.flip == false, then self.count\n  - if self.flip == true, then self.size - self.count\n\nFunction: size\nPreconditions:\n- &self: Bitset (valid instance)  \nPostconditions:\n- Returns self.size\n\nFunction: test\nPreconditions:\n- &self: Bitset (valid instance)\n- idx < self.size  \nPostconditions:\n- Returns the bit value at index idx, interpreted as:\n    self.flip xor ((self.array[idx>>3] & (1<< (idx & 0x7))) != 0)\n\nFunction: any\nPreconditions:\n- &self: Bitset (valid instance)  \nPostconditions:\n- Returns true if at least one bit is set, i.e.\n    if flip==false then (count != 0) else (count != size)\n\nFunction: none\nPreconditions:\n- &self: Bitset (valid instance)  \nPostconditions:\n- Returns !(self.any())\n\nFunction: all\nPreconditions:\n- &self: Bitset (valid instance)  \nPostconditions:\n- Returns true if every bit is set, i.e.\n    if flip==false then (count == size) else (count == 0)\n\nFunction: set\nPreconditions:\n- &mut self: Bitset (valid instance)\n- idx < self.size\n- value: bool (any)  \nPostconditions:\n- After the call:\n  - The bit at idx yields value when read via test()\n  - self.count is adjusted by the difference between the new bit and the old bit\n  - self.flip remains unchanged\n  - All other bits remain unchanged\n\nFunction: reset\nPreconditions:\n- &mut self: Bitset (valid instance)  \nPostconditions:\n- All bits cleared to 0\n- self.flip == false\n- self.count == 0\n\nFunction: flip\nPreconditions:\n- &mut self: Bitset (valid instance)  \nPostconditions:\n- self.flip toggled (true\u2192false or false\u2192true)\n- self.size and self.count unchanged\n- array contents unchanged\n\nFunction: to_string\nPreconditions:\n- &self: Bitset (valid instance)  \nPostconditions:\n- Returns a String s of length == self.size\n- For each i in 0..self.size:\n    s[i] == '1' if test(i) == true, else '0'\n\nFunction: write\nPreconditions:\n- &self: Bitset (valid instance)\n- path: &str (writable file path)  \nPostconditions:\n- On Ok(()):\n  - A file at path contains, in order:\n    1) self.size as usize\n    2) self.count as usize\n    3) self.flip as bool\n    4) self.array raw bytes (length = (size+7)>>3)\n- On Err(e):\n  - No guarantee on file contents (propagates I/O error)\n\nFunction: read\nPreconditions:\n- path: &str (readable file path containing valid bitset data)  \nPostconditions:\n- On Ok(bitset):\n  - bitset.size, bitset.count, bitset.flip, bitset.array match the file contents\n  - bitset.array.len() == (size + 7) >> 3\n- On Err(e):\n  - Returns the I/O error; no Bitset constructed",
    "rri_prompt": ""
}