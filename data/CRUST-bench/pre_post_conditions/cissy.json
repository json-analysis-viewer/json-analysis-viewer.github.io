{
    "name": "cissy",
    "manual_invs_pre_post": "```rust\nuse crate::{RangeElement, RangeType};\n\n/// Verifies that a range list satisfies key structural invariants:\n/// - Starts are positive and non-decreasing along the list.\n/// - SINGLE ranges have end == start.\n/// - STARTEND ranges have end >= start.\n/// - GREATER_EQUAL ranges impose no end constraint.\npub fn check_invariants(list: &Option<Box<RangeElement>>) {\n    let mut prev_start: u32 = 0;\n    let mut current = list.as_ref();\n    while let Some(node) = current {\n        // 1) start must be strictly positive\n        assert!(\n            node.start > 0,\n            \"Invariant violated: element.start must be > 0, got {}\",\n            node.start\n        );\n\n        // 2) check end vs start depending on rangetype\n        match node.rangetype {\n            RangeType::Single => {\n                assert_eq!(\n                    node.end, node.start,\n                    \"Invariant violated: SINGLE range must have end == start (start={}, end={})\",\n                    node.start, node.end\n                );\n            }\n            RangeType::StartEnd => {\n                assert!(\n                    node.end >= node.start,\n                    \"Invariant violated: STARTEND range must have end >= start (start={}, end={})\",\n                    node.start, node.end\n                );\n            }\n            RangeType::GreaterEqual => {\n                // no check on end\n            }\n        }\n\n        // 3) list must be sorted by non-decreasing start\n        assert!(\n            node.start >= prev_start,\n            \"Invariant violated: list not sorted by start (prev_start={}, this_start={})\",\n            prev_start,\n            node.start\n        );\n\n        prev_start = node.start;\n        current = node.next.as_ref().map(|b| &**b);\n    }\n}\n\n//\n// Invariants enforced:\n// - Every range element\u2019s `start` is > 0.\n// - For `Single` ranges, `end == start`.\n/// - For `StartEnd` ranges, `end >= start`.\n/// - The list is sorted by non-decreasing `start` values.\n```",
    "rri_prompt": "Task: Extract invariants from C  code and emit a Rust function called `check_invariants`\nRole: You are a rigorous program analyst. You will study a C program and its Rust interface files. Your job is to derive pre and post conditions of the program. \nDo any reasoning internally; only output the requested sections and code.\n\nInputs\n\n1. C function under analysis.\n2. C test case that is currently failing.\n3. Rust interface relevant to the C function.\n\nYou must implement a single Rust function named `check_invariants`:\n1. Perform non-trivial pre and post condition checks derived from the C program\u2019s behavior.\n2. Use `assert!` / `assert_eq!` with clear failure messages that include key values.\n3. You should not add unit tests but rather infer general invariants that hold for all valid states of the program.\n4. A brief bullet list titled \u201cInvariants enforced\u201d summarizing each invariant in plain language (no derivations or chain-of-thought; just the final invariants).\n\nConstraints & style\n\n1. Use only items available in the Rust interface (no new public types or deps).\n2. Prefer safe Rust; do not use unsafe unless the interface explicitly requires it.\n3. No logging/printing. No randomness. No external crates.\n4. If the interface already includes a validator that returns Result, you may call it and assert on Ok/Err instead of re-implementing internals.\n\nImplementation checklist\n1. Read the Rust interface to understand how to construct states.\n2. From the C code, enumerate and infer candidate invariants. Keep only those that must hold for all reachable states.\n3. Valid cases: assert the invariant holds.\n\nNow you will be provided with the C source code and Rust interface definitions.\n\nC source (program under analysis):\n```c\nstruct rangeElement* rangeCreate() {\n  struct rangeElement* ptr = malloc(sizeof(struct rangeElement));\n  if (ptr == NULL) {\n    fprintf(stderr, \"rangeCreate: malloc error\\n\");\n    exit(-1);\n  }\n  ptr->start = -1;\n  ptr->end = -1;\n  ptr->next = NULL;\n  return ptr;\n}\n\n// pass NULL list to create new list\n/**\n* add a n-m range to the list\n*\n* Add start-end range.  Create a new list if necessary\n*\n* @param start beginning \n* @param end ending\n* @param startOfList list\n* @return list\n*/\nstruct rangeElement* rangeAddStartEnd(uint32_t start, uint32_t end, struct rangeElement* startOfList) {\n  assert(start > 0);\n  assert(end >= start);\n  if (startOfList == NULL) {\n    startOfList = rangeCreate();\n    startOfList->start = start;\n    if (start == end) {\n      startOfList->rangetype = SINGLE;\n    }\n    else {\n      startOfList->rangetype = STARTEND;\n      startOfList->end = end;\n    }\n    return startOfList;\n  }\n  struct rangeElement* ptr = startOfList;\n  //advance to the end of list\n  while (ptr->next != NULL) {\n    ptr = ptr->next;\n  }\n  ptr->next = rangeCreate();\n  ptr = ptr->next;\n  ptr->start = start;\n  if (end == start) {\n    ptr->rangetype = SINGLE;\n  }\n  else {\n    ptr->rangetype = STARTEND;\n    ptr->end = end;\n  }\n  return startOfList;\n}\n```\nC Tests (the test cases that are failing):\n\n```c\nint main(int argc, char** argv) {\n  printf(\"start\\n\");\n  struct rangeElement* list = NULL;\n  bool b;\n  int bufsize=1024;\n  char buf[bufsize];\n  char* rv;\n\n  //////////////////////////////////////////////\n  list = rangeAddSingle(5, list);\n  printf(\"list = 5\\n\");\n\n  printf(\"test: not contains 4\\n\");\n  b = rangeContainsNum(4, list);\n  assert(b == false);\n  printf(\"\\tok\\n\");\n\n  printf(\"test: contains 5\\n\");\n  b = rangeContainsNum(5, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test: element to string\\n\");\n  memset(buf, 0, bufsize);\n  rangeElementToString(buf, bufsize, list);\n  rv = \"[5]\";\n  printf(\"\\t%s == %s ???\", rv, buf);\n  assert(strcmp(rv, buf) == 0);\n  printf(\"\\tok\\n\");\n\n\n  printf(\"test: list to string\\n\");\n  memset(buf, 0, bufsize);\n  rangeListToString(buf, bufsize, list);\n  rv = \"[5]\";\n  printf(\"\\t%s == %s ???\\n\", rv, buf);\n  assert(strcmp(\"[5]\", buf) == 0);\n  printf(\"\\tok\\n\");\n\n  printf(\"test: free\\n\");\n  rangeFree(list);\n  assert(true);\n  printf(\"\\tok\\n\");\n\n  /////////////////////////////////////////////////\n  list = NULL;\n  list = rangeAddStartEnd(5, 10, list);\n\n  printf(\"test b1:\\n\");\n  b = rangeContainsNum(4, list);\n  assert(b == false);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b2:\\n\");\n  b = rangeContainsNum(5, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b3:\\n\");\n  b = rangeContainsNum(7, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b4:\\n\");\n  b = rangeContainsNum(10, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b5:\\n\");\n  b = rangeContainsNum(12, list);\n  assert(b == false);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b6:\\n\");\n  memset(buf, 0, bufsize);\n  rangeElementToString(buf, bufsize, list);\n  rv = \"[5-10]\";\n  printf(\"\\t%s == %s ???\", rv, buf);\n  assert(strcmp(rv, buf) == 0);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b7:\\n\");\n  memset(buf, 0, bufsize);\n  rangeListToString(buf, bufsize, list);\n  rv = \"[5-10]\";\n  printf(\"\\t%s == %s ???\", rv, buf);\n  assert(strcmp(rv, buf) == 0);\n  printf(\"\\tok\\n\");\n\n  rangeFree(list);\n\n  /////////////////////////////////////////////////\n  list = NULL;\n  list = rangeAddStartEnd(5, 10, list);\n  list = rangeAddSingle(15, list);\n  list = rangeAddGreaterEqual(40, list);\n\n\n  printf(\"test c1:\\n\");\n  b = rangeContainsNum(1, list);\n  assert(b == false);\n  printf(\"\\tok\\n\");\n\n  printf(\"test c2:\\n\");\n  b = rangeContainsNum(6, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test c3:\\n\");\n  b = rangeContainsNum(12, list);\n  assert(b == false);\n  printf(\"\\tok\\n\");\n\n  printf(\"test c4:\\n\");\n  b = rangeContainsNum(50, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test c6:\\n\");\n  memset(buf, 0, bufsize);\n  rangeElementToString(buf, bufsize, list);\n  printf(\"\\t%s\", buf);\n  rv = \"[5-10]\";\n  assert(strcmp(buf, rv) == 0);\n  printf(\"\\tok\\n\");\n\n  printf(\"test c7:\");\n  memset(buf, 0, bufsize);\n  rangeListToString(buf, bufsize, list);\n  rv = \"[5-10][15][40-]\";\n  printf(\"\\t%s == %s ???\", rv, buf);\n  assert(strcmp(buf, rv) == 0);\n  printf(\"\\tok\\n\");\n  \n  rangeFree(list);\n\n  /////////////////////////////////////////////////\n  list = NULL;\n  list = rangeAddSingle(2, list);\n  list = rangeAddStartEnd(2, 4, list);\n\n  printf(\"testd:\");\n  memset(buf, 0, bufsize);\n  rangeListToString(buf, bufsize, list);\n  rv = \"[2][2-4]\";\n  printf(\"\\t%s == %s ???\\n\", rv, buf);\n  assert(strcmp(buf, rv) == 0);\n  printf(\"\\tok\\n\");\n\n\n  printf(\"test:\");\n  struct rangeElement* l2 = parseIntRanges(\"2,2-4\");\n  memset(buf, 0, bufsize);\n  rangeListToString(buf, bufsize, l2);\n  rv = \"[2][2-4]\";\n  printf(\"\\t%s == %s ???\\n\", rv, buf);\n  assert(strcmp(buf, rv) == 0);\n  printf(\"\\tok\\n\");\n  \n\n  return 0;\n}\n```\n\nRust test that fails (the test case that currently fails):\n```rust\n#[test]\nfn test_range() {\nlet mut list = None;\nlet mut buf = String::new();\nlet bufsize = 1024;\n\nlist = RangeElement::add_single(5, list);\nassert!(!RangeElement::contains_num(4, &list));\nassert!(RangeElement::contains_num(5, &list));\n\nbuf.clear();\nRangeElement::list_to_string(&mut buf, bufsize, &list);\nassert_eq!(buf, \"[5]\");\n\nlist = RangeElement::add_start_end(5, 10, list);\nassert!(!RangeElement::contains_num(4, &list));\nassert!(RangeElement::contains_num(5, &list));\nassert!(RangeElement::contains_num(7, &list));\nassert!(RangeElement::contains_num(10, &list));\nassert!(!RangeElement::contains_num(12, &list));\n\nbuf.clear();\nRangeElement::list_to_string(&mut buf, bufsize, &list);\nassert_eq!(buf, \"[5-10]\");\n\nlist = RangeElement::add_start_end(5, 10, list);\nlist = RangeElement::add_single(15, list);\nlist = RangeElement::add_greater_equal(40, list);\nassert!(!RangeElement::contains_num(1, &list));\nassert!(RangeElement::contains_num(6, &list));\nassert!(!RangeElement::contains_num(12, &list));\nassert!(RangeElement::contains_num(50, &list));\n\nbuf.clear();\nRangeElement::list_to_string(&mut buf, bufsize, &list);\nassert_eq!(buf, \"[5-10][15][40-]\");\n\nlist = RangeElement::add_single(2, list);\nlist = RangeElement::add_start_end(2, 4, list);\nbuf.clear();\nRangeElement::list_to_string(&mut buf, bufsize, &list);\nassert_eq!(buf, \"[2][2-4]\");\n\nlet l2 = RangeElement::parse_int_ranges(\"2,2-4\");\nbuf.clear();\nRangeElement::list_to_string(&mut buf, bufsize, &l2);\nassert_eq!(buf, \"[2][2-4]\");\n}\n\nfn main() {}\n```\n\n\nRust interface files (types, functions, signatures you MUST use to build test fixtures):\n```rust\npub fn add_start_end(start: u32, end: u32, start_of_list: Option<Box<RangeElement>>) -> Option<Box<RangeElement>> {\n    unimplemented!();\n}\n```\n\nPlease provide the final code in ```rust ``` tags"
}