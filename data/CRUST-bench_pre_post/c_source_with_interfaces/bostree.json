{
    "name": "bostree",
    "bostree.c": "/*\n\tSelf-Balancing order statistic tree\n\n\tImplements an AVL tree with two additional methods,\n\tSelect(i), which finds the i'th smallest element, and\n\tRank(x), which returns the rank of a given element,\n\twhich both run in O(log n).\n\n\tThe tree is implemented with map semantics, that is, there are separete key\n\tand value pointers.\n\n\tCopyright (c) 2017, Phillip Berndt\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"bostree.h\"\n#include <assert.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* Tree structure */\nstruct _BOSTree {\n\tBOSNode *root_node;\n\n\tBOSTree_cmp_function cmp_function;\n\tBOSTree_free_function free_function;\n};\n\n/* Local helper functions */\nstatic int _imax(const int i1, const int i2) {\n\treturn i1 > i2 ? i1 : i2;\n}\n\nstatic int _bostree_balance(BOSNode *node) {\n\tconst int left_depth = node->left_child_node ? node->left_child_node->depth + 1 : 0;\n\tconst int right_depth = node->right_child_node ? node->right_child_node->depth + 1 : 0;\n\treturn right_depth - left_depth;\n}\n\nstatic BOSNode *_bostree_rotate_right(BOSTree *tree, BOSNode *P) {\n\t// Rotate right:\n\t//\n\t//      P                     L\n\t//  L        R     -->    c1      P\n\t//c1 c2                        c2     R\n\t//\n\tBOSNode *L = P->left_child_node;\n\n\tif(P->parent_node) {\n\t\tif(P->parent_node->left_child_node == P) {\n\t\t\tP->parent_node->left_child_node = L;\n\t\t}\n\t\telse {\n\t\t\tP->parent_node->right_child_node = L;\n\t\t}\n\t}\n\telse {\n\t\ttree->root_node = L;\n\t}\n\n\tL->parent_node = P->parent_node;\n\n\tP->left_child_node = L->right_child_node;\n\tP->left_child_count = L->right_child_count;\n\tif(P->left_child_node) {\n\t\tP->left_child_node->parent_node = P;\n\t}\n\tP->depth = _imax(P->left_child_node ? 1 + P->left_child_node->depth : 0, P->right_child_node ? 1 + P->right_child_node->depth : 0);\n\tP->parent_node = L;\n\n\tL->right_child_node = P;\n\tP->parent_node = L;\n\tL->right_child_count = P->left_child_count + P->right_child_count + 1;\n\tL->depth = _imax(L->left_child_node ? 1 + L->left_child_node->depth : 0, L->right_child_node ? 1 + L->right_child_node->depth : 0);\n\n\treturn L;\n}\n\nstatic BOSNode *_bostree_rotate_left(BOSTree *tree, BOSNode *P) {\n\t// Rotate left:\n\t//\n\t//      P                     R\n\t//  L        R     -->    P      c2\n\t//         c1 c2        L  c1\n\t//\n\tBOSNode *R = P->right_child_node;\n\n\tif(P->parent_node) {\n\t\tif(P->parent_node->left_child_node == P) {\n\t\t\tP->parent_node->left_child_node = R;\n\t\t}\n\t\telse {\n\t\t\tP->parent_node->right_child_node = R;\n\t\t}\n\t}\n\telse {\n\t\ttree->root_node = R;\n\t}\n\n\tR->parent_node = P->parent_node;\n\n\tP->right_child_node = R->left_child_node;\n\tP->right_child_count = R->left_child_count;\n\tif(P->right_child_node) {\n\t\tP->right_child_node->parent_node = P;\n\t}\n\tP->depth = _imax(P->left_child_node ? 1 + P->left_child_node->depth : 0, P->right_child_node ? 1 + P->right_child_node->depth : 0);\n\tP->parent_node = R;\n\n\tR->left_child_node = P;\n\tP->parent_node = R;\n\tR->left_child_count = P->left_child_count + P->right_child_count + 1;\n\tR->depth = _imax(R->left_child_node ? 1 + R->left_child_node->depth : 0, R->right_child_node ? 1 + R->right_child_node->depth : 0);\n\n\treturn R;\n}\n\n\n/* API implementation */\nBOSTree *bostree_new(BOSTree_cmp_function cmp_function, BOSTree_free_function free_function) {\n\tBOSTree *new_tree = malloc(sizeof(BOSTree));\n\tnew_tree->root_node = NULL;\n\tnew_tree->cmp_function = cmp_function;\n\tnew_tree->free_function = free_function;\n\treturn new_tree;\n}\n\nvoid bostree_destroy(BOSTree *tree) {\n\t// Walk the tree and unref all nodes\n\tBOSNode *node = tree->root_node;\n\twhile(node) {\n\t\t// The order should not really matter, but use post-order traversal here.\n\t\twhile(node->left_child_node) {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\n\t\tif(node->right_child_node) {\n\t\t\tnode = node->right_child_node;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At this point, we can be sure that this node has no child nodes.\n\t\t// So it is safe to remove it.\n\t\tBOSNode *next = node->parent_node;\n\t\tif(next) {\n\t\t\tif(next->left_child_node == node) {\n\t\t\t\tnext->left_child_node = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext->right_child_node = NULL;\n\t\t\t}\n\t\t}\n\t\tbostree_node_weak_unref(tree, node);\n\t\tnode = next;\n\t}\n\n\tfree(tree);\n}\n\nunsigned int bostree_node_count(BOSTree *tree) {\n\treturn tree->root_node ? tree->root_node->left_child_count + tree->root_node->right_child_count + 1 : 0;\n}\n\nBOSNode *bostree_insert(BOSTree *tree, void *key, void *data) {\n\tBOSNode **node = &tree->root_node;\n\tBOSNode *parent_node = NULL;\n\n\t// Find tree position to insert new node\n\twhile(*node) {\n\t\tparent_node = *node;\n\t\tint cmp = tree->cmp_function(key, (*node)->key);\n\t\tif(cmp < 0) {\n\t\t\t(*node)->left_child_count++;\n\t\t\tnode = &(*node)->left_child_node;\n\t\t}\n\t\telse {\n\t\t\t(*node)->right_child_count++;\n\t\t\tnode = &(*node)->right_child_node;\n\t\t}\n\t}\n\n\t// Create new node\n\tBOSNode *new_node = malloc(sizeof(BOSNode));\n\tmemset(new_node, 0, sizeof(BOSNode));\n\tnew_node->key = key;\n\tnew_node->data = data;\n\tnew_node->weak_ref_count = 1;\n\tnew_node->weak_ref_node_valid = 1;\n\tnew_node->parent_node = parent_node;\n\n\t*node = new_node;\n\n\tif(!parent_node) {\n\t\t// Simple case, this is the first node.\n\t\ttree->root_node = new_node;\n\t\treturn new_node;\n\t}\n\n\t// Check if the depth changed with the new node:\n\t// It does only change if this is the first child of the parent\n\tif(!!parent_node->left_child_node ^ !!parent_node->right_child_node) {\n\t\t// Bubble the information up the tree\n\t\tparent_node->depth++;\n\t\twhile(parent_node->parent_node) {\n\t\t\t// Assign new depth\n\t\t\tparent_node = parent_node->parent_node;\n\n\t\t\tunsigned int new_left_depth  = parent_node->left_child_node ? parent_node->left_child_node->depth + 1 : 0;\n\t\t\tunsigned int new_right_depth = parent_node->right_child_node ? parent_node->right_child_node->depth + 1 : 0;\n\n\t\t\tunsigned int max_depth = _imax(new_left_depth, new_right_depth);\n\n\t\t\tif(parent_node->depth != max_depth) {\n\t\t\t\tparent_node->depth = max_depth;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We can break here, because if the depth did not change\n\t\t\t\t// at this level, it won't have further up either.\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Check if this node violates the AVL property, that is, that the\n\t\t\t// depths differ by no more than 1.\n\t\t\tif(new_left_depth - 2 == new_right_depth) {\n\t\t\t\t// Handle left-right case\n\t\t\t\tif(_bostree_balance(parent_node->left_child_node) > 0) {\n\t\t\t\t\t_bostree_rotate_left(tree, parent_node->left_child_node);\n\t\t\t\t}\n\n\t\t\t\t// Left is two levels deeper than right. Rotate right.\n\t\t\t\tparent_node = _bostree_rotate_right(tree, parent_node);\n\t\t\t}\n\t\t\telse if(new_left_depth + 2 == new_right_depth) {\n\t\t\t\t// Handle right-left case\n\t\t\t\tif(_bostree_balance(parent_node->right_child_node) < 0) {\n\t\t\t\t\t_bostree_rotate_right(tree, parent_node->right_child_node);\n\t\t\t\t}\n\n\t\t\t\t// Right is two levels deeper than left. Rotate left.\n\t\t\t\tparent_node = _bostree_rotate_left(tree, parent_node);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new_node;\n}\n\nvoid bostree_remove(BOSTree *tree, BOSNode *node) {\n\tBOSNode *bubble_up = NULL;\n\n\t// If this node has children on both sides, bubble one of it upwards\n\t// and rotate within the subtrees.\n\tif(node->left_child_node && node->right_child_node) {\n\t\tBOSNode *candidate = NULL;\n\t\tBOSNode *lost_child = NULL;\n\t\tif(node->left_child_node->depth >= node->right_child_node->depth) {\n\t\t\t// Left branch is deeper than right branch, might be a good idea to\n\t\t\t// bubble from this side to maintain the AVL property with increased\n\t\t\t// likelihood.\n\t\t\tnode->left_child_count--;\n\t\t\tcandidate = node->left_child_node;\n\t\t\twhile(candidate->right_child_node) {\n\t\t\t\tcandidate->right_child_count--;\n\t\t\t\tcandidate = candidate->right_child_node;\n\t\t\t}\n\t\t\tlost_child = candidate->left_child_node;\n\t\t}\n\t\telse {\n\t\t\tnode->right_child_count--;\n\t\t\tcandidate = node->right_child_node;\n\t\t\twhile(candidate->left_child_node) {\n\t\t\t\tcandidate->left_child_count--;\n\t\t\t\tcandidate = candidate->left_child_node;\n\t\t\t}\n\t\t\tlost_child = candidate->right_child_node;\n\t\t}\n\n\t\tBOSNode *bubble_start = candidate->parent_node;\n\t\tif(bubble_start->left_child_node == candidate) {\n\t\t\tbubble_start->left_child_node = lost_child;\n\t\t}\n\t\telse {\n\t\t\tbubble_start->right_child_node = lost_child;\n\t\t}\n\t\tif(lost_child) {\n\t\t\tlost_child->parent_node = bubble_start;\n\t\t}\n\n\t\t// We will later rebalance upwards from bubble_start up to candidate.\n\t\t// But first, anchor candidate into the place where \"node\" used to be.\n\n\t\tif(node->parent_node) {\n\t\t\tif(node->parent_node->left_child_node == node) {\n\t\t\t\tnode->parent_node->left_child_node = candidate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode->parent_node->right_child_node = candidate;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttree->root_node = candidate;\n\t\t}\n\t\tcandidate->parent_node = node->parent_node;\n\n\t\tcandidate->left_child_node = node->left_child_node;\n\t\tcandidate->left_child_count = node->left_child_count;\n\t\tcandidate->right_child_node = node->right_child_node;\n\t\tcandidate->right_child_count = node->right_child_count;\n\n\t\tif(candidate->left_child_node) {\n\t\t\tcandidate->left_child_node->parent_node = candidate;\n\t\t}\n\n\t\tif(candidate->right_child_node) {\n\t\t\tcandidate->right_child_node->parent_node = candidate;\n\t\t}\n\n\t\t// From here on, node is out of the game.\n\t\t// Rebalance up to candidate.\n\n\t\tif(bubble_start != node) {\n\t\t\twhile(bubble_start != candidate) {\n\t\t\t\tbubble_start->depth = _imax((bubble_start->left_child_node ? bubble_start->left_child_node->depth + 1 : 0),\n\t\t\t\t\t(bubble_start->right_child_node ? bubble_start->right_child_node->depth + 1 : 0));\n\t\t\t\tint balance = _bostree_balance(bubble_start);\n\t\t\t\tif(balance > 1) {\n\t\t\t\t\t// Rotate left. Check for right-left case before.\n\t\t\t\t\tif(_bostree_balance(bubble_start->right_child_node) < 0) {\n\t\t\t\t\t\t_bostree_rotate_right(tree, bubble_start->right_child_node);\n\t\t\t\t\t}\n\t\t\t\t\tbubble_start = _bostree_rotate_left(tree, bubble_start);\n\t\t\t\t}\n\t\t\t\telse if(balance < -1) {\n\t\t\t\t\t// Rotate right. Check for left-right case before.\n\t\t\t\t\tif(_bostree_balance(bubble_start->left_child_node) > 0) {\n\t\t\t\t\t\t_bostree_rotate_left(tree, bubble_start->left_child_node);\n\t\t\t\t\t}\n\t\t\t\t\tbubble_start = _bostree_rotate_right(tree, bubble_start);\n\t\t\t\t}\n\t\t\t\tbubble_start = bubble_start->parent_node;\n\t\t\t}\n\t\t}\n\n\t\t// Fixup candidate's depth\n\t\tcandidate->depth = _imax((candidate->left_child_node ? candidate->left_child_node->depth + 1 : 0),\n\t\t\t(candidate->right_child_node ? candidate->right_child_node->depth + 1 : 0));\n\n\t\t// We'll have to fixup child counts and depths up to the root, do that\n\t\t// later.\n\t\tbubble_up = candidate->parent_node;\n\n\t\t// Fix immediate parent node child count here.\n\t\tif(bubble_up) {\n\t\t\tif(bubble_up->left_child_node == candidate) {\n\t\t\t\tbubble_up->left_child_count--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbubble_up->right_child_count--;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// If this node has children on one side only, removing it is much simpler.\n\t\tif(!node->parent_node) {\n\t\t\t// Simple case: Node _was_ the old root.\n\t\t\tif(node->left_child_node) {\n\t\t\t\ttree->root_node = node->left_child_node;\n\t\t\t\tif(node->left_child_node) {\n\t\t\t\t\tnode->left_child_node->parent_node = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttree->root_node = node->right_child_node;\n\t\t\t\tif(node->right_child_node) {\n\t\t\t\t\tnode->right_child_node->parent_node = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No rebalancing to do\n\t\t\tbubble_up = NULL;\n\t\t}\n\t\telse {\n\t\t\tBOSNode *candidate = node->left_child_node;\n\t\t\tint candidate_count = node->left_child_count;\n\t\t\tif(node->right_child_node) {\n\t\t\t\tcandidate = node->right_child_node;\n\t\t\t\tcandidate_count = node->right_child_count;\n\t\t\t}\n\n\t\t\tif(node->parent_node->left_child_node == node) {\n\t\t\t\tnode->parent_node->left_child_node = candidate;\n\t\t\t\tnode->parent_node->left_child_count = candidate_count;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode->parent_node->right_child_node = candidate;\n\t\t\t\tnode->parent_node->right_child_count = candidate_count;\n\t\t\t}\n\n\t\t\tif(candidate) {\n\t\t\t\tcandidate->parent_node = node->parent_node;\n\t\t\t}\n\n\t\t\t// Again, from here on, the original node is out of the game.\n\t\t\t// Rebalance up to the root.\n\t\t\tbubble_up = node->parent_node;\n\t\t}\n\t}\n\n\t// At this point, everything below and including bubble_start is\n\t// balanced, and we have to look further up.\n\n\tchar bubbling_finished = 0;\n\twhile(bubble_up) {\n\t\tif(!bubbling_finished) {\n\t\t\t// Calculate updated depth for bubble_up\n\t\t\tunsigned int left_depth = bubble_up->left_child_node ? bubble_up->left_child_node->depth + 1 : 0;\n\t\t\tunsigned int right_depth = bubble_up->right_child_node ? bubble_up->right_child_node->depth + 1 : 0;\n\t\t\tunsigned int new_depth = _imax(left_depth, right_depth);\n\t\t\tchar depth_changed = (new_depth != bubble_up->depth);\n\t\t\tbubble_up->depth = new_depth;\n\n\t\t\t// Rebalance bubble_up\n\t\t\t// Not necessary for the first node, but calling _bostree_balance once\n\t\t\t// isn't that much overhead.\n\t\t\tint balance = _bostree_balance(bubble_up);\n\t\t\tif(balance < -1) {\n\t\t\t\tif(_bostree_balance(bubble_up->left_child_node) > 0) {\n\t\t\t\t\t_bostree_rotate_left(tree, bubble_up->left_child_node);\n\t\t\t\t}\n\t\t\t\tbubble_up = _bostree_rotate_right(tree, bubble_up);\n\t\t\t}\n\t\t\telse if(balance > 1) {\n\t\t\t\tif(_bostree_balance(bubble_up->right_child_node) < 0) {\n\t\t\t\t\t_bostree_rotate_right(tree, bubble_up->right_child_node);\n\t\t\t\t}\n\t\t\t\tbubble_up = _bostree_rotate_left(tree, bubble_up);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(!depth_changed) {\n\t\t\t\t\t// If we neither had to rotate nor to change the depth,\n\t\t\t\t\t// then we are obviously finished.  Only update child\n\t\t\t\t\t// counts from here on.\n\t\t\t\t\tbubbling_finished = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(bubble_up->parent_node) {\n\t\t\tif(bubble_up->parent_node->left_child_node == bubble_up) {\n\t\t\t\tbubble_up->parent_node->left_child_count--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbubble_up->parent_node->right_child_count--;\n\t\t\t}\n\t\t}\n\t\tbubble_up = bubble_up->parent_node;\n\t}\n\n\tnode->weak_ref_node_valid = 0;\n\tbostree_node_weak_unref(tree, node);\n}\n\nBOSNode *bostree_node_weak_ref(BOSNode *node) {\n\tassert(node->weak_ref_count < 127);\n\tassert(node->weak_ref_count > 0);\n\tnode->weak_ref_count++;\n\treturn node;\n}\n\nBOSNode *bostree_node_weak_unref(BOSTree *tree, BOSNode *node) {\n\tnode->weak_ref_count--;\n\tif(node->weak_ref_count == 0) {\n\t\tif(tree->free_function) {\n\t\t\ttree->free_function(node);\n\t\t}\n\t\tfree(node);\n\t}\n\telse if(node->weak_ref_node_valid) {\n\t\treturn node;\n\t}\n\treturn NULL;\n}\n\nBOSNode *bostree_lookup(BOSTree *tree, const void *key) {\n\tBOSNode *node = tree->root_node;\n\twhile(node) {\n\t\tint cmp = tree->cmp_function(key, node->key);\n\t\tif(cmp == 0) {\n\t\t\tbreak;\n\t\t}\n\t\telse if(cmp < 0) {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\t\telse {\n\t\t\tnode = node->right_child_node;\n\t\t}\n\t}\n\treturn node;\n}\n\nBOSNode *bostree_select(BOSTree *tree, unsigned int index) {\n\tBOSNode *node = tree->root_node;\n\twhile(node) {\n\t\tif(node->left_child_count <= index) {\n\t\t\tindex -= node->left_child_count;\n\t\t\tif(index == 0) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\tindex--;\n\t\t\tnode = node->right_child_node;\n\t\t}\n\t\telse {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\t}\n\treturn node;\n}\n\nBOSNode *bostree_next_node(BOSNode *node) {\n\tif(node->right_child_node) {\n\t\tnode = node->right_child_node;\n\t\twhile(node->left_child_node) {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\t\treturn node;\n\t}\n\telse if(node->parent_node) {\n\t\twhile(node->parent_node && node->parent_node->right_child_node == node) {\n\t\t\tnode = node->parent_node;\n\t\t}\n\t\treturn node->parent_node;\n\t}\n\treturn NULL;\n}\n\nBOSNode *bostree_previous_node(BOSNode *node) {\n\tif(node->left_child_node) {\n\t\tnode = node->left_child_node;\n\t\twhile(node->right_child_node) {\n\t\t\tnode = node->right_child_node;\n\t\t}\n\t\treturn node;\n\t}\n\telse if(node->parent_node) {\n\t\twhile(node->parent_node && node->parent_node->left_child_node == node) {\n\t\t\tnode = node->parent_node;\n\t\t}\n\t\treturn node->parent_node;\n\t}\n\treturn NULL;\n}\n\nunsigned int bostree_rank(BOSNode *node) {\n\tunsigned int counter = node->left_child_count;\n\twhile(node) {\n\t\tif(node->parent_node && node->parent_node->right_child_node == node) counter += 1 + node->parent_node->left_child_count;\n\t\tnode = node->parent_node;\n\t}\n\treturn counter;\n}\n\n#if !defined(NDEBUG)\n#include <stdio.h>\n#include <unistd.h>\n\n/* Debug helpers:\n\n\tPrint the tree to stdout in dot format.\n*/\n\nstatic void _bostree_print_helper(BOSNode *node) {\n\tprintf(\"  %s [label=\\\"\\\\N (%d,%d,%d)\\\"];\\n\", (char *)node->key, node->left_child_count, node->right_child_count, node->depth);\n\tif(node->parent_node) {\n\t\tprintf(\"  %s -> %s [color=green];\\n\", (char *)node->key, (char *)node->parent_node->key);\n\t}\n\n\tif(node->left_child_node != NULL) {\n\t\tprintf(\"  %s -> %s\\n\", (char *)node->key, (char *)node->left_child_node->key);\n\t\t_bostree_print_helper(node->left_child_node);\n\t}\n\tif(node->right_child_node != NULL) {\n\t\tprintf(\"  %s -> %s\\n\", (char *)node->key, (char *)node->right_child_node->key);\n\t\t_bostree_print_helper(node->right_child_node);\n\t}\n}\n\nvoid bostree_print(BOSTree *tree) {\n\tif(tree->root_node == NULL) {\n\t\treturn;\n\t}\n\n\tprintf(\"digraph {\\n  ordering = out;\\n\");\n\t_bostree_print_helper(tree->root_node);\n\tprintf(\"}\\n\");\n\tfsync(0);\n}\n#endif\n",
    "bostree.h": "/*\n\tSelf-Balancing order statistic tree\n\n\tImplements an AVL tree with two additional methods,\n\tSelect(i), which finds the i'th smallest element, and\n\tRank(x), which returns the rank of a given element,\n\twhich both run in O(log n).\n\n\tThe tree is implemented with map semantics, that is, there are separete key\n\tand value pointers.\n\n\tCopyright (c) 2017, Phillip Berndt\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef BOSTREE_H\n#define BOSTREE_H\n\n/* Opaque tree structure */\ntypedef struct _BOSTree BOSTree;\n\n/* Node structure */\nstruct _BOSNode {\n\tunsigned int left_child_count;\n\tunsigned int right_child_count;\n\tunsigned int depth;\n\n\tstruct _BOSNode *left_child_node;\n\tstruct _BOSNode *right_child_node;\n\tstruct _BOSNode *parent_node;\n\n\tvoid *key;\n\tvoid *data;\n\n\tunsigned char weak_ref_count;\n\tunsigned char weak_ref_node_valid;\n};\ntypedef struct _BOSNode BOSNode;\n\n/*\n\tPublic interface\n*/\n\n/**\n * Key comparison function.\n *\n * Should return a positive value if the second argument is larger than the\n * first one, a negative value if the first is larger, and zero exactly if both\n * are equal.\n */\ntypedef int (*BOSTree_cmp_function)(const void *, const void *);\n\n/**\n * Free function for deleted nodes.\n *\n * This function should free the key and data members of a node. The node\n * structure itself is free()d internally by BOSZTree.\n */\ntypedef void (*BOSTree_free_function)(BOSNode *node);\n\n/**\n * Create a new tree.\n *\n * The cmp_function is mandatory, but for the free function, you may supply a\n * NULL pointer if you do not have any data that needs to be free()d in\n * ->key and ->data.\n */\nBOSTree *bostree_new(BOSTree_cmp_function cmp_function, BOSTree_free_function free_function);\n\n/**\n * Destroy a tree and all its members.\n */\nvoid bostree_destroy(BOSTree *tree);\n\n/**\n * Return the number of nodes in a tree\n */\nunsigned int bostree_node_count(BOSTree *tree);\n\n/**\n * Insert a new member into the tree and return the associated node.\n */\nBOSNode *bostree_insert(BOSTree *tree, void *key, void *data);\n\n/**\n * Remove a given node from a tree.\n */\nvoid bostree_remove(BOSTree *tree, BOSNode *node);\n\n/**\n * Weak reference management for nodes.\n *\n * Nodes have an internal reference counter. They are only free()d after the\n * last weak reference has been removed. Calling bostree_node_weak_unref() on a\n * node which has been removed from the tree results in the weak reference\n * count being decreased, the node being possibly free()d if this has been the\n * last weak reference, and a NULL pointer being returned.\n */\nBOSNode *bostree_node_weak_ref(BOSNode *node);\n\n/**\n * Weak reference management for nodes.\n * See bostree_node_weak_ref()\n */\nBOSNode *bostree_node_weak_unref(BOSTree *tree, BOSNode *node);\n\n/**\n * Return a node given a key. NULL is returned if a key is not present in the\n * tree.\n */\nBOSNode *bostree_lookup(BOSTree *tree, const void *key);\n\n/**\n * Return a node given an index in in-order traversal. Indexing starts at 0.\n */\nBOSNode *bostree_select(BOSTree *tree, unsigned int index);\n\n/**\n * Return the next node in in-order traversal, or NULL is node was the last\n * node in the tree.\n */\nBOSNode *bostree_next_node(BOSNode *node);\n\n/**\n * Return the previous node in in-order traversal, or NULL is node was the first\n * node in the tree.\n */\nBOSNode *bostree_previous_node(BOSNode *node);\n\n/**\n * Return the rank of a node within it's owning tree.\n *\n * bostree_select(bostree_rank(node)) == node is always true.\n */\nunsigned int bostree_rank(BOSNode *node);\n\n#if !defined(NDEBUG) && (_BSD_SOURCE || _XOPEN_SOURCE || _POSIX_C_SOURCE >= 200112L)\nvoid bostree_print(BOSTree *tree);\n#define bostree_debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define bostree_debug(...) void\n#endif\n\n#endif\n",
    "c_rust": "",
    "c_rust_pre_post_conditions": "Function: bostree_new\nPreconditions:\n- cmp_function is a valid, non-null function pointer implementing a total order on keys.\n- free_function is either a valid function pointer or null.\nPostconditions:\n- Returns a non-null pointer to a freshly allocated BOSTree.\n- The new tree\u2019s root_node is NULL.\n- The tree\u2019s cmp_function field equals cmp_function.\n- The tree\u2019s free_function field equals free_function.\n\nFunction: bostree_destroy\nPreconditions:\n- tree is a non-null pointer returned by bostree_new.\nPostconditions:\n- All nodes in the tree have been unreferenced and freed (calling free_function on each if provided).\n- The tree object itself is freed.\n- After this call the tree pointer must not be dereferenced.\n\nFunction: bostree_node_count\nPreconditions:\n- tree is a non-null pointer to a valid BOSTree.\nPostconditions:\n- Returns 0 if tree->root_node is NULL.\n- Otherwise returns root->left_child_count + root->right_child_count + 1.\n- Does not modify the tree.\n\nFunction: bostree_insert\nPreconditions:\n- tree is a non-null pointer to a valid BOSTree.\n- key is a valid pointer (must compare via cmp_function).\n- data is a valid pointer (may be null).\n- Insertion key does not violate tree invariants (cmp_function defines unique ordering).\nPostconditions:\n- Allocates a new BOSNode and inserts it into the tree, preserving the AVL balance.\n- Returns a non-null pointer to the new node.\n- new_node->key == key.\n- new_node->data == data.\n- new_node->left_child_node and new_node->right_child_node are NULL.\n- new_node->parent_node points to its parent (or NULL if it became root).\n- new_node->weak_ref_count == 1.\n- new_node->weak_ref_node_valid == true.\n- The tree\u2019s root_node is updated if this was the first insertion.\n- The total node count (as returned by bostree_node_count) increases by 1.\n\nFunction: bostree_remove\nPreconditions:\n- tree is a non-null pointer to a valid BOSTree.\n- node is a non-null pointer to a BOSNode currently in that tree.\nPostconditions:\n- The specified node is removed and the tree is rebalanced to maintain AVL property.\n- node->weak_ref_node_valid is set to false.\n- The node\u2019s weak_ref_count is decremented via bostree_node_weak_unref:\n  \u2022 If resulting weak_ref_count > 0 and weak_ref_node_valid was true prior to unref, returns the node.\n  \u2022 If resulting weak_ref_count == 0, calls tree->free_function(node) if provided and frees node memory, returning NULL.\n- The tree\u2019s structure remains a valid AVL order-statistic tree.\n- The total node count (as returned by bostree_node_count) decreases by 1.\n\nFunction: bostree_node_weak_ref\nPreconditions:\n- node is a non-null pointer to a BOSNode.\n- node->weak_ref_count < 127.\nPostconditions:\n- Increments node->weak_ref_count by 1.\n- Returns the same node pointer.\n\nFunction: bostree_node_weak_unref\nPreconditions:\n- tree is a non-null pointer to the BOSTree that may own node.\n- node is a non-null pointer to a BOSNode.\n- node->weak_ref_count > 0.\nPostconditions:\n- Decrements node->weak_ref_count by 1.\n- If new weak_ref_count > 0 and node->weak_ref_node_valid was true before unref, returns node.\n- Otherwise (weak_ref_count == 0):\n  \u2022 If tree->free_function is non-null, calls free_function(node).\n  \u2022 Frees node\u2019s memory.\n  \u2022 Returns NULL.\n\nFunction: bostree_lookup\nPreconditions:\n- tree is a non-null pointer to a valid BOSTree.\n- key is a valid pointer.\nPostconditions:\n- Searches the tree using cmp_function.\n- Returns a pointer to the node where cmp_function(key,node->key) == 0, or NULL if not found.\n- Does not modify the tree.\n\nFunction: bostree_select\nPreconditions:\n- tree is a non-null pointer to a valid BOSTree.\n- index is a non-negative unsigned int.\nPostconditions:\n- If index < node count, returns the node at in-order position index.\n- If index \u2265 node count, returns NULL.\n- Does not modify the tree.\n\nFunction: bostree_next_node\nPreconditions:\n- node is a non-null pointer to a BOSNode in some tree.\nPostconditions:\n- Returns the successor of node in in-order traversal, or NULL if node is the last.\n- Does not modify the tree.\n\nFunction: bostree_previous_node\nPreconditions:\n- node is a non-null pointer to a BOSNode in some tree.\nPostconditions:\n- Returns the predecessor of node in in-order traversal, or NULL if node is the first.\n- Does not modify the tree.\n\nFunction: bostree_rank\nPreconditions:\n- node is a non-null pointer to a BOSNode that is part of some tree.\nPostconditions:\n- Returns the 0-based in-order rank of node.\n- Guarantees: bostree_select(tree, returned_rank) == node.\n- Does not modify the tree.\n\nFunction: bostree_print (debug only)\nPreconditions:\n- tree is a non-null pointer to a valid BOSTree.\nPostconditions:\n- Prints a Graphviz \u201cdot\u201d representation of the tree to stdout.\n- Does not modify the tree.",
    "rri_prompt": ""
}