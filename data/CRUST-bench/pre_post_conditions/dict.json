{
    "name": "dict",
    "manual_invs_pre_post": "```rust\nuse dict::dict::Dict;\n\n/// Checks core invariants of the dictionary structure.\npub fn check_invariants(dict: &Dict) {\n    // 1. The number of buckets matches the recorded modulus.\n    assert_eq!(\n        dict.buckets.len(),\n        dict.mod_,\n        \"Invariant failed: buckets.len() = {}, but dict.mod_ = {}\",\n        dict.buckets.len(),\n        dict.mod_\n    );\n\n    // 2. The total count matches the sum of each bucket's element count.\n    let summed: usize = dict.buckets.iter().map(|b| b.elements.len()).sum();\n    assert_eq!(\n        dict.count,\n        summed,\n        \"Invariant failed: dict.count = {}, but sum of bucket sizes = {}\",\n        dict.count,\n        summed\n    );\n\n    // 3. The temporary key buffer length matches the declared key size.\n    assert_eq!(\n        dict.key_temp.len(),\n        dict.key.size,\n        \"Invariant failed: key_temp.len() = {}, but key.size = {}\",\n        dict.key_temp.len(),\n        dict.key.size\n    );\n\n    // 4. For each bucket and each element:\n    for (bucket_idx, bucket) in dict.buckets.iter().enumerate() {\n        for elem in &bucket.elements {\n            // 4a. The stored key byte\u2010vector has the correct length.\n            assert_eq!(\n                elem.key.len(),\n                dict.key.size,\n                \"Invariant failed: elem.key.len() = {}, expected {} (bucket {})\",\n                elem.key.len(),\n                dict.key.size,\n                bucket_idx\n            );\n\n            // 4b. The stored value byte\u2010vector has the correct length.\n            assert_eq!(\n                elem.val.len(),\n                dict.val.size,\n                \"Invariant failed: elem.val.len() = {}, expected {} (bucket {})\",\n                elem.val.len(),\n                dict.val.size,\n                bucket_idx\n            );\n\n            // 4c. The element's hash code modulo `mod_` points to its actual bucket index.\n            let idx = (elem.code as usize) % dict.mod_;\n            assert_eq!(\n                idx,\n                bucket_idx,\n                \"Invariant failed: elem.code % mod_ = {} but stored in bucket {}\",\n                idx,\n                bucket_idx\n            );\n        }\n    }\n}\n\n// Invariants enforced:\n// - The number of buckets equals `dict.mod_`.\n// - `dict.count` equals the sum of `elements.len()` across all buckets.\n// - `key_temp.len()` equals `dict.key.size`.\n// - Each element's `key.len()` equals `dict.key.size`.\n// - Each element's `val.len()` equals `dict.val.size`.\n// - For every element, `(elem.code % dict.mod_)` equals its bucket index.\n```",
    "rri_prompt": "Task: Extract invariants from C  code and emit a Rust function called `check_invariants`\nRole: You are a rigorous program analyst. You will study a C program and its Rust interface files. Your job is to derive pre and post conditions of the program. \nDo any reasoning internally; only output the requested sections and code.\n\nInputs\n\n1. C function under analysis.\n2. C test case that is currently failing.\n3. Rust interface relevant to the C function.\n\nYou must implement a single Rust function named `check_invariants`:\n1. Perform non-trivial pre and post condition checks derived from the C program\u2019s behavior.\n2. Use `assert!` / `assert_eq!` with clear failure messages that include key values.\n3. You should not add unit tests but rather infer general invariants that hold for all valid states of the program.\n4. A brief bullet list titled \u201cInvariants enforced\u201d summarizing each invariant in plain language (no derivations or chain-of-thought; just the final invariants).\n\nConstraints & style\n\n1. Use only items available in the Rust interface (no new public types or deps).\n2. Prefer safe Rust; do not use unsafe unless the interface explicitly requires it.\n3. No logging/printing. No randomness. No external crates.\n4. If the interface already includes a validator that returns Result, you may call it and assert on Ok/Err instead of re-implementing internals.\n\nImplementation checklist\n1. Read the Rust interface to understand how to construct states.\n2. From the C code, enumerate and infer candidate invariants. Keep only those that must hold for all reachable states.\n3. Valid cases: assert the invariant holds.\n\nNow you will be provided with the C source code and Rust interface definitions.\n\nC source (program under analysis):\n```c\n#include \"dict.h\"\n\n#define DEFAULT_MOD     8\n#define DEFAULT_STEP    2\n#define HASH_BASE       256LLU\n#define HASH_MOD        1000000007LLU\n#define ASSERT_MEM(x)   if(x==NULL){fprintf(stderr,\"[ERRO]: out of memory.\\n\");exit(1);}\n\ntypedef struct dict_elem dict_elem_t;\nstruct dict_elem\n{\n    uint64_t        code;\n    dict_elem_t*    prev;\n    dict_elem_t*    next;\n    char            key[];\n};\n\ntypedef struct dict_list\n{\n    size_t          size;\n    dict_elem_t*    head;\n    dict_elem_t*    tail;\n} dict_list_t;\n\nstruct dict\n{\n    dict_key_attr_t     key;\n    dict_val_attr_t     val;\n    dict_alloc_t        alloc;\n    size_t              mod;\n    dict_list_t*        list;\n    void*               key_temp;\n};\n\n\nstatic inline bool dict_reshape( dict_t* restrict dict, size_t step )\n{\n    size_t old_size = dict->mod;\n    size_t new_size = old_size * step * DEFAULT_STEP;\n\n    dict_list_t* old_list = dict->list;\n    dict_list_t* new_list = dict->alloc.malloc( sizeof (dict_list_t) * new_size );\n\n    if ( new_list == NULL ) return false;\n\n    dict->mod   = new_size;\n    dict->list  = new_list;\n\n    memset( dict->list, 0, sizeof (dict_list_t) * new_size );\n\n    dict_elem_t* curr;\n    dict_elem_t* next;\n    uint64_t index;\n    for ( size_t i = 0; i < old_size; i++ )\n    {\n        curr = old_list[i].head;\n        while ( curr != NULL )\n        {\n            next    = curr->next;\n            index   = curr->code % new_size;\n            \n            if ( new_list[ index ].head == NULL )\n            {\n                new_list[ index ].head = new_list[ index ].tail = curr;\n                curr->prev = NULL;\n            }\n            else\n            {\n                new_list[ index ].tail->next = curr;\n                new_list[ index ].tail = curr;\n                curr->prev = new_list[ index ].tail;\n            }\n            new_list[ index ].size++;\n            curr = next;\n        }\n    }\n\n    for ( size_t i = 0; i < new_size; i++ )\n    {\n        new_list[i].tail->next = NULL;\n    }\n\n    if ( dict->alloc.free != NULL )\n    {\n        dict->alloc.free( old_list );\n    }\n\n    return true;\n}\n\n\nstatic inline void* dict_get_key( const dict_t* restrict dict, va_list ap )\n{\n    void* key = dict->key_temp;\n    if ( dict->key.copy != NULL )\n    {\n        void* data = va_arg( ap, void* );\n        dict->key.copy( key, data );\n    }\n    else\n    {\n        switch ( dict->key.type )\n        {\n            case DICT_CHAR:         *(char*)        key = va_arg( ap, int );            break;\n            case DICT_WCHAR:        *(wchar_t*)     key = va_arg( ap, int );            break;\n            case DICT_I32:          *(int32_t*)     key = va_arg( ap, int32_t );        break;\n            case DICT_U32:          *(uint32_t*)    key = va_arg( ap, uint32_t );       break;\n            case DICT_F32:          *(float*)       key = va_arg( ap, double );         break;\n            case DICT_I64:          *(int64_t*)     key = va_arg( ap, int64_t );        break;\n            case DICT_U64:          *(uint64_t*)    key = va_arg( ap, uint64_t );       break;\n            case DICT_F64:          *(double*)      key = va_arg( ap, double );         break;\n            case DICT_PTR:          *(void**)       key = va_arg( ap, void* );          break;\n            case DICT_STR:\n            {\n                char* str = va_arg( ap, char* );\n                *(char**) key = dict->alloc.malloc( strlen(str) + 1 );\n                ASSERT_MEM( *(char**) key );\n                strcpy( *(char**) key, str );\n                break;\n            }\n            case DICT_STRUCT:\n            {\n                void* data = va_arg( ap, void* );\n                memcpy( key, data, dict->key.size );\n                break;\n            }\n            default:                fprintf( stderr, \"[ERRO]: illegal type.\\n\" );       exit(1);\n        }\n    }\n    return key;\n}\n\n\nstatic inline uint64_t dict_get_hash( const dict_t* restrict dict, void* restrict key )\n{\n    uint64_t code = 0;\n    if ( dict->key.hash != NULL )\n    {\n        code = dict->key.hash( key );\n    }\n    else\n    {\n        size_t length;\n        switch ( dict->key.type )\n        {\n            case DICT_CHAR:         code = *(char*)     key;    break;\n            case DICT_WCHAR:        code = *(wchar_t*)  key;    break;\n            case DICT_I32:          code = *(int32_t*)  key;    break;\n            case DICT_U32:          code = *(uint32_t*) key;    break;\n            case DICT_F32:          code = *(float*)    key;    break;\n            case DICT_I64:          code = *(int64_t*)  key;    break;\n            case DICT_U64:          code = *(uint64_t*) key;    break;\n            case DICT_F64:          code = *(double*)   key;    break;\n            case DICT_PTR:\n            {\n                code = *(uintptr_t*) key;\n                break;\n            }\n            case DICT_STR:          \n                length = strlen( *(char**) key );\n                for ( size_t i = 0; i < length; i++ )\n                {\n                    code = ( code * HASH_BASE + ( *(char**) key )[i] ) % HASH_MOD;\n                }\n                break;\n            case DICT_STRUCT:\n                length = dict->key.size;\n                for ( size_t i = 0; i < length; i++ )\n                {\n                    code = ( code * HASH_BASE + ( (char*) key )[i] ) % HASH_MOD;\n                }\n                break;\n            default:\n            {\n                fprintf( stderr, \"[ERRO]: illegal type.\\n\" );\n                exit(1);\n            }\n        }\n    }\n    return code;\n}\n\n\nstatic inline void dict_free_key( const dict_t* restrict dict, void* restrict key )\n{\n    if ( dict->key.copy != NULL && dict->key.free != NULL )\n    {\n        dict->key.free( key );\n    }\n    else if ( dict->key.type == DICT_STR )\n    {\n        dict->alloc.free( *(char**) key );\n    }\n}\n\n\nstatic inline void dict_free_val( const dict_t* restrict dict, void* restrict val )\n{\n    if ( dict->val.free != NULL )\n    {\n        dict->val.free( val );\n    }\n}\n\n\nstatic inline void dict_free_node( const dict_t* restrict dict, dict_elem_t* restrict node )\n{\n    if ( dict->alloc.free != NULL )\n    {\n        dict->alloc.free( node );\n    }\n}\n\n\nstatic inline void dict_delete_node( dict_list_t* restrict list, dict_elem_t* restrict curr )\n{\n    if ( curr == list->head )\n    {\n        list->head = curr->next;\n    }\n    if ( curr == list->tail )\n    {\n        list->tail = curr->prev;\n    }\n    if ( curr->prev != NULL )\n    {\n        curr->prev->next = curr->next;\n    }\n    if ( curr->next != NULL )\n    {\n        curr->next->prev = curr->prev;\n    }\n    list->size--;\n}\n\n\ndict_t* dict_create( dict_args_t args )\n{\n    size_t key_size;\n    switch ( args.key.type )\n    {\n        case DICT_CHAR:    key_size = sizeof ( char );                      break;\n        case DICT_WCHAR:   key_size = sizeof ( wchar_t );                   break;\n        case DICT_I32:     key_size = sizeof ( int32_t );                   break;\n        case DICT_U32:     key_size = sizeof ( uint32_t );                  break;\n        case DICT_F32:     key_size = sizeof ( float );                     break;\n        case DICT_I64:     key_size = sizeof ( int64_t );                   break;\n        case DICT_U64:     key_size = sizeof ( uint64_t );                  break;\n        case DICT_F64:     key_size = sizeof ( double );                    break;\n        case DICT_PTR:     key_size = sizeof ( void* );                     break;\n        case DICT_STR:     key_size = sizeof ( char* );                     break;\n        case DICT_STRUCT:  \n        {\n            key_size = ( args.key.size + ( sizeof (uintptr_t) - 1 ) ) & ~( sizeof (uintptr_t) - 1 );\n            break;\n        }\n        default:           fprintf( stderr, \"[ERRO]: illegal type.\\n\" );    exit(1);\n    }\n\n    size_t val_size = ( args.val.size + ( sizeof (uintptr_t) - 1 ) ) & ~( sizeof (uintptr_t) - 1 );\n\n    dict_t* dict = NULL;\n    if ( args.alloc.malloc != NULL )\n    {\n        dict = args.alloc.malloc( sizeof (dict_t) );\n        ASSERT_MEM( dict );\n        dict->alloc = args.alloc;\n    }\n    else\n    {\n        dict = malloc( sizeof (dict_t) );\n        ASSERT_MEM( dict );\n        dict->alloc = (dict_alloc_t)\n        {\n            .malloc = malloc,\n            .free   = free,\n        };\n    }\n\n    dict->key = args.key;\n    dict->key.size = key_size;\n\n    dict->val = args.val;\n    dict->val.size = val_size;\n\n    dict->key_temp = dict->alloc.malloc( dict->key.size );\n    ASSERT_MEM( dict->key_temp );\n\n    dict->mod   = DEFAULT_MOD;\n    dict->list  = dict->alloc.malloc( sizeof (dict_list_t) * dict->mod );\n    ASSERT_MEM( dict->list );\n    memset( dict->list, 0, sizeof (dict_list_t) * dict->mod );\n\n    return dict;\n}\n\n\ndict_t* dict_new( dict_type_t key_type, size_t key_size, size_t val_size )\n{\n    return dict_create( (dict_args_t)\n    {\n        .key = (dict_key_attr_t)\n        {\n            .type = key_type,\n            .size = key_size,\n        },\n        .val = (dict_val_attr_t)\n        {\n            .size = val_size,\n        },\n        .alloc = (dict_alloc_t) { 0 },\n    });\n}\n\n\nvoid dict_destroy( dict_t* restrict dict )\n{\n    for ( size_t i = 0; i < dict->mod; i++ )\n    {\n        dict_elem_t* curr = dict->list[i].head;\n        dict_elem_t* next;\n        while ( curr != NULL )\n        {\n            next = curr->next;\n            \n            dict_free_key( dict, curr->key );\n            if ( dict->val.size != 0 )\n            {\n                dict_free_val( dict, curr->key + dict->key.size );\n            }\n            dict_free_node( dict, curr );\n\n            curr = next;\n        }\n    }\n\n    if ( dict->alloc.free != NULL )\n    {\n        dict->alloc.free( dict->key_temp );\n        dict->alloc.free( dict->list );\n        dict->alloc.free( dict );\n        dict = NULL;\n    }\n}\n\n\nvoid* dict_get( dict_t* restrict dict, ... )\n{\n    va_list ap;\n    va_start( ap, dict );\n\n    // get the key\n    void* key = dict_get_key( dict, ap );\n\n    va_end(ap);\n\n    // get hash code\n    uint64_t code = dict_get_hash( dict, key );\n\n    // get into the linked list\n    size_t index = code % dict->mod;\n    for ( dict_elem_t* curr = dict->list[ index ].head; curr != NULL; curr = curr->next )\n    {\n        if ( curr->code != code ) continue;\n        if ( dict->key.cmpr != NULL )\n        {\n            if ( dict->key.cmpr( curr->key, key ) == 0 )\n            {\n                dict_free_key( dict, key );\n                return curr->key + dict->key.size;\n            }\n        }\n        else\n        {\n            switch ( dict->key.type )\n            {\n                case DICT_CHAR:\n                case DICT_WCHAR:\n                case DICT_I32:\n                case DICT_U32:\n                case DICT_F32:\n                case DICT_I64:\n                case DICT_U64:\n                case DICT_F64:\n                case DICT_PTR:\n                case DICT_STRUCT:\n                {\n                    if ( memcmp( curr->key, key, dict->key.size ) == 0 )\n                    {\n                        dict_free_key( dict, key );\n                        return curr->key + dict->key.size;\n                    }\n                    break;\n                }\n                case DICT_STR:\n                {\n                    if ( strcmp( *(char**) curr->key, *(char**) key ) == 0 )\n                    {\n                        dict_free_key( dict, key );\n                        return curr->key + dict->key.size;\n                    }\n                    break;\n                }\n                default:\n                {\n                    fprintf( stderr, \"[ERRO]: illegal type.\\n\" );\n                    exit(1);\n                }\n            }\n        }\n    }\n\n    // doesn't already appear in the list\n    dict_elem_t* elem = dict->alloc.malloc( sizeof (dict_elem_t) + dict->key.size + dict->val.size );\n    ASSERT_MEM( elem );\n    *elem = (dict_elem_t)\n    {\n        .code   = code,\n        .prev   = dict->list[ index ].tail,\n    };\n    memcpy( elem->key, key, dict->key.size );\n    memset( elem->key + dict->key.size, 0, dict->val.size );\n    if ( dict->list[ index ].size == 0 )\n    {\n        dict->list[ index ].head = dict->list[ index ].tail = elem;\n    }\n    else\n    {\n        dict->list[ index ].tail->next = elem;\n        dict->list[ index ].tail = elem;\n    }\n    if ( dict->list[ index ].size++ > dict->mod )\n    {\n        if ( dict_reshape( dict, 1 ) == false )\n        {\n            return NULL;\n        }\n    }\n    return elem->key + dict->key.size;\n}\n\n\nbool dict_remove( dict_t* restrict dict, ... )\n{\n    va_list ap;\n    va_start( ap, dict );\n\n    // get the key\n    void* key = dict_get_key( dict, ap );\n\n    va_end(ap);\n\n    // get hash code\n    uint64_t code = dict_get_hash( dict, key );\n\n    // get into the linked list\n    size_t index = code % dict->mod;\n    for ( dict_elem_t* curr = dict->list[ index ].head; curr != NULL; curr = curr->next )\n    {\n        if ( curr->code != code ) continue;\n        if ( dict->key.cmpr != NULL )\n        {\n            if ( dict->key.cmpr( curr->key, key ) == 0 )\n            {\n                // redirect node\n                dict_free_key( dict, key );\n                dict_delete_node( &dict->list[ index ], curr );\n                // delete key and val and node\n                dict_free_key( dict, curr->key );\n                dict_free_val( dict, curr->key + dict->key.size );\n                dict_free_node( dict, curr );\n                return true;\n            }\n        }\n        else\n        {\n            switch ( dict->key.type )\n            {\n                case DICT_CHAR:\n                case DICT_WCHAR:\n                case DICT_I32:\n                case DICT_U32:\n                case DICT_F32:\n                case DICT_I64:\n                case DICT_U64:\n                case DICT_F64:\n                case DICT_PTR:\n                case DICT_STRUCT:\n                {\n                    if ( memcmp( curr->key, key, dict->key.size ) == 0 )\n                    {\n                        // redirect node\n                        dict_free_key( dict, key );\n                        dict_delete_node( &dict->list[ index ], curr );\n                        // delete key and val and node\n                        dict_free_key( dict, curr->key );\n                        dict_free_val( dict, curr->key + dict->key.size );\n                        dict_free_node( dict, curr );\n                        return true;\n                    }\n                    break;\n                }\n                case DICT_STR:\n                {\n                    if ( strcmp( curr->key, key ) == 0 )\n                    {\n                        // redirect node\n                        dict_free_key( dict, key );\n                        dict_delete_node( &dict->list[ index ], curr );\n                        // delete key and val and node\n                        dict_free_key( dict, curr->key );\n                        dict_free_val( dict, curr->key + dict->key.size );\n                        dict_free_node( dict, curr );\n                        return true;\n                    }\n                    break;\n                }\n                default:\n                {\n                    fprintf( stderr, \"[ERRO]: illegal type.\\n\" );\n                    exit(1);\n                }\n            }\n        }\n    }\n\n    // doesn't already appear in the list\n    dict_free_key( dict, key );\n    return false;\n}\n\n\nbool dict_has( const dict_t* restrict dict, ... )\n{\n    va_list ap;\n    va_start( ap, dict );\n\n    void* key = dict_get_key( dict, ap );\n\n    va_end(ap);\n\n    uint64_t code = dict_get_hash( dict, key );\n\n    // get into the linked list\n    size_t index = code % dict->mod;\n    for ( dict_elem_t* curr = dict->list[ index ].head; curr != NULL; curr = curr->next )\n    {\n        if ( curr->code != code ) continue;\n        if ( dict->key.cmpr != NULL )\n        {\n            if ( dict->key.cmpr( curr->key, key ) == 0 )\n            {\n                return true;\n            }\n        }\n        else\n        {\n            switch ( dict->key.type )\n            {\n                case DICT_CHAR:\n                case DICT_WCHAR:\n                case DICT_I32:\n                case DICT_U32:\n                case DICT_F32:\n                case DICT_I64:\n                case DICT_U64:\n                case DICT_F64:\n                case DICT_PTR:\n                case DICT_STRUCT:\n                {\n                    if ( memcmp( curr->key, key, dict->key.size ) == 0 )\n                    {\n                        dict_free_key( dict, key );\n                        return true;\n                    }\n                    break;\n                }\n                case DICT_STR:\n                {\n                    if ( strcmp( curr->key, key ) == 0 )\n                    {\n                        dict_free_key( dict, key );\n                        return true;\n                    }\n                    break;\n                }\n                default:\n                {\n                    fprintf( stderr, \"[ERRO]: illegal type.\\n\" );\n                    exit(1);\n                }\n            }\n        }\n    }\n\n    // doesn't already appear in the list\n    dict_free_key( dict, key );\n    return false;\n}\n\n\nsize_t dict_len( const dict_t* restrict dict )\n{\n    size_t size = 0;\n    for ( size_t i = 0; i < dict->mod; i++ )\n    {\n        size += dict->list[i].size;\n    }\n    return size;\n}\n\n\nconst void* dict_key( const dict_t* restrict dict, size_t* restrict size )\n{\n    *size = dict_len( dict );\n\n    if ( *size == 0 )\n    {\n        return NULL;\n    }\n\n    char* arr = dict->alloc.malloc( dict->key.size * (*size) );\n\n    size_t index = 0;\n    for ( size_t i = 0; i < dict->mod; i++ )\n    {\n        for ( dict_elem_t* curr = dict->list[i].head; curr != NULL; curr = curr->next )\n        {\n            memcpy( arr + ( dict->key.size * index ), curr->key, dict->key.size );\n            if ( index++ == *size ) return arr;\n        }\n    }\n\n    return arr;\n}\n\n\nvoid* dict_serialize( const dict_t* restrict dict, size_t* restrict bytes )\n{\n    size_t space;\n    if ( bytes == NULL )\n    {\n        bytes = &space;\n    }\n\n    // calculate key size and val size\n    uint32_t size = dict_len( dict );\n    uint32_t key_val_size[3] = { dict->key.size, dict->val.size, size };\n    size_t   elem_size = dict->key.type == DICT_STR ? sizeof (uint32_t) + dict->val.size : dict->key.size + dict->val.size;\n\n    // calculate total size\n    if ( dict->key.type == DICT_STR )\n    {\n        *bytes = sizeof (uint32_t) * 3 + size * elem_size;\n    }\n    else\n    {\n        *bytes = sizeof (uint32_t) * 3 + size * elem_size;\n    }\n\n    // calculate key size if string type\n    #ifdef __STDC_NO_VLA__\n        uint32_t* strlen_table;\n        if (dict->key.type == DICT_STR )\n        {\n            strlen_table = dict->alloc.malloc( sizeof (uint32_t) * size );\n            ASSERT_MEM( strlen_table );\n        }\n    #else\n        uint32_t strlen_table[size];\n    #endif  // __STDC_NO_VLA__\n    if ( dict->key.type == DICT_STR )\n    {\n        size_t index = 0;\n        for ( size_t i = 0; i < dict->mod; i++ )\n        {\n            for ( dict_elem_t* curr = dict->list[i].head; curr != NULL; curr = curr->next )\n            {\n                strlen_table[index] = (uint32_t) strlen( *(char**) curr->key );\n                *bytes += strlen_table[index];\n                index++;\n            }\n        }\n    }\n\n\n    // allocate memory\n    void* data = dict->alloc.malloc( *bytes );\n    if ( data == NULL )\n    {\n        *bytes = 0;\n        return NULL;\n    }\n    char* ptr = data;\n\n    // store header\n    memcpy( ptr, key_val_size, sizeof (uint32_t) * 3 );\n    ptr += sizeof (uint32_t) * 3;\n\n    // store individual items\n    if ( dict->key.type == DICT_STR )\n    {\n        size_t index = 0;\n        char* str_ptr = ptr + size * elem_size;\n        for ( size_t i = 0; i < dict->mod; i++ )\n        {\n            for ( dict_elem_t* curr = dict->list[i].head; curr != NULL; curr = curr->next )\n            {\n                memcpy( ptr, &strlen_table[index], sizeof (uint32_t) );\n                ptr += sizeof (uint32_t);\n                memcpy( ptr, curr->key + dict->key.size, dict->val.size );\n                ptr += dict->val.size;\n                memcpy( str_ptr, *(char**) curr->key, strlen_table[index] );\n                str_ptr += strlen_table[index];\n                index++;\n            }\n        }\n    }\n    else\n    {\n        for ( size_t i = 0; i < dict->mod; i++ )\n        {\n            for ( dict_elem_t* curr = dict->list[i].head; curr != NULL; curr = curr->next )\n            {\n                memcpy( ptr, curr->key, elem_size );\n                ptr += elem_size;\n            }\n        }\n    }\n\n    // clean up memory allocation\n    #ifdef __STDC_NO_VLA__\n        if ( dict->key.type != DICT_STR && dict->alloc.free != NULL )\n        {\n            dict->alloc.free( strlen_table );\n        }\n    #endif  // __STDC_NO_VLA__\n\n    return data;\n}\n\n\ndict_t* dict_deserialize( dict_args_t args, const void* restrict data )\n{\n    const char* ptr = data;\n    uint32_t key_val_size[3];\n    memcpy( key_val_size, ptr, sizeof (uint32_t) * 3 );\n    ptr += sizeof (uint32_t) * 3;\n\n    size_t key_size;\n    switch ( args.key.type )\n    {\n        case DICT_CHAR:    key_size = sizeof ( char );                      break;\n        case DICT_WCHAR:   key_size = sizeof ( wchar_t );                   break;\n        case DICT_I32:     key_size = sizeof ( int32_t );                   break;\n        case DICT_U32:     key_size = sizeof ( uint32_t );                  break;\n        case DICT_F32:     key_size = sizeof ( float );                     break;\n        case DICT_I64:     key_size = sizeof ( int64_t );                   break;\n        case DICT_U64:     key_size = sizeof ( uint64_t );                  break;\n        case DICT_F64:     key_size = sizeof ( double );                    break;\n        case DICT_PTR:     key_size = sizeof ( void* );                     break;\n        case DICT_STR:     key_size = sizeof ( char* );                     break;\n        case DICT_STRUCT:\n        {\n            key_size = ( args.key.size + ( sizeof (uintptr_t) - 1 ) ) & ~( sizeof (uintptr_t) - 1 );\n            break;\n        }\n        default:           fprintf( stderr, \"[ERRO]: illegal type.\\n\" );    exit(1);\n    }\n\n    size_t val_size = ( args.val.size + ( sizeof (uintptr_t) - 1 ) ) & ~( sizeof (uintptr_t) - 1 );\n\n    if ( key_size != key_val_size[0] )\n    {\n        fprintf( stderr, \"[ERRO]: key type conflict, data corrupted.\\n\" );\n        return NULL;\n    }\n\n    if ( val_size != key_val_size[1] )\n    {\n        fprintf( stderr, \"[ERRO]: val type conflict, data corrupted.\\n\" );\n        return NULL;\n    }\n\n    dict_t* dict = NULL;\n    if ( args.alloc.malloc != NULL )\n    {\n        dict = args.alloc.malloc( sizeof (dict_t) );\n        ASSERT_MEM( dict );\n        dict->alloc = args.alloc;\n    }\n    else\n    {\n        dict = malloc( sizeof (dict_t) );\n        ASSERT_MEM( dict );\n        dict->alloc = (dict_alloc_t)\n        {\n            .malloc = malloc,\n            .free   = free,\n        };\n    }\n\n    dict->key = args.key;\n    dict->key.size = key_size;\n\n    dict->val = args.val;\n    dict->val.size = val_size;\n\n    dict->key_temp = dict->alloc.malloc( dict->key.size );\n    ASSERT_MEM( dict->key_temp );\n\n    dict->mod = DEFAULT_MOD;\n    dict->list  = dict->alloc.malloc( sizeof (dict_list_t) * dict->mod );\n    ASSERT_MEM( dict->list );\n    memset( dict->list, 0, sizeof (dict_list_t) * dict->mod );\n\n    // assign all the values\n    size_t elem_size = dict->key.type == DICT_STR ? sizeof (uint32_t) + dict->val.size : dict->key.size + dict->val.size;\n    size_t index;\n    uint64_t code;\n    dict_elem_t* elem;\n    if ( dict->key.type == DICT_STR )\n    {\n        const char* str_ptr = ptr + key_val_size[2] * elem_size;\n        for ( size_t i = 0; i < key_val_size[2]; i++ )\n        {\n            elem = dict->alloc.malloc( sizeof (dict_elem_t) + dict->key.size + dict->val.size );\n            ASSERT_MEM( elem );\n            // copy string\n            *(char**) elem->key = dict->alloc.malloc( *(uint32_t*) ptr + 1 );\n            ASSERT_MEM( elem->key );\n            memcpy( *(char**) elem->key, str_ptr, *(uint32_t*) ptr );\n            ( *(char**) elem->key )[ *(uint32_t*) ptr ] = 0;\n            str_ptr += *(uint32_t*) ptr;\n            ptr += sizeof (uint32_t);\n            memcpy( elem->key + dict->key.size, ptr, dict->val.size );\n            ptr += dict->val.size;\n            code = dict_get_hash( dict, elem->key );\n            elem->code = code;\n            index = code % dict->mod;\n            elem->prev = dict->list[index].tail;\n            elem->next = NULL;\n            if ( dict->list[index].size++ == 0 )\n            {\n                dict->list[index].head = dict->list[index].tail = elem;\n            }\n            else \n            {\n                dict->list[index].tail->next = elem;\n                dict->list[index].tail = elem;\n            }\n        }\n    }\n    else \n    {\n        for ( size_t i = 0; i < key_val_size[2]; i++ )\n        {\n            elem = dict->alloc.malloc( sizeof (dict_elem_t) + dict->key.size + dict->val.size );\n            ASSERT_MEM( elem );\n            memcpy( elem->key, ptr, elem_size );\n            ptr += elem_size;\n            code = dict_get_hash( dict, elem->key );\n            elem->code = code;\n            index = code % dict->mod;\n            elem->prev = dict->list[index].tail;\n            elem->next = NULL;\n            if ( dict->list[index].size++ == 0 )\n            {\n                dict->list[index].head = dict->list[index].tail = elem;\n            }\n            else\n            {\n                dict->list[index].tail->next = elem;\n                dict->list[index].tail = elem;\n            }\n        }\n    }\n\n    size_t max = 0;\n    for ( size_t i = 0; i < dict->mod; i++ )\n    {\n        if ( dict->list[i].size > max )\n        {\n            max = dict->list[i].size;\n        }\n    }\n\n    if ( max <= DEFAULT_MOD ) return dict;\n    max /= DEFAULT_MOD;\n    if ( dict_reshape( dict, max ) == false )\n    {\n        return NULL;\n    }\n    return dict;\n}\n\n\n```\n\nC Tests (the test cases that are failing):\n\n```c\n#include \"../src/dict.h\"\n#include <string.h>\n\ntypedef struct str\n{\n    size_t size;\n    char* str;\n} str_t;\n\n\n// dict_deep_copy\nvoid str_copy( void* dest, const void* src )\n{\n    str_t* d = dest;\n    const str_t* s = src;\n    d->size = s->size;\n    d->str = malloc( s->size + 1 );\n    strcpy( d->str, s->str );\n}\n\n// dict_free\nvoid str_free( void* ptr )\n{\n    free( ( (str_t*) ptr )->str );\n    ( (str_t*) ptr )->str = NULL;\n}\n\n// dict_hash\nuint64_t str_hash( const void* ptr )\n{\n    const str_t* str = ptr;\n    uint64_t code = 0;\n    for ( size_t i = 0; i < str->size; i++ )\n    {\n        code = ( code * 256 + ( str->str[i] ) % 1007 );\n    }\n    return code;\n}\n\n// dict_cmpr\nint str_cmpr( const void* s1, const void* s2 )\n{\n    const str_t* str1 = s1;\n    const str_t* str2 = s2;\n    return strcmp( str1->str, str2->str );\n}\n\n#define dict_uint64( dict, str )    ( *(uint64_t*) dict_get( dict, str ) )\n\nint main( void )\n{\n    // attribute list for key. \n    dict_key_attr_t key_attr = \n    {\n        .type = DICT_STRUCT,\n        .size = sizeof (str_t),\n        .copy = str_copy,\n        .free = str_free,\n        .hash = str_hash,\n        .cmpr = str_cmpr,\n    };\n    dict_t* dict = dict_create_args( .key = key_attr, .val = { .size = sizeof (uint64_t) } );\n\n    char* s1 = \"s1\";\n    char* s2 = \"s2\";\n    char* s3 = \"s3\";\n    char* s4 = \"s4\";\n    char* s5 = \"s5\";\n\n    dict_uint64( dict, ( &(str_t){ strlen(s1), s1 } ) ) = 1;\n    dict_uint64( dict, ( &(str_t){ strlen(s2), s2 } ) ) = 2;\n    dict_uint64( dict, ( &(str_t){ strlen(s3), s3 } ) ) = 3;\n    dict_uint64( dict, ( &(str_t){ strlen(s4), s4 } ) ) = 4;\n    dict_uint64( dict, ( &(str_t){ strlen(s5), s5 } ) ) = 5;\n\n    printf( \"val: %lu\\n\", dict_uint64( dict, ( &(str_t){ strlen(\"s4\"), \"s4\" } ) ) );\n    printf( \"remove: %d\\n\", dict_remove( dict, ( &(str_t){ strlen(\"s3\"), \"s3\" } ) ) );\n\n    size_t size;\n    const str_t* arr = dict_key( dict, &size );\n    printf( \"key amount: %zu\\n\", size );\n    for ( size_t i = 0; i < size; i++ )\n    {\n        printf( \"key[%zu]: %s\\n\", i, arr[i].str );\n    }\n    free( (void*)arr );\n\n    dict_destroy( dict );\n\n    return 0;\n}\n\n```\n\nRust test that fails (the test case that currently fails):\n```rust\nuse dict::dict::{\ndict_create_args, dict_destroy, dict_get, dict_remove, DictType, DictArgs, DictKeyAttr,\nDictValAttr, DictAlloc, Dict, DictDeepCopy, DictDestructor, DictHash, DictCmpr, dict_key\n};\nuse std::mem::size_of;\n\n/// This mimics the C struct:\n/// typedef struct str {\n///     size_t size;\n///     char* str;\n/// } str_t;\n#[repr(C)]\n#[derive(Debug, Clone)]\nstruct StrT {\nsize: usize,\n// For simplicity, store data as a standard Rust String, though in the real C code\n// it was a raw char* plus custom allocation.\n// The dictionary is only storing bytes, so we are just illustrating usage.\n// You would handle deeper ownership in a real scenario.\ndata: String,\n}\n\n/// In the C code, we have custom str_copy, str_free, etc. For Rust stubs, we'd rely on closures/fns\n/// in the dictionary, but we're just demonstrating calls.\n#[test]\nfn test2() {\n// Construct the DictKeyAttr that includes copy, free, hash, cmpr as in C\n// Here, we simply store them as None to illustrate usage, because the actual logic is unimplemented.\nlet key_attr = DictKeyAttr {\ntype_: DictType::Struct,\nsize: size_of::<StrT>(),\ncopy: None,\nfree: None, // would be Some(fn) if we implement str_free\nhash: None, // would be Some(fn) if we implement str_hash\ncmpr: None, // would be Some(fn) if we implement str_cmpr\n};\nlet val_attr = DictValAttr {\nsize: size_of::<u64>(),\nfree: None,\n};\nlet alloc = DictAlloc { malloc: None, free: None };\nlet args = DictArgs {\nkey: key_attr,\nval: val_attr,\nalloc,\n};\n\n// dict_create_args( .key = key_attr, .val = { .size = sizeof(uint64_t) } )\nlet mut dict = dict_create_args(args);\n\n// #define dict_uint64(dict, str) (*(uint64_t*) dict_get(dict, str))\n// In C, we do: dict_uint64(dict, &str_t{size, s}) = some_value.\n\n// We'll define a small utility to do that in Rust:\nunsafe fn dict_uint64<'a>(dict: &'a mut Dict, key: &'a StrT) -> &'a mut u64 {\nprintln!(\"{}\", key.data);\nlet data = dict_get(dict, key.data.as_bytes()).expect(\"dict_get returned None for u64 key\");\nlet (prefix, middle, suffix) = data.align_to_mut::<u64>();\nassert!(prefix.is_empty() && suffix.is_empty());\n&mut middle[0]\n}\n\n// Insert some values\nlet s1 = StrT { size: 2, data: \"s1\".to_string() };\nlet s2 = StrT { size: 2, data: \"s2\".to_string() };\nlet s3 = StrT { size: 2, data: \"s3\".to_string() };\nlet s4 = StrT { size: 2, data: \"s4\".to_string() };\nlet s5 = StrT { size: 2, data: \"s5\".to_string() };\nunsafe{\n*dict_uint64(&mut dict, &s1) = 1;\n*dict_uint64(&mut dict, &s2) = 2;\n*dict_uint64(&mut dict, &s3) = 3;\n*dict_uint64(&mut dict, &s4) = 4;\n*dict_uint64(&mut dict, &s5) = 5;\n}\n\n// printf(\"val: %lu\\n\", dict_uint64(dict, s4));\nunsafe{\nprintln!(\"val: {}\", *dict_uint64(&mut dict, &s4));\n}\n\n// dict_remove(dict, &s3)\nlet removed = dict_remove(&mut dict, s3.data.as_bytes());\nprintln!(\"remove: {}\", removed);\n\n// Retrieve keys with dict_key (unimplemented stub)\nlet mut size_of_keys = 0;\nif let Some(_keys_bytes) = dict_key(&dict, &mut size_of_keys) {\nprintln!(\"key amount: {}\", size_of_keys);\nprintln!(\"We would iterate and print each key, but the function is a stub in this demonstration.\");\n}\n\ndict_destroy(&mut dict);\n}\nfn main() {}\n```\n\n\nRust interface files (types, functions, signatures you MUST use to build test fixtures):\n```rust\nuse core::cmp::Ordering;\nuse std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash as StdHash, Hasher};\nuse std::sync::Mutex;\n/// A collection of constants matching the original C #defines.\npub const HASH_MOD: u64 = 1000000007;\npub const HASH_BASE: u64 = 256;\npub const DEFAULT_STEP: usize = 2;\npub const DEFAULT_MOD: usize = 8;\n/// Enum corresponding to the C enum `dict_type_t`.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum DictType {\nChar,\nWChar,\nI32,\nU32,\nF32,\nI64,\nU64,\nF64,\nPtr,\nStr,\nStruct,\n}\n/// A safe function pointer type for deep-copying values.\npub type DictDeepCopy = fn(dest: &mut [u8], src: &[u8]);\n/// A safe function pointer type for destructors.\npub type DictDestructor = fn(data: &mut [u8]);\n/// A safe function pointer type for comparisons.\npub type DictCmpr = fn(a: &[u8], b: &[u8]) -> i32;\n/// A safe function pointer type for hashing.\npub type DictHash = fn(data: &[u8]) -> u64;\n/// A safe function pointer type for memory allocation (unused in safe Rust).\npub type DictMalloc = fn(size: usize) -> Vec<u8>;\n/// A safe function pointer type for freeing allocated memory (unused in safe Rust).\npub type DictFree = fn(_: Vec<u8>);\n/// Corresponds to `dict_alloc_t` in C.\n#[derive(Clone)]\npub struct DictAlloc {\npub malloc: Option<DictMalloc>,\npub free: Option<DictFree>,\n}\n/// Corresponds to `dict_key_attr_t` in C.\n#[derive(Clone)]\npub struct DictKeyAttr {\npub type_: DictType,\npub size: usize,\npub copy: Option<DictDeepCopy>,\npub free: Option<DictDestructor>,\npub hash: Option<DictHash>,\npub cmpr: Option<DictCmpr>,\n}\n/// Corresponds to `dict_val_attr_t` in C.\n#[derive(Clone)]\npub struct DictValAttr {\npub size: usize,\npub free: Option<DictDestructor>,\n}\n/// Corresponds to `dict_args_t` in C.\n#[derive(Clone)]\npub struct DictArgs {\npub key: DictKeyAttr,\npub val: DictValAttr,\npub alloc: DictAlloc,\n}\n/// Each element in the dictionary. Mirrors the struct dict_elem in C.\n/// We store the key bytes in `key` and the value bytes in `val`.\n#[derive(Clone)]\npub struct DictElem {\npub code: u64,    // The hash code\npub key: Vec<u8>, // Owned bytes for the key\npub val: Vec<u8>, // Owned bytes for the value\n}\n/// A bucket (list) in the dictionary. Mirrors dict_list_t in C, but\n/// instead of a linked list, we store a Vec for safe iteration/removal.\n#[derive(Clone)]\npub struct DictBucket {\npub elements: Vec<DictElem>,\n}\n/// Corresponds to `struct dict` in C.\npub struct Dict {\npub key: DictKeyAttr,\npub val: DictValAttr,\npub alloc: DictAlloc,\npub mod_: usize,              // Number of buckets\npub buckets: Vec<DictBucket>, // The buckets array\npub key_temp: Vec<u8>,        // Temporary buffer for constructing a key\npub keys_dump: Vec<u8>,       // Unused here; effectively replaced by a safe approach\npub count: usize,             // Number of elements total\n}\n/// Create a dictionary using detailed arguments. Matches C's dict_create().\npub fn dict_create(args: DictArgs) -> Dict {\n    unimplemented!()\n}\n/// Create a dictionary with derived arguments. Matches C's dict_new().\npub fn dict_new(key_type: DictType, key_size: usize, val_size: usize) -> Dict {\n    unimplemented!()\n}\n/// Destroy a dictionary. Matches C's dict_destroy().\n/// In Rust, memory is freed automatically, but we emulate calling destructors if provided.\npub fn dict_destroy(dict: &mut Dict) {\n    unimplemented!()\n}\n/// Retrieve or create a value from the dictionary. In C, this used varargs. Here, we\n/// accept a slice of bytes as the key. Returns a mutable slice of the value,\n/// or None if something went wrong. Matches C's dict_get(dict_t*, ...).\n///\n/// IMPORTANT NOTE on borrow-checking:\n/// We must avoid returning a reference while also reshaping or re-borrowing the dictionary.\n/// To fix borrow issues, we do this in distinct steps:\n/// 1) Prepare the final key bytes. 2) Compute hash/code/index. 3) Search for existing element.\n/// 4) If not found, insert a new element. 5) Possibly reshape. 6) Perform a final search\n/// to retrieve a &mut reference. This ensures no overlapping mutable borrows exist during\n/// the function body.\npub fn dict_get<'dict>(dict: &'dict mut Dict, key_data: &[u8]) -> Option<&'dict mut [u8]> {\n    unimplemented!()\n}\n/// Remove a value from the dictionary. Matches C's dict_remove(dict_t*, ...).\n/// Returns true if the element was found and removed.\npub fn dict_remove(dict: &mut Dict, key_data: &[u8]) -> bool {\n    unimplemented!()\n}\n/// Check if a key exists in the dictionary. Matches C's dict_has(const dict_t*, ...).\npub fn dict_has(dict: &Dict, key_data: &[u8]) -> bool {\n    unimplemented!()\n}\n/// Return the number of elements in the dictionary. Matches C's dict_len().\npub fn dict_len(dict: &Dict) -> usize {\n    unimplemented!()\n}\n/// Return a snapshot of all keys. In C, it returns a newly allocated array of all keys\n/// (size = key.size * dict_len). This is not thread-safe in the original C usage. In\n/// safe Rust, we simulate returning a static buffer by leaking the allocation. This\n/// avoids unsafe code, but does leak memory for each call. Matches C's dict_key().\npub fn dict_key(dict: &Dict, size: &mut usize) -> Option<&'static [u8]> {\n    unimplemented!()\n}\n/// Serialize a dictionary into a contiguous Vec<u8>. Matches C's dict_serialize().\npub fn dict_serialize(dict: &Dict, bytes: &mut usize) -> Option<Vec<u8>> {\n    unimplemented!()\n}\n/// Deserialize a dictionary from a slice. Matches C's dict_deserialize().\npub fn dict_deserialize(args: DictArgs, data: &[u8]) -> Dict {\n    unimplemented!()\n}\n/// Convenience function to create a dictionary using inline arguments, mirroring the\n/// C macro dict_create_args(...).\npub fn dict_create_args(args: DictArgs) -> Dict {\n    unimplemented!()\n}\n/// The original dict_key_equals. Kept for signature consistency but not used internally\n/// to avoid borrow conflicts.\npub fn dict_key_equals(dict: &Dict, a: &[u8], b: &[u8]) -> bool {\n    unimplemented!()\n}\n/// Not used in this design, but signature is kept.\npub fn dict_delete_node(_list: &mut DictBucket, _curr: &mut DictElem) {\n// no-op in this safe design\n}\n/// The original dict_free_val. Kept for signature consistency.\npub fn dict_free_val(dict: &Dict, val: &mut [u8]) {\n    unimplemented!()\n}\n/// Not used in pure Rust version, matching signature only.\npub fn dict_get_key(_dict: &Dict) -> Option<&mut [u8]> {\n    unimplemented!()\n}\n/// Internal function to reshape the dictionary. Matches C's dict_reshape().\n/// We re-allocate and re-hash all elements with new capacity = old * step * DEFAULT_STEP.\npub fn dict_reshape(dict: &mut Dict, step: usize) -> bool {\n    unimplemented!()\n}\n/// Internal function to free a node. Matches C's dict_free_node().\npub fn dict_free_node(_dict: &Dict, _node: &mut DictElem) {\n    unimplemented!()\n}\n/// Internal function to free a dictionary key. Kept for signature consistency.\npub fn dict_free_key(dict: &Dict, key: &mut [u8]) {\n    unimplemented!()\n}\n/// The original dict_get_hash. Kept for signature consistency but not used internally\n/// to avoid borrow conflicts.\npub fn dict_get_hash(dict: &Dict, key: &[u8]) -> u64 {\n    unimplemented!()\n}\n```\n\nPlease provide the final code in ```rust ``` tags"
}