{
    "name": "bigint",
    "bigint.h": "/*\n * Adam's Big Integer Library\n * Version 1.0\n */\n#ifndef bigint_H\n#define bigint_H\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\ntypedef struct {\n    bool is_negative;\n    int64_t *digits;\n    size_t size;\n} bigint;\n\nvoid bigint_delete(bigint n);\n\nbigint bigint_zero() {\n    bigint result;\n    result.is_negative = false;\n    result.size = 1;\n    result.digits = malloc(sizeof(int64_t));\n    result.digits[0] = 0;\n    return result;\n}\n\nvoid bigint_print(bigint n);\n\nbool bigint_is_64_bit(bigint n) {\n    if (n.is_negative) {\n        if (n.size > 10) {\n            return false;\n        }\n        if (n.size < 10) {\n            return true;\n        }\n    } else {\n        if (n.size > 10) {\n            return false;\n        }\n        if (n.size < 10) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid bigint_remove_leading_zeros(bigint *n) {\n    size_t leading_zeros = 0;\n    for (size_t i = 0; i < n->size; i++) {\n        if (n->digits[i] == 0) {\n            leading_zeros++;\n        } else {\n            break;\n        }\n    }\n\n    // If there are leading zeros, memmove the digits\n    if (leading_zeros > 0) {\n        if (leading_zeros >= n->size) {\n            n->size = 1;\n            n->digits[0] = 0;\n            return;\n        }\n        n->size -= leading_zeros;\n        memmove(n->digits, n->digits + leading_zeros, n->size * sizeof(int64_t));\n    }\n}\n\nbigint bigint_from_int(int64_t n) {\n    bigint result;\n    if (n < 0) {\n        result.is_negative = true;\n        n = -n;\n    } else {\n        result.is_negative = false;\n    }\n    result.size = 1;\n    int64_t m = n;\n    while (m > 0) {\n        m /= 10;\n        result.size++;\n    }\n    result.digits = malloc(result.size * sizeof(int64_t));\n    m = n;\n    for (size_t i = 0; i < result.size; i++) {\n        result.digits[result.size - i - 1] = m % 10;\n        m /= 10;\n    }\n    bigint_remove_leading_zeros(&result);\n    return result;\n}\n\nint64_t bigint_to_int(bigint n) {\n    int64_t result = 0;\n    for (size_t i = 0; i < n.size; i++) {\n        result *= 10;\n        result += n.digits[i];\n    }\n    if (n.is_negative) {\n        result = -result;\n    }\n    return result;\n}\n\n/* Create a new bigint from an integer \n* @param n The integer to create a bigint from\n* @return A new bigint with the value of n\n*/\nbigint bigint_from_string(const char *n) {\n    bigint result;\n    \n    // Determine if the number is negative\n    if (n[0] == '-') {\n        result.is_negative = true;\n        n++;\n    } else {\n        result.is_negative = false;\n    }\n\n    // Determine the size of the number\n    result.size = strlen(n);\n\n    // Allocate memory for the digits\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n    // Copy the digits into the bigint\n    for (size_t i = 0; i < result.size; i++) {\n        result.digits[i] = n[i] - '0';\n    }\n    \n    return result;\n}\n\n\nbigint bigint_copy(bigint n) {\n    bigint result;\n    result.is_negative = n.is_negative;\n    result.size = n.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    memcpy(result.digits, n.digits, result.size * sizeof(int64_t));\n    return result;\n}\n\n/* Print a bigint\n* @param n The bigint to print\n*/\nvoid bigint_print(bigint n) {\n    if (n.is_negative) {\n        printf(\"-\");\n    }\n    for (size_t i = 0; i < n.size; i++) {\n        assert(n.digits[i] >= 0 && n.digits[i] <= 9);\n        printf(\"%lld\", n.digits[i]);\n    }\n}\n\n\nbool bigint_gt(bigint a, bigint b) {\n    bigint_remove_leading_zeros(&a);\n    bigint_remove_leading_zeros(&b);\n    if (a.size > b.size) {\n        return !a.is_negative;\n    }\n    if (a.size < b.size) {\n        return a.is_negative;\n    }\n    for (size_t i = 0; i < a.size; i++) {\n        if (a.digits[i] > b.digits[i]) {\n            return !a.is_negative;\n        }\n        if (a.digits[i] < b.digits[i]) {\n            return a.is_negative;\n        }\n    }\n    return false;\n}\n\nbool bigint_eq(bigint a, bigint b) {\n    bigint_remove_leading_zeros(&a);\n    bigint_remove_leading_zeros(&b);\n    if (a.size != b.size) {\n        return false;\n    }\n    if (a.is_negative != b.is_negative) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size; i++) {\n        if (a.digits[i] != b.digits[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool bigint_eqzero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return true;\n    }\n    return false;\n}\n\nbool bigint_ltzero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return false;\n    }\n    return n.is_negative;\n}\nbool bigint_gtzero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return false;\n    }\n    return !n.is_negative;\n}\n\nbool bigint_lezero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return true;\n    }\n    return n.is_negative;\n}\n\nbool bigint_gezero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return true;\n    }\n    return !n.is_negative;\n}\n\nbigint bigint_abs(bigint n) {\n    n.is_negative = false;\n    return n;\n}\n\nbool bigint_ge(bigint a, bigint b) {\n    return bigint_gt(a, b) || bigint_eq(a, b);\n}\n\nbool bigint_lt(bigint a, bigint b) {\n    return !bigint_ge(a, b);\n}\n\nbool bigint_le(bigint a, bigint b) {\n    return !bigint_gt(a, b);\n}\n\n\nbigint bigint_add(bigint a, bigint b);\n\n/* Subtract two bigints\n* @param a The first bigint\n* @param b The second bigint\n* @return The difference of a and b\n*/\nbigint bigint_sub(bigint a, bigint b) {\n    bigint result;\n    if (a.is_negative && b.is_negative) {\n        a.is_negative = false;\n        b.is_negative = false;\n        result = bigint_add(b, a);\n        result.is_negative = true;\n        return result;\n    }\n    \n    if (a.is_negative) {\n        // -a - b = -(a + b)\n        b.is_negative = true;\n        result = bigint_add(a, b);\n        return result;\n    }\n\n    if (b.is_negative) {\n        // a - (-b) = a + b\n        b.is_negative = false;\n        result = bigint_add(a, b);\n        return result;\n    }\n\n    result.size = a.size > b.size ? a.size : b.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n    bool is_negative = bigint_lt(a, b);\n\n\n    // Subtract the digits\n    int64_t carry = 0;\n    bigint larger = bigint_gt(a, b) ? a : b;\n    bigint smaller = bigint_gt(a, b) ? b : a;\n\n    for (size_t i = 0; i < result.size; i++) {\n        int64_t diff = carry;\n        if (i < larger.size) {\n            diff += larger.digits[larger.size - i - 1];\n        }\n        if (i < smaller.size) {\n            diff -= smaller.digits[smaller.size - i - 1];\n        }\n        if (diff < 0) {\n            diff += 10;\n            carry = -1;\n        } else {\n            carry = 0;\n        }\n        result.digits[result.size - i - 1] = diff;\n    }\n    \n    bigint_remove_leading_zeros(&result);\n\n    result.is_negative = is_negative;\n\n    return result;\n}\n\n/* Add two bigints\n* @param a The first bigint\n* @param b The second bigint\n* @return The sum of a and b\n*/\nbigint bigint_add(bigint a, bigint b) {\n    bigint result;\n    if (a.is_negative && b.is_negative) {\n        result.is_negative = true;\n    } else if (a.is_negative) {\n        a.is_negative = false;\n        result = bigint_sub(b, a);\n        return result;\n    } else if (b.is_negative) {\n        b.is_negative = false;\n        result = bigint_sub(a, b);\n        return result;\n    } else {\n        result.is_negative = false;\n    }\n    result.size = a.size > b.size ? a.size : b.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n\n    \n    // Add the digits\n    int64_t carry = 0;\n    for (size_t i = 0; i < result.size; i++) {\n        int64_t sum = carry;\n        if (i < a.size) {\n            sum += a.digits[a.size - i - 1];\n        }\n        if (i < b.size) {\n            sum += b.digits[b.size - i - 1];\n        }\n        result.digits[result.size - i - 1] = sum % 10;\n        carry = sum / 10;\n    }\n    \n    // If there is a carry, add another digit\n    if (carry > 0) {\n        result.size++;\n        result.digits = realloc(result.digits, result.size * sizeof(int64_t));\n        for (size_t i = result.size - 1; i > 0; i--) {\n            result.digits[i] = result.digits[i - 1];\n        }\n        result.digits[0] = carry;\n    }\n    bigint_remove_leading_zeros(&result);\n    \n    return result;\n}\n\n\nbigint bigint_inc(bigint *n) {\n    bigint one = bigint_from_string(\"1\"), tmp;\n    tmp = *n;\n    *n = bigint_add(*n, one);\n    bigint_delete(tmp);\n    bigint_delete(one);\n    return *n;\n}\n\nbigint bigint_dec(bigint *n) {\n    bigint one = bigint_from_string(\"1\"), tmp;\n    tmp = *n;\n    *n = bigint_sub(*n, one);\n    bigint_delete(tmp);\n    bigint_delete(one);\n    return *n;\n}\n\nbigint bigint_mul(bigint a, bigint b) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b)) {\n        return bigint_from_int(bigint_to_int(a) * bigint_to_int(b));\n    }\n\n\n    bigint result;\n    result.size = a.size + b.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n    // Multiply the digits\n    for (size_t i = 0; i < result.size; i++) {\n        result.digits[i] = 0;\n    }\n    for (size_t i = 0; i < a.size; i++) {\n        for (size_t j = 0; j < b.size; j++) {\n            result.digits[result.size - i - j - 1] += a.digits[a.size - i - 1] * b.digits[b.size - j - 1];\n        }\n    }\n\n    // Normalize the result\n    int64_t carry = 0;\n    for (size_t i = 0; i < result.size; i++) {\n        int64_t sum = result.digits[result.size - i - 1] + carry;\n        result.digits[result.size - i - 1] = sum % 10;\n        carry = sum / 10;\n    }\n\n    // If there is a carry, add another digit\n    if (carry > 0) {\n        result.size++;\n        result.digits = realloc(result.digits, result.size * sizeof(int64_t));\n        for (size_t i = result.size - 1; i > 0; i--) {\n            result.digits[i] = result.digits[i - 1];\n        }\n        result.digits[0] = carry;\n    }\n    \n    bigint_remove_leading_zeros(&result);\n    \n    // Check negative\n    result.is_negative = a.is_negative != b.is_negative;\n    \n    return result;\n}\n\n\nbigint bigint_divmod(bigint numerator, bigint denominator, bigint *remainder) {\n    if (bigint_is_64_bit(numerator) && bigint_is_64_bit(denominator)) {\n        int64_t quotient = bigint_to_int(numerator) / bigint_to_int(denominator);\n        int64_t rem = bigint_to_int(numerator) % bigint_to_int(denominator);\n        *remainder = bigint_from_int(rem);\n        return bigint_from_int(quotient);\n    }\n\n    bigint quotient = bigint_from_string(\"0\");\n    \n    bool negative = numerator.is_negative != denominator.is_negative;\n    numerator.is_negative = false;\n    denominator.is_negative = false;\n    \n    bigint tmp1, tmp2;\n    numerator = bigint_copy(numerator);\n\n    // Divide the numerator by the denominator\n    // This is a very slow algorithm\n    // It works by subtracting the denominator from the numerator until the numerator is less than the denominator\n    // The number of times the denominator is subtracted is the quotient\n    // The remainder is the numerator after the last subtraction\n    while (bigint_gtzero(numerator)) {\n        tmp1 = numerator;\n        numerator = bigint_sub(numerator, denominator);\n        bigint_delete(tmp1);\n        if (bigint_ltzero(numerator)) {\n            break;\n        }\n        bigint_inc(&quotient);\n    }\n    if (bigint_ltzero(numerator)) {\n        tmp1 = numerator;\n        numerator = bigint_add(numerator, denominator);\n        bigint_delete(tmp1);\n    }\n\n    // Set the remainder\n    *remainder = numerator;\n\n    bigint_remove_leading_zeros(&quotient);\n\n    if (negative) {\n        quotient.is_negative = true;\n        remainder->is_negative = true;\n    }\n\n    return quotient;\n}\n\nbigint bigint_div(bigint a, bigint b) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b)) {\n        return bigint_from_int(bigint_to_int(a) / bigint_to_int(b));\n    }\n\n    bigint remainder;\n    bigint result = bigint_divmod(a, b, &remainder);\n    bigint_delete(remainder);\n    return result;\n}\n\nbigint bigint_mod(bigint a, bigint b) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b)) {\n        bigint result = bigint_from_int(bigint_to_int(a) % bigint_to_int(b));\n        // printf(\"Computing %lld %% %lld = %lld\\n\", bigint_to_int(a), bigint_to_int(b), bigint_to_int(result));\n        return result;\n    }\n\n    bigint remainder;\n    bigint_delete(bigint_divmod(a, b, &remainder));\n    return remainder;\n}\n\nbigint bigint_pow(bigint a, bigint b) {\n    bigint result, tmp;\n    if (b.is_negative) {\n        result = bigint_from_string(\"0\");\n        return result;\n    }\n    result = bigint_from_string(\"1\");\n    if (bigint_eqzero(b)) {\n        return result;\n    }\n    b = bigint_copy(b);\n    while (!bigint_eqzero(b)) {\n        tmp = result;\n        result = bigint_mul(result, a);\n        bigint_delete(tmp);\n        bigint_dec(&b);\n    }\n    bigint_delete(b);\n    return result;\n}\n\nbool bigint_is_odd(bigint n);\nbool bigint_is_even(bigint n);\n\nbigint bigint_fast_pow(bigint a, bigint b, bigint m) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b) && bigint_is_64_bit(m)) {\n        int64_t result = 1;\n        int64_t base = bigint_to_int(a);\n        int64_t exp = bigint_to_int(b);\n        int64_t mod = bigint_to_int(m);\n        base %= mod;\n        while (exp > 0) {\n            if (exp % 2 == 1) {\n                result = (result * base) % mod;\n            }\n            exp = exp >> 1;\n            base = (base * base) % mod;\n        }\n        return bigint_from_int(result);\n    }\n    \n    bigint result;\n\n    if (b.is_negative) {\n        result = bigint_from_string(\"0\");\n        return result;\n    }\n    if (bigint_eqzero(b)) {\n        result = bigint_from_string(\"1\");\n        return result;\n    }\n\n    bigint tmp1, tmp2;\n    // printf(\"Computing %lld ^ %lld mod %lld\\n\", bigint_to_int(a), bigint_to_int(b), bigint_to_int(m));\n    b = bigint_copy(b);\n    a = bigint_mod(a, m);\n    result = bigint_copy(a);\n    bigint b_save = bigint_copy(b);\n    bigint_dec(&b);\n\n    bigint pow = bigint_from_string(\"1\");\n    while (true) {\n        tmp1 = bigint_from_string(\"2\");\n        tmp2 = bigint_div(b, tmp1);\n        bigint_delete(tmp1);\n        if (!bigint_gtzero(tmp2)) {\n            bigint_delete(tmp2);\n            break;\n        }\n        bigint_delete(tmp2);\n\n        tmp1 = bigint_mul(result, result);\n        tmp2 = result;\n        result = bigint_mod(tmp1, m);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        // Halve b\n        tmp1 = b;\n        tmp2 = bigint_from_string(\"2\");\n        \n        b = bigint_div(b, tmp2);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        \n        tmp1 = pow;\n        pow = bigint_add(pow, pow);\n        bigint_delete(tmp1);\n    }\n    \n    tmp1 = b_save;\n    b_save = bigint_sub(b_save, pow);\n    bigint_delete(tmp1);\n\n    if (bigint_is_odd(b_save)) {\n        tmp1 = result;\n        tmp2 = bigint_mul(result, a);\n        result = bigint_mod(tmp2, m);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        bigint_dec(&b_save);\n        bigint_inc(&pow);\n    }\n\n    if (bigint_lt(b_save, bigint_from_int(5))) {\n        while (!bigint_eqzero(b_save)) {\n            tmp1 = result;\n            tmp2 = bigint_mul(result, a);\n            result = bigint_mod(tmp2, m);\n            bigint_delete(tmp1);\n            bigint_delete(tmp2);\n            bigint_dec(&b_save);\n            bigint_inc(&pow);\n        }\n\n        bigint_delete(b_save);\n        bigint_delete(pow);\n\n        return result;\n    }\n\n    // Do the same halving powers for the subpart\n    bigint subpart = bigint_fast_pow(a, b_save, m);\n\n    tmp1 = result;\n    tmp2 = subpart;\n    result = bigint_mul(result, subpart);\n    bigint_delete(tmp1);\n    bigint_delete(tmp2);\n\n    tmp1 = result;\n    result = bigint_mod(result, m);\n    bigint_delete(tmp1);\n\n    bigint_delete(b_save);\n    bigint_delete(pow);\n    \n    return result;\n}\n\nbigint bigint_modinv(bigint a, bigint m) {\n    bigint m0 = bigint_copy(m);\n    bigint y = bigint_from_string(\"0\");\n    bigint x = bigint_from_string(\"1\");\n    bigint q = bigint_from_string(\"0\");\n    bigint t = bigint_from_string(\"0\");\n    bigint temp = bigint_from_string(\"0\");\n    bigint one = bigint_from_string(\"1\");\n    a = bigint_copy(a);\n    m = bigint_copy(m);\n\n    bigint tmp1, tmp2;\n    while (!bigint_eqzero(a)) {\n        tmp1 = q;\n        q = bigint_div(m, a);\n        bigint_delete(tmp1);\n\n        tmp1 = t;\n        tmp2 = bigint_mul(q, a);\n        t = bigint_sub(m, tmp2);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        tmp1 = m, tmp2 = a;\n        m = bigint_copy(a);\n        a = bigint_copy(t);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        tmp1 = t;\n        tmp2 = bigint_mul(q, x);\n        t = bigint_sub(y, tmp2);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        tmp1 = y, tmp2 = x;\n        y = bigint_copy(x);\n        x = bigint_copy(t);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n    }\n    if (bigint_ltzero(m)) {\n        tmp1 = m;\n        m = bigint_add(m, m0);\n        bigint_delete(tmp1);\n    }\n\n    if (bigint_eq(m, one)) {\n        bigint result = bigint_mod(y, m0);\n        if (bigint_ltzero(result)) {\n            tmp1 = result;\n            result = bigint_add(result, m0);\n            bigint_delete(tmp1);\n        }\n        bigint_delete(a);\n        bigint_delete(m);\n        bigint_delete(m0);\n        bigint_delete(y);\n        bigint_delete(x);\n        bigint_delete(q);\n        bigint_delete(t);\n        bigint_delete(temp);\n        bigint_delete(one);\n        return result;\n    }\n    bigint_delete(a);\n    bigint_delete(m);\n    bigint_delete(m0);\n    bigint_delete(y);\n    bigint_delete(x);\n    bigint_delete(q);\n    bigint_delete(t);\n    bigint_delete(temp);\n    bigint_delete(one);\n    return bigint_from_int(0);\n}\n\nbigint bigint_sqrt(bigint n) {\n    bigint one = bigint_from_string(\"1\");\n    bigint two = bigint_from_string(\"2\");\n    bigint low = bigint_from_string(\"0\");\n    bigint high = bigint_copy(n);\n    bigint mid = bigint_from_string(\"0\");\n    while (bigint_lt(low, high)) {\n        bigint tmp1 = bigint_add(low, high);\n        bigint tmp2 = mid;\n        mid = bigint_div(tmp1, two);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        tmp1 = bigint_mul(mid, mid);\n        if (bigint_lt(tmp1, n)) {\n            tmp2 = low;\n            low = bigint_add(mid, one);\n            bigint_delete(tmp2);\n        } else {\n            tmp2 = high;\n            high = bigint_copy(mid);\n            bigint_delete(tmp2);\n        }\n        bigint_delete(tmp1);\n    }\n\n    bigint_delete(one);\n    bigint_delete(two);\n    bigint_delete(mid);\n    bigint_delete(high);\n\n    return low;\n}\n\nbool bigint_is_even(bigint n) {\n    return n.digits[n.size - 1] % 2 == 0;\n}\n\nbool bigint_is_odd(bigint n) {\n    return n.digits[n.size - 1] % 2 == 1;\n}\n\nbool bigint_is_prime(bigint n) {\n    bigint tmp1, tmp2;\n    // Check if the number is even\n    if (bigint_is_even(n)) {\n        return false;\n    }\n\n    // If the last digit is a 5 or 0, the number is divisible by 5\n    if (n.size > 1 && (n.digits[n.size - 1] == 5 || n.digits[n.size - 1] == 0)) {\n        return false;\n    }\n    // Check if the sum of the digits is divisible by 3\n    bigint sum = bigint_from_string(\"0\");\n    for (size_t i = 0; i < n.size; i++) {\n        tmp1 = bigint_from_int(n.digits[i]);\n        tmp2 = sum;\n        sum = bigint_add(sum, tmp1);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n    }\n\n    tmp1 = bigint_from_string(\"3\");\n    tmp2 = bigint_mod(sum, tmp1);\n    if (bigint_eqzero(tmp2)) {\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        bigint_delete(sum);\n        return false;\n    }\n    bigint_delete(tmp1);\n    bigint_delete(tmp2);\n    bigint_delete(sum);\n\n    bigint sqrt_n = bigint_sqrt(n);\n    \n    for (tmp1 = bigint_from_string(\"2\"); bigint_le(tmp1, sqrt_n); bigint_inc(&tmp1)) {\n        tmp2 = bigint_mod(n, tmp1);\n        if (bigint_eqzero(tmp2)) {\n            bigint_delete(tmp1);\n            bigint_delete(tmp2);\n            bigint_delete(sqrt_n);\n            return false;\n        }\n        bigint_delete(tmp2);\n    }\n    bigint_delete(tmp1);\n    bigint_delete(sqrt_n);\n    return true;\n}\n\n/* Delete a bigint\n* @param n The bigint to delete\n*/\n#include <execinfo.h>\nvoid bigint_delete(bigint n) {\n    free(n.digits);\n    n.digits = NULL;\n    n.is_negative = false;\n    n.size = 0;\n}\n\n#endif",
    "c_rust": "",
    "c_rust_pre_post_conditions": "// Preconditions and postconditions for BigInt interface\n\nFunction: BigInt::zero()\nPreconditions:\n- none\nPostconditions:\n- returns BigInt b with b.negative == false\n- b.digits == vec![0]\n\nFunction: BigInt::is_64_bit(&self) -> bool\nPreconditions:\n- self.digits each in 0..=9\nPostconditions:\n- returns true if self.digits.len() < 10\n- returns false otherwise\n\nFunction: BigInt::remove_leading_zeros(&mut self)\nPreconditions:\n- self.digits.len() \u2265 1\n- all entries in self.digits are in 0..=9\nPostconditions:\n- any leading zeros in self.digits are dropped\n- if all digits were zero, self.digits == vec![0]\n- self.digits.len() \u2265 1\n\nFunction: BigInt::from_int(n: i64) -> BigInt\nPreconditions:\n- none\nPostconditions:\n- returns BigInt b representing decimal expansion of n\n- b.negative == (n < 0)\n- b.digits contains the digits of |n| with no leading zeros (except one zero if n == 0)\n\nFunction: BigInt::to_int(&self) -> i64\nPreconditions:\n- self represents a value that fits in i64 (magnitude < 2\u2076\u00b3)\nPostconditions:\n- returns signed integer value reconstructed from self.digits and self.negative\n\nFunction: BigInt::from_str(s: &str) -> BigInt\nPreconditions:\n- s matches the regex \"-?[0-9]+\"\nPostconditions:\n- returns BigInt b with b.negative == (s starts with '-')\n- b.digits == vec![ each character ('0'..'9') as u8 ] without further normalization\n\nFunction: BigInt::copy(&self) -> BigInt\nPreconditions:\n- none\nPostconditions:\n- returns a distinct BigInt b with b.negative == self.negative\n- b.digits.clone() == self.digits\n\nFunction: BigInt::print(&self)\nPreconditions:\n- self.digits each in 0..=9\nPostconditions:\n- writes to stdout exactly the decimal form of self, with a leading '-' if self.negative\n\nFunction: BigInt::is_zero(&self) -> bool\nPreconditions:\n- none\nPostconditions:\n- returns true iff after removing leading zeros self.digits == vec![0]\n\nFunction: BigInt::lt_zero(&self) -> bool\nPreconditions:\n- none\nPostconditions:\n- returns true iff self.negative == true and !self.is_zero()\n\nFunction: BigInt::gt_zero(&self) -> bool\nPreconditions:\n- none\nPostconditions:\n- returns true iff self.negative == false and !self.is_zero()\n\nFunction: BigInt::lezero(&self) -> bool\nPreconditions:\n- none\nPostconditions:\n- returns true iff self.negative == true or self.is_zero()\n\nFunction: BigInt::gezero(&self) -> bool\nPreconditions:\n- none\nPostconditions:\n- returns true iff self.negative == false or self.is_zero()\n\nFunction: BigInt::abs(&self) -> BigInt\nPreconditions:\n- none\nPostconditions:\n- returns BigInt b with b.digits == self.digits and b.negative == false\n\nFunction: BigInt::add(&self, other: &BigInt) -> BigInt\nPreconditions:\n- self.digits and other.digits valid decimal digits\nPostconditions:\n- returns BigInt representing arithmetic sum self + other\n- result.digits have no leading zeros\n- result.negative correctly set\n\nFunction: BigInt::sub(&self, other: &BigInt) -> BigInt\nPreconditions:\n- self.digits and other.digits valid decimal digits\nPostconditions:\n- returns BigInt representing arithmetic difference self \u2212 other\n- result.digits have no leading zeros\n- result.negative correctly set\n\nFunction: BigInt::inc(&mut self)\nPreconditions:\n- self.digits valid\nPostconditions:\n- replaces self by self + 1\n- self.digits have no leading zeros\n- self.negative updated\n\nFunction: BigInt::dec(&mut self)\nPreconditions:\n- self.digits valid\nPostconditions:\n- replaces self by self \u2212 1\n- self.digits have no leading zeros\n- self.negative updated\n\nFunction: BigInt::mul(&self, other: &BigInt) -> BigInt\nPreconditions:\n- self.digits and other.digits valid\nPostconditions:\n- returns BigInt representing self \u00d7 other\n- result.digits have no leading zeros\n- result.negative == self.negative XOR other.negative\n\nFunction: BigInt::divmod(&self, other: &BigInt) -> (BigInt, BigInt)\nPreconditions:\n- other != zero\nPostconditions:\n- returns (q, r) with q = \u230aself / other\u230b, r = self \u2212 q*other\n- 0 \u2264 r < |other|\n- q.negative and r.negative follow C semantics\n\nFunction: BigInt::div(&self, other: &BigInt) -> BigInt\nPreconditions:\n- other != zero\nPostconditions:\n- returns quotient \u230aself / other\u230b identical to first element of divmod\n\nFunction: BigInt::r#mod(&self, other: &BigInt) -> BigInt\nPreconditions:\n- other != zero\nPostconditions:\n- returns remainder self % other identical to second element of divmod\n\nFunction: BigInt::pow(&self, exponent: &BigInt) -> BigInt\nPreconditions:\n- none\nPostconditions:\n- if exponent.negative == true returns zero()\n- if exponent == zero() returns one (i.e. digit vec [1], negative false)\n- otherwise returns self^exponent (repeated multiplication)\n\nFunction: BigInt::fast_pow(&self, exponent: &BigInt, modulo: &BigInt) -> BigInt\nPreconditions:\n- modulo != zero()\n- none on exponent\nPostconditions:\n- if exponent.negative returns zero()\n- if exponent == zero() returns one mod modulo\n- returns (self^exponent) % modulo using fast exponentiation\n\nFunction: BigInt::modinv(&self, modulo: &BigInt) -> BigInt\nPreconditions:\n- modulo != zero()\n- gcd(self, modulo) == 1\nPostconditions:\n- returns x such that (self * x) % modulo == 1\n\nFunction: BigInt::sqrt(&self) -> BigInt\nPreconditions:\n- self.negative == false\nPostconditions:\n- returns the least non\u2010negative t such that t*t \u2265 self\n\nFunction: BigInt::is_even(&self) -> bool\nPreconditions:\n- self.digits non\u2010empty\nPostconditions:\n- returns true iff last digit % 2 == 0\n\nFunction: BigInt::is_odd(&self) -> bool\nPreconditions:\n- self.digits non\u2010empty\nPostconditions:\n- returns true iff last digit % 2 == 1\n\nFunction: BigInt::is_prime(&self) -> bool\nPreconditions:\n- self.digits represent a non\u2010negative integer\nPostconditions:\n- returns false if self is even, ends in 0 or 5, or sum of digits divisible by 3\n- otherwise tests all odd divisors up to \u221aself\n- returns true iff no divisor found\n\nFunction: gt(a: &BigInt, b: &BigInt) -> bool\nPreconditions:\n- a.digits and b.digits valid\nPostconditions:\n- returns true iff numeric value of a > b\n\nFunction: lt(a: &BigInt, b: &BigInt) -> bool\nPreconditions:\n- a.digits and b.digits valid\nPostconditions:\n- returns true iff a < b\n\nFunction: ge(a: &BigInt, b: &BigInt) -> bool\nPreconditions:\n- a.digits and b.digits valid\nPostconditions:\n- returns true iff a >= b\n\nFunction: le(a: &BigInt, b: &BigInt) -> bool\nPreconditions:\n- a.digits and b.digits valid\nPostconditions:\n- returns true iff a <= b\n\nFunction: delete(a: &mut BigInt)\nPreconditions:\n- a not in use after deletion\nPostconditions:\n- frees internal storage (in C: frees digits and zero\u2010izes the struct)\n\nTrait impl: std::ops::Neg for BigInt\nFunction: neg(self) -> BigInt\nPreconditions:\n- self.digits valid\nPostconditions:\n- returns BigInt with same digits and flipped negative flag\n\nTrait impl: PartialEq for BigInt\nFunction: eq(&self, other: &BigInt) -> bool\nPreconditions:\n- self.digits and other.digits valid\nPostconditions:\n- returns true iff self.negative == other.negative and self.digits == other.digits after leading\u2010zero removal\n\nTrait impl: PartialOrd for BigInt\nFunction: partial_cmp(&self, other: &BigInt) -> Option<Ordering>\nPreconditions:\n- self.digits and other.digits valid\nPostconditions:\n- returns Some(Ordering::Less|Equal|Greater) corresponding to numeric comparison\n\nTrait impl: fmt::Display for BigInt\nFunction: fmt(&self, f: &mut fmt::Formatter) -> fmt::Result\nPreconditions:\n- self.digits valid\nPostconditions:\n- writes the same output as BigInt::print and returns fmt::Result::Ok(())",
    "rri_prompt": ""
}