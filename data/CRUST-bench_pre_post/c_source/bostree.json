{
    "name": "bostree",
    "bostree.c": "/*\n\tSelf-Balancing order statistic tree\n\n\tImplements an AVL tree with two additional methods,\n\tSelect(i), which finds the i'th smallest element, and\n\tRank(x), which returns the rank of a given element,\n\twhich both run in O(log n).\n\n\tThe tree is implemented with map semantics, that is, there are separete key\n\tand value pointers.\n\n\tCopyright (c) 2017, Phillip Berndt\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"bostree.h\"\n#include <assert.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* Tree structure */\nstruct _BOSTree {\n\tBOSNode *root_node;\n\n\tBOSTree_cmp_function cmp_function;\n\tBOSTree_free_function free_function;\n};\n\n/* Local helper functions */\nstatic int _imax(const int i1, const int i2) {\n\treturn i1 > i2 ? i1 : i2;\n}\n\nstatic int _bostree_balance(BOSNode *node) {\n\tconst int left_depth = node->left_child_node ? node->left_child_node->depth + 1 : 0;\n\tconst int right_depth = node->right_child_node ? node->right_child_node->depth + 1 : 0;\n\treturn right_depth - left_depth;\n}\n\nstatic BOSNode *_bostree_rotate_right(BOSTree *tree, BOSNode *P) {\n\t// Rotate right:\n\t//\n\t//      P                     L\n\t//  L        R     -->    c1      P\n\t//c1 c2                        c2     R\n\t//\n\tBOSNode *L = P->left_child_node;\n\n\tif(P->parent_node) {\n\t\tif(P->parent_node->left_child_node == P) {\n\t\t\tP->parent_node->left_child_node = L;\n\t\t}\n\t\telse {\n\t\t\tP->parent_node->right_child_node = L;\n\t\t}\n\t}\n\telse {\n\t\ttree->root_node = L;\n\t}\n\n\tL->parent_node = P->parent_node;\n\n\tP->left_child_node = L->right_child_node;\n\tP->left_child_count = L->right_child_count;\n\tif(P->left_child_node) {\n\t\tP->left_child_node->parent_node = P;\n\t}\n\tP->depth = _imax(P->left_child_node ? 1 + P->left_child_node->depth : 0, P->right_child_node ? 1 + P->right_child_node->depth : 0);\n\tP->parent_node = L;\n\n\tL->right_child_node = P;\n\tP->parent_node = L;\n\tL->right_child_count = P->left_child_count + P->right_child_count + 1;\n\tL->depth = _imax(L->left_child_node ? 1 + L->left_child_node->depth : 0, L->right_child_node ? 1 + L->right_child_node->depth : 0);\n\n\treturn L;\n}\n\nstatic BOSNode *_bostree_rotate_left(BOSTree *tree, BOSNode *P) {\n\t// Rotate left:\n\t//\n\t//      P                     R\n\t//  L        R     -->    P      c2\n\t//         c1 c2        L  c1\n\t//\n\tBOSNode *R = P->right_child_node;\n\n\tif(P->parent_node) {\n\t\tif(P->parent_node->left_child_node == P) {\n\t\t\tP->parent_node->left_child_node = R;\n\t\t}\n\t\telse {\n\t\t\tP->parent_node->right_child_node = R;\n\t\t}\n\t}\n\telse {\n\t\ttree->root_node = R;\n\t}\n\n\tR->parent_node = P->parent_node;\n\n\tP->right_child_node = R->left_child_node;\n\tP->right_child_count = R->left_child_count;\n\tif(P->right_child_node) {\n\t\tP->right_child_node->parent_node = P;\n\t}\n\tP->depth = _imax(P->left_child_node ? 1 + P->left_child_node->depth : 0, P->right_child_node ? 1 + P->right_child_node->depth : 0);\n\tP->parent_node = R;\n\n\tR->left_child_node = P;\n\tP->parent_node = R;\n\tR->left_child_count = P->left_child_count + P->right_child_count + 1;\n\tR->depth = _imax(R->left_child_node ? 1 + R->left_child_node->depth : 0, R->right_child_node ? 1 + R->right_child_node->depth : 0);\n\n\treturn R;\n}\n\n\n/* API implementation */\nBOSTree *bostree_new(BOSTree_cmp_function cmp_function, BOSTree_free_function free_function) {\n\tBOSTree *new_tree = malloc(sizeof(BOSTree));\n\tnew_tree->root_node = NULL;\n\tnew_tree->cmp_function = cmp_function;\n\tnew_tree->free_function = free_function;\n\treturn new_tree;\n}\n\nvoid bostree_destroy(BOSTree *tree) {\n\t// Walk the tree and unref all nodes\n\tBOSNode *node = tree->root_node;\n\twhile(node) {\n\t\t// The order should not really matter, but use post-order traversal here.\n\t\twhile(node->left_child_node) {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\n\t\tif(node->right_child_node) {\n\t\t\tnode = node->right_child_node;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At this point, we can be sure that this node has no child nodes.\n\t\t// So it is safe to remove it.\n\t\tBOSNode *next = node->parent_node;\n\t\tif(next) {\n\t\t\tif(next->left_child_node == node) {\n\t\t\t\tnext->left_child_node = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext->right_child_node = NULL;\n\t\t\t}\n\t\t}\n\t\tbostree_node_weak_unref(tree, node);\n\t\tnode = next;\n\t}\n\n\tfree(tree);\n}\n\nunsigned int bostree_node_count(BOSTree *tree) {\n\treturn tree->root_node ? tree->root_node->left_child_count + tree->root_node->right_child_count + 1 : 0;\n}\n\nBOSNode *bostree_insert(BOSTree *tree, void *key, void *data) {\n\tBOSNode **node = &tree->root_node;\n\tBOSNode *parent_node = NULL;\n\n\t// Find tree position to insert new node\n\twhile(*node) {\n\t\tparent_node = *node;\n\t\tint cmp = tree->cmp_function(key, (*node)->key);\n\t\tif(cmp < 0) {\n\t\t\t(*node)->left_child_count++;\n\t\t\tnode = &(*node)->left_child_node;\n\t\t}\n\t\telse {\n\t\t\t(*node)->right_child_count++;\n\t\t\tnode = &(*node)->right_child_node;\n\t\t}\n\t}\n\n\t// Create new node\n\tBOSNode *new_node = malloc(sizeof(BOSNode));\n\tmemset(new_node, 0, sizeof(BOSNode));\n\tnew_node->key = key;\n\tnew_node->data = data;\n\tnew_node->weak_ref_count = 1;\n\tnew_node->weak_ref_node_valid = 1;\n\tnew_node->parent_node = parent_node;\n\n\t*node = new_node;\n\n\tif(!parent_node) {\n\t\t// Simple case, this is the first node.\n\t\ttree->root_node = new_node;\n\t\treturn new_node;\n\t}\n\n\t// Check if the depth changed with the new node:\n\t// It does only change if this is the first child of the parent\n\tif(!!parent_node->left_child_node ^ !!parent_node->right_child_node) {\n\t\t// Bubble the information up the tree\n\t\tparent_node->depth++;\n\t\twhile(parent_node->parent_node) {\n\t\t\t// Assign new depth\n\t\t\tparent_node = parent_node->parent_node;\n\n\t\t\tunsigned int new_left_depth  = parent_node->left_child_node ? parent_node->left_child_node->depth + 1 : 0;\n\t\t\tunsigned int new_right_depth = parent_node->right_child_node ? parent_node->right_child_node->depth + 1 : 0;\n\n\t\t\tunsigned int max_depth = _imax(new_left_depth, new_right_depth);\n\n\t\t\tif(parent_node->depth != max_depth) {\n\t\t\t\tparent_node->depth = max_depth;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We can break here, because if the depth did not change\n\t\t\t\t// at this level, it won't have further up either.\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Check if this node violates the AVL property, that is, that the\n\t\t\t// depths differ by no more than 1.\n\t\t\tif(new_left_depth - 2 == new_right_depth) {\n\t\t\t\t// Handle left-right case\n\t\t\t\tif(_bostree_balance(parent_node->left_child_node) > 0) {\n\t\t\t\t\t_bostree_rotate_left(tree, parent_node->left_child_node);\n\t\t\t\t}\n\n\t\t\t\t// Left is two levels deeper than right. Rotate right.\n\t\t\t\tparent_node = _bostree_rotate_right(tree, parent_node);\n\t\t\t}\n\t\t\telse if(new_left_depth + 2 == new_right_depth) {\n\t\t\t\t// Handle right-left case\n\t\t\t\tif(_bostree_balance(parent_node->right_child_node) < 0) {\n\t\t\t\t\t_bostree_rotate_right(tree, parent_node->right_child_node);\n\t\t\t\t}\n\n\t\t\t\t// Right is two levels deeper than left. Rotate left.\n\t\t\t\tparent_node = _bostree_rotate_left(tree, parent_node);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new_node;\n}\n\nvoid bostree_remove(BOSTree *tree, BOSNode *node) {\n\tBOSNode *bubble_up = NULL;\n\n\t// If this node has children on both sides, bubble one of it upwards\n\t// and rotate within the subtrees.\n\tif(node->left_child_node && node->right_child_node) {\n\t\tBOSNode *candidate = NULL;\n\t\tBOSNode *lost_child = NULL;\n\t\tif(node->left_child_node->depth >= node->right_child_node->depth) {\n\t\t\t// Left branch is deeper than right branch, might be a good idea to\n\t\t\t// bubble from this side to maintain the AVL property with increased\n\t\t\t// likelihood.\n\t\t\tnode->left_child_count--;\n\t\t\tcandidate = node->left_child_node;\n\t\t\twhile(candidate->right_child_node) {\n\t\t\t\tcandidate->right_child_count--;\n\t\t\t\tcandidate = candidate->right_child_node;\n\t\t\t}\n\t\t\tlost_child = candidate->left_child_node;\n\t\t}\n\t\telse {\n\t\t\tnode->right_child_count--;\n\t\t\tcandidate = node->right_child_node;\n\t\t\twhile(candidate->left_child_node) {\n\t\t\t\tcandidate->left_child_count--;\n\t\t\t\tcandidate = candidate->left_child_node;\n\t\t\t}\n\t\t\tlost_child = candidate->right_child_node;\n\t\t}\n\n\t\tBOSNode *bubble_start = candidate->parent_node;\n\t\tif(bubble_start->left_child_node == candidate) {\n\t\t\tbubble_start->left_child_node = lost_child;\n\t\t}\n\t\telse {\n\t\t\tbubble_start->right_child_node = lost_child;\n\t\t}\n\t\tif(lost_child) {\n\t\t\tlost_child->parent_node = bubble_start;\n\t\t}\n\n\t\t// We will later rebalance upwards from bubble_start up to candidate.\n\t\t// But first, anchor candidate into the place where \"node\" used to be.\n\n\t\tif(node->parent_node) {\n\t\t\tif(node->parent_node->left_child_node == node) {\n\t\t\t\tnode->parent_node->left_child_node = candidate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode->parent_node->right_child_node = candidate;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttree->root_node = candidate;\n\t\t}\n\t\tcandidate->parent_node = node->parent_node;\n\n\t\tcandidate->left_child_node = node->left_child_node;\n\t\tcandidate->left_child_count = node->left_child_count;\n\t\tcandidate->right_child_node = node->right_child_node;\n\t\tcandidate->right_child_count = node->right_child_count;\n\n\t\tif(candidate->left_child_node) {\n\t\t\tcandidate->left_child_node->parent_node = candidate;\n\t\t}\n\n\t\tif(candidate->right_child_node) {\n\t\t\tcandidate->right_child_node->parent_node = candidate;\n\t\t}\n\n\t\t// From here on, node is out of the game.\n\t\t// Rebalance up to candidate.\n\n\t\tif(bubble_start != node) {\n\t\t\twhile(bubble_start != candidate) {\n\t\t\t\tbubble_start->depth = _imax((bubble_start->left_child_node ? bubble_start->left_child_node->depth + 1 : 0),\n\t\t\t\t\t(bubble_start->right_child_node ? bubble_start->right_child_node->depth + 1 : 0));\n\t\t\t\tint balance = _bostree_balance(bubble_start);\n\t\t\t\tif(balance > 1) {\n\t\t\t\t\t// Rotate left. Check for right-left case before.\n\t\t\t\t\tif(_bostree_balance(bubble_start->right_child_node) < 0) {\n\t\t\t\t\t\t_bostree_rotate_right(tree, bubble_start->right_child_node);\n\t\t\t\t\t}\n\t\t\t\t\tbubble_start = _bostree_rotate_left(tree, bubble_start);\n\t\t\t\t}\n\t\t\t\telse if(balance < -1) {\n\t\t\t\t\t// Rotate right. Check for left-right case before.\n\t\t\t\t\tif(_bostree_balance(bubble_start->left_child_node) > 0) {\n\t\t\t\t\t\t_bostree_rotate_left(tree, bubble_start->left_child_node);\n\t\t\t\t\t}\n\t\t\t\t\tbubble_start = _bostree_rotate_right(tree, bubble_start);\n\t\t\t\t}\n\t\t\t\tbubble_start = bubble_start->parent_node;\n\t\t\t}\n\t\t}\n\n\t\t// Fixup candidate's depth\n\t\tcandidate->depth = _imax((candidate->left_child_node ? candidate->left_child_node->depth + 1 : 0),\n\t\t\t(candidate->right_child_node ? candidate->right_child_node->depth + 1 : 0));\n\n\t\t// We'll have to fixup child counts and depths up to the root, do that\n\t\t// later.\n\t\tbubble_up = candidate->parent_node;\n\n\t\t// Fix immediate parent node child count here.\n\t\tif(bubble_up) {\n\t\t\tif(bubble_up->left_child_node == candidate) {\n\t\t\t\tbubble_up->left_child_count--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbubble_up->right_child_count--;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// If this node has children on one side only, removing it is much simpler.\n\t\tif(!node->parent_node) {\n\t\t\t// Simple case: Node _was_ the old root.\n\t\t\tif(node->left_child_node) {\n\t\t\t\ttree->root_node = node->left_child_node;\n\t\t\t\tif(node->left_child_node) {\n\t\t\t\t\tnode->left_child_node->parent_node = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttree->root_node = node->right_child_node;\n\t\t\t\tif(node->right_child_node) {\n\t\t\t\t\tnode->right_child_node->parent_node = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No rebalancing to do\n\t\t\tbubble_up = NULL;\n\t\t}\n\t\telse {\n\t\t\tBOSNode *candidate = node->left_child_node;\n\t\t\tint candidate_count = node->left_child_count;\n\t\t\tif(node->right_child_node) {\n\t\t\t\tcandidate = node->right_child_node;\n\t\t\t\tcandidate_count = node->right_child_count;\n\t\t\t}\n\n\t\t\tif(node->parent_node->left_child_node == node) {\n\t\t\t\tnode->parent_node->left_child_node = candidate;\n\t\t\t\tnode->parent_node->left_child_count = candidate_count;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode->parent_node->right_child_node = candidate;\n\t\t\t\tnode->parent_node->right_child_count = candidate_count;\n\t\t\t}\n\n\t\t\tif(candidate) {\n\t\t\t\tcandidate->parent_node = node->parent_node;\n\t\t\t}\n\n\t\t\t// Again, from here on, the original node is out of the game.\n\t\t\t// Rebalance up to the root.\n\t\t\tbubble_up = node->parent_node;\n\t\t}\n\t}\n\n\t// At this point, everything below and including bubble_start is\n\t// balanced, and we have to look further up.\n\n\tchar bubbling_finished = 0;\n\twhile(bubble_up) {\n\t\tif(!bubbling_finished) {\n\t\t\t// Calculate updated depth for bubble_up\n\t\t\tunsigned int left_depth = bubble_up->left_child_node ? bubble_up->left_child_node->depth + 1 : 0;\n\t\t\tunsigned int right_depth = bubble_up->right_child_node ? bubble_up->right_child_node->depth + 1 : 0;\n\t\t\tunsigned int new_depth = _imax(left_depth, right_depth);\n\t\t\tchar depth_changed = (new_depth != bubble_up->depth);\n\t\t\tbubble_up->depth = new_depth;\n\n\t\t\t// Rebalance bubble_up\n\t\t\t// Not necessary for the first node, but calling _bostree_balance once\n\t\t\t// isn't that much overhead.\n\t\t\tint balance = _bostree_balance(bubble_up);\n\t\t\tif(balance < -1) {\n\t\t\t\tif(_bostree_balance(bubble_up->left_child_node) > 0) {\n\t\t\t\t\t_bostree_rotate_left(tree, bubble_up->left_child_node);\n\t\t\t\t}\n\t\t\t\tbubble_up = _bostree_rotate_right(tree, bubble_up);\n\t\t\t}\n\t\t\telse if(balance > 1) {\n\t\t\t\tif(_bostree_balance(bubble_up->right_child_node) < 0) {\n\t\t\t\t\t_bostree_rotate_right(tree, bubble_up->right_child_node);\n\t\t\t\t}\n\t\t\t\tbubble_up = _bostree_rotate_left(tree, bubble_up);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(!depth_changed) {\n\t\t\t\t\t// If we neither had to rotate nor to change the depth,\n\t\t\t\t\t// then we are obviously finished.  Only update child\n\t\t\t\t\t// counts from here on.\n\t\t\t\t\tbubbling_finished = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(bubble_up->parent_node) {\n\t\t\tif(bubble_up->parent_node->left_child_node == bubble_up) {\n\t\t\t\tbubble_up->parent_node->left_child_count--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbubble_up->parent_node->right_child_count--;\n\t\t\t}\n\t\t}\n\t\tbubble_up = bubble_up->parent_node;\n\t}\n\n\tnode->weak_ref_node_valid = 0;\n\tbostree_node_weak_unref(tree, node);\n}\n\nBOSNode *bostree_node_weak_ref(BOSNode *node) {\n\tassert(node->weak_ref_count < 127);\n\tassert(node->weak_ref_count > 0);\n\tnode->weak_ref_count++;\n\treturn node;\n}\n\nBOSNode *bostree_node_weak_unref(BOSTree *tree, BOSNode *node) {\n\tnode->weak_ref_count--;\n\tif(node->weak_ref_count == 0) {\n\t\tif(tree->free_function) {\n\t\t\ttree->free_function(node);\n\t\t}\n\t\tfree(node);\n\t}\n\telse if(node->weak_ref_node_valid) {\n\t\treturn node;\n\t}\n\treturn NULL;\n}\n\nBOSNode *bostree_lookup(BOSTree *tree, const void *key) {\n\tBOSNode *node = tree->root_node;\n\twhile(node) {\n\t\tint cmp = tree->cmp_function(key, node->key);\n\t\tif(cmp == 0) {\n\t\t\tbreak;\n\t\t}\n\t\telse if(cmp < 0) {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\t\telse {\n\t\t\tnode = node->right_child_node;\n\t\t}\n\t}\n\treturn node;\n}\n\nBOSNode *bostree_select(BOSTree *tree, unsigned int index) {\n\tBOSNode *node = tree->root_node;\n\twhile(node) {\n\t\tif(node->left_child_count <= index) {\n\t\t\tindex -= node->left_child_count;\n\t\t\tif(index == 0) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\tindex--;\n\t\t\tnode = node->right_child_node;\n\t\t}\n\t\telse {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\t}\n\treturn node;\n}\n\nBOSNode *bostree_next_node(BOSNode *node) {\n\tif(node->right_child_node) {\n\t\tnode = node->right_child_node;\n\t\twhile(node->left_child_node) {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\t\treturn node;\n\t}\n\telse if(node->parent_node) {\n\t\twhile(node->parent_node && node->parent_node->right_child_node == node) {\n\t\t\tnode = node->parent_node;\n\t\t}\n\t\treturn node->parent_node;\n\t}\n\treturn NULL;\n}\n\nBOSNode *bostree_previous_node(BOSNode *node) {\n\tif(node->left_child_node) {\n\t\tnode = node->left_child_node;\n\t\twhile(node->right_child_node) {\n\t\t\tnode = node->right_child_node;\n\t\t}\n\t\treturn node;\n\t}\n\telse if(node->parent_node) {\n\t\twhile(node->parent_node && node->parent_node->left_child_node == node) {\n\t\t\tnode = node->parent_node;\n\t\t}\n\t\treturn node->parent_node;\n\t}\n\treturn NULL;\n}\n\nunsigned int bostree_rank(BOSNode *node) {\n\tunsigned int counter = node->left_child_count;\n\twhile(node) {\n\t\tif(node->parent_node && node->parent_node->right_child_node == node) counter += 1 + node->parent_node->left_child_count;\n\t\tnode = node->parent_node;\n\t}\n\treturn counter;\n}\n\n#if !defined(NDEBUG)\n#include <stdio.h>\n#include <unistd.h>\n\n/* Debug helpers:\n\n\tPrint the tree to stdout in dot format.\n*/\n\nstatic void _bostree_print_helper(BOSNode *node) {\n\tprintf(\"  %s [label=\\\"\\\\N (%d,%d,%d)\\\"];\\n\", (char *)node->key, node->left_child_count, node->right_child_count, node->depth);\n\tif(node->parent_node) {\n\t\tprintf(\"  %s -> %s [color=green];\\n\", (char *)node->key, (char *)node->parent_node->key);\n\t}\n\n\tif(node->left_child_node != NULL) {\n\t\tprintf(\"  %s -> %s\\n\", (char *)node->key, (char *)node->left_child_node->key);\n\t\t_bostree_print_helper(node->left_child_node);\n\t}\n\tif(node->right_child_node != NULL) {\n\t\tprintf(\"  %s -> %s\\n\", (char *)node->key, (char *)node->right_child_node->key);\n\t\t_bostree_print_helper(node->right_child_node);\n\t}\n}\n\nvoid bostree_print(BOSTree *tree) {\n\tif(tree->root_node == NULL) {\n\t\treturn;\n\t}\n\n\tprintf(\"digraph {\\n  ordering = out;\\n\");\n\t_bostree_print_helper(tree->root_node);\n\tprintf(\"}\\n\");\n\tfsync(0);\n}\n#endif\n",
    "bostree.h": "/*\n\tSelf-Balancing order statistic tree\n\n\tImplements an AVL tree with two additional methods,\n\tSelect(i), which finds the i'th smallest element, and\n\tRank(x), which returns the rank of a given element,\n\twhich both run in O(log n).\n\n\tThe tree is implemented with map semantics, that is, there are separete key\n\tand value pointers.\n\n\tCopyright (c) 2017, Phillip Berndt\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef BOSTREE_H\n#define BOSTREE_H\n\n/* Opaque tree structure */\ntypedef struct _BOSTree BOSTree;\n\n/* Node structure */\nstruct _BOSNode {\n\tunsigned int left_child_count;\n\tunsigned int right_child_count;\n\tunsigned int depth;\n\n\tstruct _BOSNode *left_child_node;\n\tstruct _BOSNode *right_child_node;\n\tstruct _BOSNode *parent_node;\n\n\tvoid *key;\n\tvoid *data;\n\n\tunsigned char weak_ref_count;\n\tunsigned char weak_ref_node_valid;\n};\ntypedef struct _BOSNode BOSNode;\n\n/*\n\tPublic interface\n*/\n\n/**\n * Key comparison function.\n *\n * Should return a positive value if the second argument is larger than the\n * first one, a negative value if the first is larger, and zero exactly if both\n * are equal.\n */\ntypedef int (*BOSTree_cmp_function)(const void *, const void *);\n\n/**\n * Free function for deleted nodes.\n *\n * This function should free the key and data members of a node. The node\n * structure itself is free()d internally by BOSZTree.\n */\ntypedef void (*BOSTree_free_function)(BOSNode *node);\n\n/**\n * Create a new tree.\n *\n * The cmp_function is mandatory, but for the free function, you may supply a\n * NULL pointer if you do not have any data that needs to be free()d in\n * ->key and ->data.\n */\nBOSTree *bostree_new(BOSTree_cmp_function cmp_function, BOSTree_free_function free_function);\n\n/**\n * Destroy a tree and all its members.\n */\nvoid bostree_destroy(BOSTree *tree);\n\n/**\n * Return the number of nodes in a tree\n */\nunsigned int bostree_node_count(BOSTree *tree);\n\n/**\n * Insert a new member into the tree and return the associated node.\n */\nBOSNode *bostree_insert(BOSTree *tree, void *key, void *data);\n\n/**\n * Remove a given node from a tree.\n */\nvoid bostree_remove(BOSTree *tree, BOSNode *node);\n\n/**\n * Weak reference management for nodes.\n *\n * Nodes have an internal reference counter. They are only free()d after the\n * last weak reference has been removed. Calling bostree_node_weak_unref() on a\n * node which has been removed from the tree results in the weak reference\n * count being decreased, the node being possibly free()d if this has been the\n * last weak reference, and a NULL pointer being returned.\n */\nBOSNode *bostree_node_weak_ref(BOSNode *node);\n\n/**\n * Weak reference management for nodes.\n * See bostree_node_weak_ref()\n */\nBOSNode *bostree_node_weak_unref(BOSTree *tree, BOSNode *node);\n\n/**\n * Return a node given a key. NULL is returned if a key is not present in the\n * tree.\n */\nBOSNode *bostree_lookup(BOSTree *tree, const void *key);\n\n/**\n * Return a node given an index in in-order traversal. Indexing starts at 0.\n */\nBOSNode *bostree_select(BOSTree *tree, unsigned int index);\n\n/**\n * Return the next node in in-order traversal, or NULL is node was the last\n * node in the tree.\n */\nBOSNode *bostree_next_node(BOSNode *node);\n\n/**\n * Return the previous node in in-order traversal, or NULL is node was the first\n * node in the tree.\n */\nBOSNode *bostree_previous_node(BOSNode *node);\n\n/**\n * Return the rank of a node within it's owning tree.\n *\n * bostree_select(bostree_rank(node)) == node is always true.\n */\nunsigned int bostree_rank(BOSNode *node);\n\n#if !defined(NDEBUG) && (_BSD_SOURCE || _XOPEN_SOURCE || _POSIX_C_SOURCE >= 200112L)\nvoid bostree_print(BOSTree *tree);\n#define bostree_debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define bostree_debug(...) void\n#endif\n\n#endif\n",
    "c": "",
    "c_pre_post_conditions": "Function: _imax\nPre-condition:\n    \u2013 None (i1 and i2 may be any int values, no overflow assumed).\nPost-condition:\n    \u2013 Returns the greater of i1 and i2.\n    \u2013 Return value \u2265 i1 and \u2265 i2, and equal to one of them.\n\nFunction: _bostree_balance\nPre-condition:\n    \u2013 node != NULL.\n    \u2013 node->depth == max(child depths + 1) if children exist.\n    \u2013 children\u2019 depth fields are up\u2010to\u2010date.\nPost-condition:\n    \u2013 Returns (height of right subtree) \u2013 (height of left subtree).\n    \u2013 Does not modify node or its subtree.\n\nFunction: _bostree_rotate_right\nPre-condition:\n    \u2013 tree != NULL, P != NULL.\n    \u2013 P->left_child_node != NULL.\n    \u2013 P and P->left_child_node (\u201cL\u201d) have correct parent/child pointers,\n      left_child_count, right_child_count and depth.\nPost-condition:\n    \u2013 Subtree formerly rooted at P is now rooted at L.\n    \u2013 BST ordering of keys is preserved.\n    \u2013 P->left_child_count := old L->right_child_count.\n      L->right_child_count := (old P->left_child_count + old P->right_child_count + 1).\n    \u2013 P->depth and L->depth updated to max(child depths + 1).\n    \u2013 Parent pointers of P, L, and any moved children are correct.\n    \u2013 If P was tree->root_node, tree->root_node := L.\n    \u2013 Global BST, AVL balance, and order\u2010statistic invariants hold.\n\nFunction: _bostree_rotate_left\nPre-condition:\n    \u2013 tree != NULL, P != NULL.\n    \u2013 P->right_child_node != NULL.\n    \u2013 P and P->right_child_node (\u201cR\u201d) have correct pointers, counts, depths.\nPost-condition:\n    \u2013 Subtree rotated left: R becomes root of that subtree.\n    \u2013 BST ordering preserved.\n    \u2013 P->right_child_count := old R->left_child_count.\n      R->left_child_count := (old P->left_child_count + old P->right_child_count + 1).\n    \u2013 P->depth and R->depth updated.\n    \u2013 Parent/child pointers corrected.\n    \u2013 If P was tree->root_node, tree->root_node := R.\n    \u2013 AVL and order\u2010statistic invariants still hold.\n\nFunction: bostree_new\nPre-condition:\n    \u2013 cmp_function != NULL.\nPost-condition:\n    \u2013 Returns a non\u2010NULL BOSTree*.\n    \u2013 tree->root_node == NULL.\n    \u2013 tree->cmp_function == cmp_function.\n    \u2013 tree->free_function == free_function.\n    \u2013 Tree is empty and ready for insertions.\n\nFunction: bostree_destroy\nPre-condition:\n    \u2013 tree != NULL.\n    \u2013 No concurrent operations on this tree.\nPost-condition:\n    \u2013 All BOSNode instances in the tree have been weak-unref\u2019ed.\n    \u2013 free_function(node) called for each node if provided.\n    \u2013 All node memory and the BOSTree struct itself are freed.\n    \u2013 No memory leaks of tree or nodes.\n\nFunction: bostree_node_count\nPre-condition:\n    \u2013 tree != NULL.\n    \u2013 The BST\u2019s child counts are correct.\nPost-condition:\n    \u2013 Returns 0 if tree->root_node == NULL.\n    \u2013 Otherwise returns (root->left_child_count + root->right_child_count + 1).\n    \u2013 Does not modify the tree.\n\nFunction: bostree_insert\nPre-condition:\n    \u2013 tree != NULL.\n    \u2013 key, data are valid pointers (key can be NULL if cmp handles it).\n    \u2013 tree satisfies BST invariant (left keys < node->key \u2264 right keys),\n      AVL balance (for every node, |balance| \u2264 1), and correct counts/depths.\nPost-condition:\n    \u2013 A new node N is allocated, N->key==key, N->data==data.\n    \u2013 N->weak_ref_count == 1, N->weak_ref_node_valid == 1.\n    \u2013 N is placed so that BST ordering holds.\n    \u2013 All ancestors on the insertion path have their left_child_count or\n      right_child_count incremented by 1.\n    \u2013 Depth fields on the path to root are updated, and any necessary\n      rotations restore AVL balance.\n    \u2013 Parent/child pointers remain consistent.\n    \u2013 Tree size increases by 1.\n    \u2013 Returns pointer to N.\n\nFunction: bostree_remove\nPre-condition:\n    \u2013 tree != NULL.\n    \u2013 node != NULL, node->weak_ref_node_valid == 1.\n    \u2013 node belongs to tree, which satisfies BST, AVL, and order\u2010statistic invariants.\nPost-condition:\n    \u2013 node is unlinked from the tree.\n    \u2013 If node had two children, an in\u2010order predecessor or successor is \u201cbubbled\u201d\n      into its place, and that side\u2019s child counts are decremented along the way.\n    \u2013 Otherwise its single child (if any) replaces it.\n    \u2013 All affected ancestor depths and child counts are updated.\n    \u2013 AVL rotations restore |balance| \u2264 1 at every node.\n    \u2013 BST and order\u2010statistic invariants hold on the resulting tree.\n    \u2013 node->weak_ref_node_valid is set to 0.\n    \u2013 A call to bostree_node_weak_unref(tree, node) is made; if that was the last\n      weak reference, free_function(node) is called and node freed.\n    \u2013 Tree size decreases by 1.\n\nFunction: bostree_node_weak_ref\nPre-condition:\n    \u2013 node != NULL.\n    \u2013 1 \u2264 node->weak_ref_count < 127.\nPost-condition:\n    \u2013 node->weak_ref_count is incremented by 1.\n    \u2013 node->weak_ref_node_valid is unchanged.\n    \u2013 Returns node.\n\nFunction: bostree_node_weak_unref\nPre-condition:\n    \u2013 tree != NULL (unless node was never in a tree).\n    \u2013 node != NULL.\n    \u2013 node->weak_ref_count \u2265 1.\nPost-condition:\n    \u2013 node->weak_ref_count is decremented by 1.\n    \u2013 If node->weak_ref_count == 0:\n         \u2022 If tree->free_function != NULL, free_function(node) is called.\n         \u2022 node is freed (via free(node)).\n         \u2022 Returns NULL.\n      Else if node->weak_ref_node_valid == 1:\n         \u2022 Returns node.\n      Else:\n         \u2022 Returns NULL.\n\nFunction: bostree_lookup\nPre-condition:\n    \u2013 tree != NULL.\n    \u2013 BST invariant holds under cmp_function.\nPost-condition:\n    \u2013 Traverses from root comparing key via cmp_function.\n    \u2013 Returns first node for which cmp(key,node->key) == 0, or NULL if none.\n    \u2013 Does not modify the tree or node counts/depths.\n\nFunction: bostree_select\nPre-condition:\n    \u2013 tree != NULL.\n    \u2013 tree->root_node\u2019s left_child_count/right_child_count are correct.\n    \u2013 Desired index \u2208 [0, node_count(tree)\u22121] to get non\u2010NULL result.\nPost-condition:\n    \u2013 Walks from root, at each node:\n         \u2022 If index < left_child_count, go left.\n         \u2022 Else if index == left_child_count, return node.\n         \u2022 Else subtract (left_child_count + 1) from index and go right.\n    \u2013 Returns the node at in\u2010order position \u2018index\u2019, or NULL if index out of range.\n    \u2013 Tree unchanged.\n\nFunction: bostree_next_node\nPre-condition:\n    \u2013 node != NULL.\n    \u2013 parent/child pointers form a valid BST.\nPost-condition:\n    \u2013 If node->right_child_node != NULL, returns the leftmost node in that subtree.\n    \u2013 Else walks up via parent pointers until node is a left child, returns that parent.\n    \u2013 Returns NULL if node is the maximum element.\n    \u2013 Does not modify the tree.\n\nFunction: bostree_previous_node\nPre-condition:\n    \u2013 node != NULL.\n    \u2013 parent/child pointers are consistent.\nPost-condition:\n    \u2013 If node->left_child_node != NULL, returns the rightmost node in that subtree.\n    \u2013 Else walks up until node is a right child, returns that parent.\n    \u2013 Returns NULL if node is the minimum element.\n    \u2013 Does not modify the tree.\n\nFunction: bostree_rank\nPre-condition:\n    \u2013 node != NULL.\n    \u2013 node belongs to a tree whose left_child_count fields are correct.\nPost-condition:\n    \u2013 Initializes counter = node->left_child_count.\n    \u2013 Walks up via parent pointers:\n         \u2022 Every time node is a right child, adds (1 + parent->left_child_count).\n    \u2013 Returns the total: the 0\u2010based in\u2010order rank of node.\n    \u2013 Does not modify the tree.",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\nFunction: function_name\nPre-condition: description of the pre-condition\nPost-condition: description of the post-condition\n```\n\nHere is the code:\n{{bostree.c}}\n```c\n// header file\n/*/*\n\tSelf-Balancing order statistic tree\n\n\tImplements an AVL tree with two additional methods,\n\tSelect(i), which finds the i'th smallest element, and\n\tRank(x), which returns the rank of a given element,\n\twhich both run in O(log n).\n\n\tThe tree is implemented with map semantics, that is, there are separete key\n\tand value pointers.\n\n\tCopyright (c) 2017, Phillip Berndt\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#ifndef BOSTREE_H\n#define BOSTREE_H\n\n/* Opaque tree structure */\ntypedef struct _BOSTree BOSTree;\n\n/* Node structure */\nstruct _BOSNode {\n\tunsigned int left_child_count;\n\tunsigned int right_child_count;\n\tunsigned int depth;\n\n\tstruct _BOSNode *left_child_node;\n\tstruct _BOSNode *right_child_node;\n\tstruct _BOSNode *parent_node;\n\n\tvoid *key;\n\tvoid *data;\n\n\tunsigned char weak_ref_count;\n\tunsigned char weak_ref_node_valid;\n};\ntypedef struct _BOSNode BOSNode;\n\n/*\n\tPublic interface\n*/\n\n/**\n * Key comparison function.\n *\n * Should return a positive value if the second argument is larger than the\n * first one, a negative value if the first is larger, and zero exactly if both\n * are equal.\n */\ntypedef int (*BOSTree_cmp_function)(const void *, const void *);\n\n/**\n * Free function for deleted nodes.\n *\n * This function should free the key and data members of a node. The node\n * structure itself is free()d internally by BOSZTree.\n */\ntypedef void (*BOSTree_free_function)(BOSNode *node);\n\n/**\n * Create a new tree.\n *\n * The cmp_function is mandatory, but for the free function, you may supply a\n * NULL pointer if you do not have any data that needs to be free()d in\n * ->key and ->data.\n */\nBOSTree *bostree_new(BOSTree_cmp_function cmp_function, BOSTree_free_function free_function);\n\n/**\n * Destroy a tree and all its members.\n */\nvoid bostree_destroy(BOSTree *tree);\n\n/**\n * Return the number of nodes in a tree\n */\nunsigned int bostree_node_count(BOSTree *tree);\n\n/**\n * Insert a new member into the tree and return the associated node.\n */\nBOSNode *bostree_insert(BOSTree *tree, void *key, void *data);\n\n/**\n * Remove a given node from a tree.\n */\nvoid bostree_remove(BOSTree *tree, BOSNode *node);\n\n/**\n * Weak reference management for nodes.\n *\n * Nodes have an internal reference counter. They are only free()d after the\n * last weak reference has been removed. Calling bostree_node_weak_unref() on a\n * node which has been removed from the tree results in the weak reference\n * count being decreased, the node being possibly free()d if this has been the\n * last weak reference, and a NULL pointer being returned.\n */\nBOSNode *bostree_node_weak_ref(BOSNode *node);\n\n/**\n * Weak reference management for nodes.\n * See bostree_node_weak_ref()\n */\nBOSNode *bostree_node_weak_unref(BOSTree *tree, BOSNode *node);\n\n/**\n * Return a node given a key. NULL is returned if a key is not present in the\n * tree.\n */\nBOSNode *bostree_lookup(BOSTree *tree, const void *key);\n\n/**\n * Return a node given an index in in-order traversal. Indexing starts at 0.\n */\nBOSNode *bostree_select(BOSTree *tree, unsigned int index);\n\n/**\n * Return the next node in in-order traversal, or NULL is node was the last\n * node in the tree.\n */\nBOSNode *bostree_next_node(BOSNode *node);\n\n/**\n * Return the previous node in in-order traversal, or NULL is node was the first\n * node in the tree.\n */\nBOSNode *bostree_previous_node(BOSNode *node);\n\n/**\n * Return the rank of a node within it's owning tree.\n *\n * bostree_select(bostree_rank(node)) == node is always true.\n */\nunsigned int bostree_rank(BOSNode *node);\n\n#if !defined(NDEBUG) && (_BSD_SOURCE || _XOPEN_SOURCE || _POSIX_C_SOURCE >= 200112L)\nvoid bostree_print(BOSTree *tree);\n#define bostree_debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define bostree_debug(...) void\n#endif\n\n#endif\n*/\n/*\n\tSelf-Balancing order statistic tree\n\n\tImplements an AVL tree with two additional methods,\n\tSelect(i), which finds the i'th smallest element, and\n\tRank(x), which returns the rank of a given element,\n\twhich both run in O(log n).\n\n\tThe tree is implemented with map semantics, that is, there are separete key\n\tand value pointers.\n\n\tCopyright (c) 2017, Phillip Berndt\n\n\tThis program is free software: you can redistribute it and/or modify\n\tit under the terms of the GNU General Public License as published by\n\tthe Free Software Foundation, either version 3 of the License, or\n\t(at your option) any later version.\n\n\tThis program is distributed in the hope that it will be useful,\n\tbut WITHOUT ANY WARRANTY; without even the implied warranty of\n\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\tGNU General Public License for more details.\n\n\tYou should have received a copy of the GNU General Public License\n\talong with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"bostree.h\"\n#include <assert.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* Tree structure */\nstruct _BOSTree {\n\tBOSNode *root_node;\n\n\tBOSTree_cmp_function cmp_function;\n\tBOSTree_free_function free_function;\n};\n\n/* Local helper functions */\nstatic int _imax(const int i1, const int i2) {\n\treturn i1 > i2 ? i1 : i2;\n}\n\nstatic int _bostree_balance(BOSNode *node) {\n\tconst int left_depth = node->left_child_node ? node->left_child_node->depth + 1 : 0;\n\tconst int right_depth = node->right_child_node ? node->right_child_node->depth + 1 : 0;\n\treturn right_depth - left_depth;\n}\n\nstatic BOSNode *_bostree_rotate_right(BOSTree *tree, BOSNode *P) {\n\t// Rotate right:\n\t//\n\t//      P                     L\n\t//  L        R     -->    c1      P\n\t//c1 c2                        c2     R\n\t//\n\tBOSNode *L = P->left_child_node;\n\n\tif(P->parent_node) {\n\t\tif(P->parent_node->left_child_node == P) {\n\t\t\tP->parent_node->left_child_node = L;\n\t\t}\n\t\telse {\n\t\t\tP->parent_node->right_child_node = L;\n\t\t}\n\t}\n\telse {\n\t\ttree->root_node = L;\n\t}\n\n\tL->parent_node = P->parent_node;\n\n\tP->left_child_node = L->right_child_node;\n\tP->left_child_count = L->right_child_count;\n\tif(P->left_child_node) {\n\t\tP->left_child_node->parent_node = P;\n\t}\n\tP->depth = _imax(P->left_child_node ? 1 + P->left_child_node->depth : 0, P->right_child_node ? 1 + P->right_child_node->depth : 0);\n\tP->parent_node = L;\n\n\tL->right_child_node = P;\n\tP->parent_node = L;\n\tL->right_child_count = P->left_child_count + P->right_child_count + 1;\n\tL->depth = _imax(L->left_child_node ? 1 + L->left_child_node->depth : 0, L->right_child_node ? 1 + L->right_child_node->depth : 0);\n\n\treturn L;\n}\n\nstatic BOSNode *_bostree_rotate_left(BOSTree *tree, BOSNode *P) {\n\t// Rotate left:\n\t//\n\t//      P                     R\n\t//  L        R     -->    P      c2\n\t//         c1 c2        L  c1\n\t//\n\tBOSNode *R = P->right_child_node;\n\n\tif(P->parent_node) {\n\t\tif(P->parent_node->left_child_node == P) {\n\t\t\tP->parent_node->left_child_node = R;\n\t\t}\n\t\telse {\n\t\t\tP->parent_node->right_child_node = R;\n\t\t}\n\t}\n\telse {\n\t\ttree->root_node = R;\n\t}\n\n\tR->parent_node = P->parent_node;\n\n\tP->right_child_node = R->left_child_node;\n\tP->right_child_count = R->left_child_count;\n\tif(P->right_child_node) {\n\t\tP->right_child_node->parent_node = P;\n\t}\n\tP->depth = _imax(P->left_child_node ? 1 + P->left_child_node->depth : 0, P->right_child_node ? 1 + P->right_child_node->depth : 0);\n\tP->parent_node = R;\n\n\tR->left_child_node = P;\n\tP->parent_node = R;\n\tR->left_child_count = P->left_child_count + P->right_child_count + 1;\n\tR->depth = _imax(R->left_child_node ? 1 + R->left_child_node->depth : 0, R->right_child_node ? 1 + R->right_child_node->depth : 0);\n\n\treturn R;\n}\n\n\n/* API implementation */\nBOSTree *bostree_new(BOSTree_cmp_function cmp_function, BOSTree_free_function free_function) {\n\tBOSTree *new_tree = malloc(sizeof(BOSTree));\n\tnew_tree->root_node = NULL;\n\tnew_tree->cmp_function = cmp_function;\n\tnew_tree->free_function = free_function;\n\treturn new_tree;\n}\n\nvoid bostree_destroy(BOSTree *tree) {\n\t// Walk the tree and unref all nodes\n\tBOSNode *node = tree->root_node;\n\twhile(node) {\n\t\t// The order should not really matter, but use post-order traversal here.\n\t\twhile(node->left_child_node) {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\n\t\tif(node->right_child_node) {\n\t\t\tnode = node->right_child_node;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// At this point, we can be sure that this node has no child nodes.\n\t\t// So it is safe to remove it.\n\t\tBOSNode *next = node->parent_node;\n\t\tif(next) {\n\t\t\tif(next->left_child_node == node) {\n\t\t\t\tnext->left_child_node = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnext->right_child_node = NULL;\n\t\t\t}\n\t\t}\n\t\tbostree_node_weak_unref(tree, node);\n\t\tnode = next;\n\t}\n\n\tfree(tree);\n}\n\nunsigned int bostree_node_count(BOSTree *tree) {\n\treturn tree->root_node ? tree->root_node->left_child_count + tree->root_node->right_child_count + 1 : 0;\n}\n\nBOSNode *bostree_insert(BOSTree *tree, void *key, void *data) {\n\tBOSNode **node = &tree->root_node;\n\tBOSNode *parent_node = NULL;\n\n\t// Find tree position to insert new node\n\twhile(*node) {\n\t\tparent_node = *node;\n\t\tint cmp = tree->cmp_function(key, (*node)->key);\n\t\tif(cmp < 0) {\n\t\t\t(*node)->left_child_count++;\n\t\t\tnode = &(*node)->left_child_node;\n\t\t}\n\t\telse {\n\t\t\t(*node)->right_child_count++;\n\t\t\tnode = &(*node)->right_child_node;\n\t\t}\n\t}\n\n\t// Create new node\n\tBOSNode *new_node = malloc(sizeof(BOSNode));\n\tmemset(new_node, 0, sizeof(BOSNode));\n\tnew_node->key = key;\n\tnew_node->data = data;\n\tnew_node->weak_ref_count = 1;\n\tnew_node->weak_ref_node_valid = 1;\n\tnew_node->parent_node = parent_node;\n\n\t*node = new_node;\n\n\tif(!parent_node) {\n\t\t// Simple case, this is the first node.\n\t\ttree->root_node = new_node;\n\t\treturn new_node;\n\t}\n\n\t// Check if the depth changed with the new node:\n\t// It does only change if this is the first child of the parent\n\tif(!!parent_node->left_child_node ^ !!parent_node->right_child_node) {\n\t\t// Bubble the information up the tree\n\t\tparent_node->depth++;\n\t\twhile(parent_node->parent_node) {\n\t\t\t// Assign new depth\n\t\t\tparent_node = parent_node->parent_node;\n\n\t\t\tunsigned int new_left_depth  = parent_node->left_child_node ? parent_node->left_child_node->depth + 1 : 0;\n\t\t\tunsigned int new_right_depth = parent_node->right_child_node ? parent_node->right_child_node->depth + 1 : 0;\n\n\t\t\tunsigned int max_depth = _imax(new_left_depth, new_right_depth);\n\n\t\t\tif(parent_node->depth != max_depth) {\n\t\t\t\tparent_node->depth = max_depth;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We can break here, because if the depth did not change\n\t\t\t\t// at this level, it won't have further up either.\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Check if this node violates the AVL property, that is, that the\n\t\t\t// depths differ by no more than 1.\n\t\t\tif(new_left_depth - 2 == new_right_depth) {\n\t\t\t\t// Handle left-right case\n\t\t\t\tif(_bostree_balance(parent_node->left_child_node) > 0) {\n\t\t\t\t\t_bostree_rotate_left(tree, parent_node->left_child_node);\n\t\t\t\t}\n\n\t\t\t\t// Left is two levels deeper than right. Rotate right.\n\t\t\t\tparent_node = _bostree_rotate_right(tree, parent_node);\n\t\t\t}\n\t\t\telse if(new_left_depth + 2 == new_right_depth) {\n\t\t\t\t// Handle right-left case\n\t\t\t\tif(_bostree_balance(parent_node->right_child_node) < 0) {\n\t\t\t\t\t_bostree_rotate_right(tree, parent_node->right_child_node);\n\t\t\t\t}\n\n\t\t\t\t// Right is two levels deeper than left. Rotate left.\n\t\t\t\tparent_node = _bostree_rotate_left(tree, parent_node);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new_node;\n}\n\nvoid bostree_remove(BOSTree *tree, BOSNode *node) {\n\tBOSNode *bubble_up = NULL;\n\n\t// If this node has children on both sides, bubble one of it upwards\n\t// and rotate within the subtrees.\n\tif(node->left_child_node && node->right_child_node) {\n\t\tBOSNode *candidate = NULL;\n\t\tBOSNode *lost_child = NULL;\n\t\tif(node->left_child_node->depth >= node->right_child_node->depth) {\n\t\t\t// Left branch is deeper than right branch, might be a good idea to\n\t\t\t// bubble from this side to maintain the AVL property with increased\n\t\t\t// likelihood.\n\t\t\tnode->left_child_count--;\n\t\t\tcandidate = node->left_child_node;\n\t\t\twhile(candidate->right_child_node) {\n\t\t\t\tcandidate->right_child_count--;\n\t\t\t\tcandidate = candidate->right_child_node;\n\t\t\t}\n\t\t\tlost_child = candidate->left_child_node;\n\t\t}\n\t\telse {\n\t\t\tnode->right_child_count--;\n\t\t\tcandidate = node->right_child_node;\n\t\t\twhile(candidate->left_child_node) {\n\t\t\t\tcandidate->left_child_count--;\n\t\t\t\tcandidate = candidate->left_child_node;\n\t\t\t}\n\t\t\tlost_child = candidate->right_child_node;\n\t\t}\n\n\t\tBOSNode *bubble_start = candidate->parent_node;\n\t\tif(bubble_start->left_child_node == candidate) {\n\t\t\tbubble_start->left_child_node = lost_child;\n\t\t}\n\t\telse {\n\t\t\tbubble_start->right_child_node = lost_child;\n\t\t}\n\t\tif(lost_child) {\n\t\t\tlost_child->parent_node = bubble_start;\n\t\t}\n\n\t\t// We will later rebalance upwards from bubble_start up to candidate.\n\t\t// But first, anchor candidate into the place where \"node\" used to be.\n\n\t\tif(node->parent_node) {\n\t\t\tif(node->parent_node->left_child_node == node) {\n\t\t\t\tnode->parent_node->left_child_node = candidate;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode->parent_node->right_child_node = candidate;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttree->root_node = candidate;\n\t\t}\n\t\tcandidate->parent_node = node->parent_node;\n\n\t\tcandidate->left_child_node = node->left_child_node;\n\t\tcandidate->left_child_count = node->left_child_count;\n\t\tcandidate->right_child_node = node->right_child_node;\n\t\tcandidate->right_child_count = node->right_child_count;\n\n\t\tif(candidate->left_child_node) {\n\t\t\tcandidate->left_child_node->parent_node = candidate;\n\t\t}\n\n\t\tif(candidate->right_child_node) {\n\t\t\tcandidate->right_child_node->parent_node = candidate;\n\t\t}\n\n\t\t// From here on, node is out of the game.\n\t\t// Rebalance up to candidate.\n\n\t\tif(bubble_start != node) {\n\t\t\twhile(bubble_start != candidate) {\n\t\t\t\tbubble_start->depth = _imax((bubble_start->left_child_node ? bubble_start->left_child_node->depth + 1 : 0),\n\t\t\t\t\t(bubble_start->right_child_node ? bubble_start->right_child_node->depth + 1 : 0));\n\t\t\t\tint balance = _bostree_balance(bubble_start);\n\t\t\t\tif(balance > 1) {\n\t\t\t\t\t// Rotate left. Check for right-left case before.\n\t\t\t\t\tif(_bostree_balance(bubble_start->right_child_node) < 0) {\n\t\t\t\t\t\t_bostree_rotate_right(tree, bubble_start->right_child_node);\n\t\t\t\t\t}\n\t\t\t\t\tbubble_start = _bostree_rotate_left(tree, bubble_start);\n\t\t\t\t}\n\t\t\t\telse if(balance < -1) {\n\t\t\t\t\t// Rotate right. Check for left-right case before.\n\t\t\t\t\tif(_bostree_balance(bubble_start->left_child_node) > 0) {\n\t\t\t\t\t\t_bostree_rotate_left(tree, bubble_start->left_child_node);\n\t\t\t\t\t}\n\t\t\t\t\tbubble_start = _bostree_rotate_right(tree, bubble_start);\n\t\t\t\t}\n\t\t\t\tbubble_start = bubble_start->parent_node;\n\t\t\t}\n\t\t}\n\n\t\t// Fixup candidate's depth\n\t\tcandidate->depth = _imax((candidate->left_child_node ? candidate->left_child_node->depth + 1 : 0),\n\t\t\t(candidate->right_child_node ? candidate->right_child_node->depth + 1 : 0));\n\n\t\t// We'll have to fixup child counts and depths up to the root, do that\n\t\t// later.\n\t\tbubble_up = candidate->parent_node;\n\n\t\t// Fix immediate parent node child count here.\n\t\tif(bubble_up) {\n\t\t\tif(bubble_up->left_child_node == candidate) {\n\t\t\t\tbubble_up->left_child_count--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbubble_up->right_child_count--;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// If this node has children on one side only, removing it is much simpler.\n\t\tif(!node->parent_node) {\n\t\t\t// Simple case: Node _was_ the old root.\n\t\t\tif(node->left_child_node) {\n\t\t\t\ttree->root_node = node->left_child_node;\n\t\t\t\tif(node->left_child_node) {\n\t\t\t\t\tnode->left_child_node->parent_node = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttree->root_node = node->right_child_node;\n\t\t\t\tif(node->right_child_node) {\n\t\t\t\t\tnode->right_child_node->parent_node = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No rebalancing to do\n\t\t\tbubble_up = NULL;\n\t\t}\n\t\telse {\n\t\t\tBOSNode *candidate = node->left_child_node;\n\t\t\tint candidate_count = node->left_child_count;\n\t\t\tif(node->right_child_node) {\n\t\t\t\tcandidate = node->right_child_node;\n\t\t\t\tcandidate_count = node->right_child_count;\n\t\t\t}\n\n\t\t\tif(node->parent_node->left_child_node == node) {\n\t\t\t\tnode->parent_node->left_child_node = candidate;\n\t\t\t\tnode->parent_node->left_child_count = candidate_count;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode->parent_node->right_child_node = candidate;\n\t\t\t\tnode->parent_node->right_child_count = candidate_count;\n\t\t\t}\n\n\t\t\tif(candidate) {\n\t\t\t\tcandidate->parent_node = node->parent_node;\n\t\t\t}\n\n\t\t\t// Again, from here on, the original node is out of the game.\n\t\t\t// Rebalance up to the root.\n\t\t\tbubble_up = node->parent_node;\n\t\t}\n\t}\n\n\t// At this point, everything below and including bubble_start is\n\t// balanced, and we have to look further up.\n\n\tchar bubbling_finished = 0;\n\twhile(bubble_up) {\n\t\tif(!bubbling_finished) {\n\t\t\t// Calculate updated depth for bubble_up\n\t\t\tunsigned int left_depth = bubble_up->left_child_node ? bubble_up->left_child_node->depth + 1 : 0;\n\t\t\tunsigned int right_depth = bubble_up->right_child_node ? bubble_up->right_child_node->depth + 1 : 0;\n\t\t\tunsigned int new_depth = _imax(left_depth, right_depth);\n\t\t\tchar depth_changed = (new_depth != bubble_up->depth);\n\t\t\tbubble_up->depth = new_depth;\n\n\t\t\t// Rebalance bubble_up\n\t\t\t// Not necessary for the first node, but calling _bostree_balance once\n\t\t\t// isn't that much overhead.\n\t\t\tint balance = _bostree_balance(bubble_up);\n\t\t\tif(balance < -1) {\n\t\t\t\tif(_bostree_balance(bubble_up->left_child_node) > 0) {\n\t\t\t\t\t_bostree_rotate_left(tree, bubble_up->left_child_node);\n\t\t\t\t}\n\t\t\t\tbubble_up = _bostree_rotate_right(tree, bubble_up);\n\t\t\t}\n\t\t\telse if(balance > 1) {\n\t\t\t\tif(_bostree_balance(bubble_up->right_child_node) < 0) {\n\t\t\t\t\t_bostree_rotate_right(tree, bubble_up->right_child_node);\n\t\t\t\t}\n\t\t\t\tbubble_up = _bostree_rotate_left(tree, bubble_up);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(!depth_changed) {\n\t\t\t\t\t// If we neither had to rotate nor to change the depth,\n\t\t\t\t\t// then we are obviously finished.  Only update child\n\t\t\t\t\t// counts from here on.\n\t\t\t\t\tbubbling_finished = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(bubble_up->parent_node) {\n\t\t\tif(bubble_up->parent_node->left_child_node == bubble_up) {\n\t\t\t\tbubble_up->parent_node->left_child_count--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbubble_up->parent_node->right_child_count--;\n\t\t\t}\n\t\t}\n\t\tbubble_up = bubble_up->parent_node;\n\t}\n\n\tnode->weak_ref_node_valid = 0;\n\tbostree_node_weak_unref(tree, node);\n}\n\nBOSNode *bostree_node_weak_ref(BOSNode *node) {\n\tassert(node->weak_ref_count < 127);\n\tassert(node->weak_ref_count > 0);\n\tnode->weak_ref_count++;\n\treturn node;\n}\n\nBOSNode *bostree_node_weak_unref(BOSTree *tree, BOSNode *node) {\n\tnode->weak_ref_count--;\n\tif(node->weak_ref_count == 0) {\n\t\tif(tree->free_function) {\n\t\t\ttree->free_function(node);\n\t\t}\n\t\tfree(node);\n\t}\n\telse if(node->weak_ref_node_valid) {\n\t\treturn node;\n\t}\n\treturn NULL;\n}\n\nBOSNode *bostree_lookup(BOSTree *tree, const void *key) {\n\tBOSNode *node = tree->root_node;\n\twhile(node) {\n\t\tint cmp = tree->cmp_function(key, node->key);\n\t\tif(cmp == 0) {\n\t\t\tbreak;\n\t\t}\n\t\telse if(cmp < 0) {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\t\telse {\n\t\t\tnode = node->right_child_node;\n\t\t}\n\t}\n\treturn node;\n}\n\nBOSNode *bostree_select(BOSTree *tree, unsigned int index) {\n\tBOSNode *node = tree->root_node;\n\twhile(node) {\n\t\tif(node->left_child_count <= index) {\n\t\t\tindex -= node->left_child_count;\n\t\t\tif(index == 0) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\tindex--;\n\t\t\tnode = node->right_child_node;\n\t\t}\n\t\telse {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\t}\n\treturn node;\n}\n\nBOSNode *bostree_next_node(BOSNode *node) {\n\tif(node->right_child_node) {\n\t\tnode = node->right_child_node;\n\t\twhile(node->left_child_node) {\n\t\t\tnode = node->left_child_node;\n\t\t}\n\t\treturn node;\n\t}\n\telse if(node->parent_node) {\n\t\twhile(node->parent_node && node->parent_node->right_child_node == node) {\n\t\t\tnode = node->parent_node;\n\t\t}\n\t\treturn node->parent_node;\n\t}\n\treturn NULL;\n}\n\nBOSNode *bostree_previous_node(BOSNode *node) {\n\tif(node->left_child_node) {\n\t\tnode = node->left_child_node;\n\t\twhile(node->right_child_node) {\n\t\t\tnode = node->right_child_node;\n\t\t}\n\t\treturn node;\n\t}\n\telse if(node->parent_node) {\n\t\twhile(node->parent_node && node->parent_node->left_child_node == node) {\n\t\t\tnode = node->parent_node;\n\t\t}\n\t\treturn node->parent_node;\n\t}\n\treturn NULL;\n}\n\nunsigned int bostree_rank(BOSNode *node) {\n\tunsigned int counter = node->left_child_count;\n\twhile(node) {\n\t\tif(node->parent_node && node->parent_node->right_child_node == node) counter += 1 + node->parent_node->left_child_count;\n\t\tnode = node->parent_node;\n\t}\n\treturn counter;\n}\n\n#if !defined(NDEBUG)\n#include <stdio.h>\n#include <unistd.h>\n\n/* Debug helpers:\n\n\tPrint the tree to stdout in dot format.\n*/\n\nstatic void _bostree_print_helper(BOSNode *node) {\n\tprintf(\"  %s [label=\\\"\\\\N (%d,%d,%d)\\\"];\\n\", (char *)node->key, node->left_child_count, node->right_child_count, node->depth);\n\tif(node->parent_node) {\n\t\tprintf(\"  %s -> %s [color=green];\\n\", (char *)node->key, (char *)node->parent_node->key);\n\t}\n\n\tif(node->left_child_node != NULL) {\n\t\tprintf(\"  %s -> %s\\n\", (char *)node->key, (char *)node->left_child_node->key);\n\t\t_bostree_print_helper(node->left_child_node);\n\t}\n\tif(node->right_child_node != NULL) {\n\t\tprintf(\"  %s -> %s\\n\", (char *)node->key, (char *)node->right_child_node->key);\n\t\t_bostree_print_helper(node->right_child_node);\n\t}\n}\n\nvoid bostree_print(BOSTree *tree) {\n\tif(tree->root_node == NULL) {\n\t\treturn;\n\t}\n\n\tprintf(\"digraph {\\n  ordering = out;\\n\");\n\t_bostree_print_helper(tree->root_node);\n\tprintf(\"}\\n\");\n\tfsync(0);\n}\n#endif\n```\n\n\nPlease extract the invariants from the code.\n"
}