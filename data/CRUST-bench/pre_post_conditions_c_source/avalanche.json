{
    "name": "avalanche",
    "avalanche.c": "/* avalanche.c\n */\n#include \"avalanche.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid avalanche(hash_f hash, FILE* ins, uint64_t max_iter, matrix_t* results)\n{\n    size_t key_size = results->n_rows / 8;\n    size_t hash_words = results->n_cols / 32;\n\n    char* key = malloc(key_size);\n    uint32_t* hvalue = malloc(4 * hash_words);\n    uint32_t* htemp = malloc(4 * hash_words);\n\n    uint64_t key_count = 0;\n    while (key_count < max_iter) {\n        size_t n_in = fread(key, 1, key_size, ins);\n        if (n_in < key_size)\n            break;\n\n        hash(key, key_size, hvalue);\n        ++key_count;\n\n        for (size_t i_byte = 0; i_byte < key_size; ++i_byte) {\n            for (size_t i_bit = 0; i_bit < 8; ++i_bit) {\n                size_t row = i_byte * 8 + i_bit;\n\n                // flip the i-th bit of this byte and re-hash\n                char i_mask = 0x80 >> i_bit;\n                key[i_byte] ^= i_mask;\n                hash(key, key_size, htemp);\n                key[i_byte] ^= i_mask;\n\n                for (size_t j_word = 0; j_word < hash_words; ++j_word) {\n                    for (size_t j_bit = 0; j_bit < 32; ++j_bit) {\n                        size_t col = j_word * 32 + j_bit;\n\n                        // test whether hvalue & htemp differ at j-th bit.\n                        uint32_t j_mask = 0x80000000 >> j_bit;\n                        if ((hvalue[j_word] ^ htemp[j_word]) & j_mask) {\n                            double curr = MATRIX_GET(results, row, col);\n                            MATRIX_SET(results, row, col, curr + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    free(key);\n    free(hvalue);\n    free(htemp);\n\n    if (key_count) {\n        // convert matrix entries to the mean values\n        size_t n_vals = results->n_cols * results->n_rows;\n        for (size_t k = 0; k < n_vals; ++k)\n            results->vals[k] /= key_count;\n    }\n}\n\nmatrix_t* matrix_alloc(size_t n_rows, size_t n_cols) {\n    matrix_t* M = malloc(sizeof(matrix_t));\n    M->n_rows = n_rows;\n    M->n_cols = n_cols;\n    M->vals = calloc(sizeof(double), n_cols * n_rows);\n    return M;\n}\n\nvoid matrix_free(matrix_t* M) {\n    if (M == NULL)\n        return;\n    free(M->vals);\n    free(M);\n    M = NULL;\n}\n\nvoid matrix_fprintf(FILE* fout, const char* format, const matrix_t* M) {\n    if (M == NULL)\n        return;\n\n    for (size_t r = 0; r < M->n_rows; ++r) {\n        for (size_t c = 0; c < M->n_cols; ++c) {\n            fprintf(fout, format, MATRIX_GET(M, r, c));\n        }\n        fprintf(fout, \"\\n\");\n    }\n}\n",
    "avalanche.h": "#ifndef AVALANCHE_H\n#define AVALANCHE_H\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/** Protypical hash function: converts a `key` of bytes to a hash value,\n represented as an array of 32-bit blocks.\n */\ntypedef void (* hash_f)(char* key, size_t key_len, uint32_t* hash_value);\n\n/** Simple matrix structure.\n */\ntypedef struct {\n    size_t n_rows, n_cols;\n    double* vals;\n} matrix_t;\n\n// macros for enforcing row-major layout of matrix\n#define MATRIX_GET(M, ROW, COL) ((M)->vals[(ROW) * (M)->n_cols + (COL)])\n#define MATRIX_SET(M, ROW, COL, VAL) ((M)->vals[(ROW) * (M)->n_cols + (COL)] = (VAL))\n\n/** Avalanche test for hash function.\n\n All test keys are read successively from the stream `ins`, and the probability\n that flipping i-th input bit affects the j-th output bit is recorded as the\n ij-th entry of the matrix.\n\n All keys read have the same length, so that the key length and size of the\n hash value (in words) are parameterized by the row and columns of the mattrix.\n */\nvoid avalanche(hash_f hash, FILE* ins, uint64_t max_iter, matrix_t* results);\n\nmatrix_t* matrix_alloc(size_t n_rows, size_t n_cols);\nvoid matrix_free(matrix_t*);\nvoid matrix_fprintf(FILE* fout, const char* format, const matrix_t*);\n\n#endif // AVALANCHE_H\n",
    "c": "",
    "c_pre_post_conditions": "// Function: avalanche\n// Pre-condition:\n//   - hash        != NULL\n//   - ins         != NULL and opened for reading\n//   - results     != NULL\n//   - results->n_rows % 8   == 0   (so key_size = results->n_rows/8 is integral)\n//   - results->n_cols % 32  == 0   (so hash_words = results->n_cols/32 is integral)\n//   - results->vals points to at least results->n_rows * results->n_cols doubles\n//   - results->vals is zero\u2010initialized (so that counts accumulate correctly)\n//   - max_iter   \u2265 0\n// Post-condition:\n//   - Internally allocated buffers (key, hvalue, htemp) are freed.\n//   - Let K = number of full keys actually read (0 \u2264 K \u2264 max_iter).\n//   - If K > 0, then for every 0 \u2264 r < results->n_rows and 0 \u2264 c < results->n_cols,\n//       results->vals[r * results->n_cols + c]\n//         =  (1.0 / K) * (# of times flipping input bit r changed output bit c).\n//     Hence each entry is in [0,1] and represents the empirical probability.\n//   - If K == 0, results->vals remains all zero.\n//   - No other side effects (input FILE* and hash function state are untouched).\n\n// Function: matrix_alloc\n// Pre-condition:\n//   - n_rows * n_cols does not overflow size_t\n// Post-condition:\n//   - Returns a non-NULL pointer M such that\n//       M->n_rows == n_rows\n//       M->n_cols == n_cols\n//       M->vals is a newly allocated array of n_rows*n_cols doubles,\n//         each initialized to 0.0.\n\n// Function: matrix_free\n// Pre-condition:\n//   - M == NULL, or M was previously returned by matrix_alloc\n// Post-condition:\n//   - If M != NULL, then M->vals has been freed and M itself has been freed.\n//   - It is safe to call matrix_free(NULL) (no action taken).\n\n// Function: matrix_fprintf\n// Pre-condition:\n//   - fout   != NULL and open for writing\n//   - format != NULL and describes how to print a double\n//   - M == NULL, or M was previously returned by matrix_alloc\n// Post-condition:\n//   - If M != NULL, writes M->n_rows lines to fout;\n//       each line contains M->n_cols values\n//       by calling fprintf(fout, format, M->vals[r*M->n_cols + c]) in row-major order,\n//       followed by a newline.\n//   - If M == NULL, no output is produced.\n//   - M and its contents are not modified.",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\n// Function: function_name\n// Pre-condition: description of the pre-condition\n// Post-condition: description of the post-condition\n```\n\nHere is the code:\n{{avalanche.c}}\n```c\n// header file\n/*#ifndef AVALANCHE_H\n#define AVALANCHE_H\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/** Protypical hash function: converts a `key` of bytes to a hash value,\n represented as an array of 32-bit blocks.\n */\ntypedef void (* hash_f)(char* key, size_t key_len, uint32_t* hash_value);\n\n/** Simple matrix structure.\n */\ntypedef struct {\n    size_t n_rows, n_cols;\n    double* vals;\n} matrix_t;\n\n// macros for enforcing row-major layout of matrix\n#define MATRIX_GET(M, ROW, COL) ((M)->vals[(ROW) * (M)->n_cols + (COL)])\n#define MATRIX_SET(M, ROW, COL, VAL) ((M)->vals[(ROW) * (M)->n_cols + (COL)] = (VAL))\n\n/** Avalanche test for hash function.\n\n All test keys are read successively from the stream `ins`, and the probability\n that flipping i-th input bit affects the j-th output bit is recorded as the\n ij-th entry of the matrix.\n\n All keys read have the same length, so that the key length and size of the\n hash value (in words) are parameterized by the row and columns of the mattrix.\n */\nvoid avalanche(hash_f hash, FILE* ins, uint64_t max_iter, matrix_t* results);\n\nmatrix_t* matrix_alloc(size_t n_rows, size_t n_cols);\nvoid matrix_free(matrix_t*);\nvoid matrix_fprintf(FILE* fout, const char* format, const matrix_t*);\n\n#endif // AVALANCHE_H\n*/\n/* avalanche.c\n */\n#include \"avalanche.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid avalanche(hash_f hash, FILE* ins, uint64_t max_iter, matrix_t* results)\n{\n    size_t key_size = results->n_rows / 8;\n    size_t hash_words = results->n_cols / 32;\n\n    char* key = malloc(key_size);\n    uint32_t* hvalue = malloc(4 * hash_words);\n    uint32_t* htemp = malloc(4 * hash_words);\n\n    uint64_t key_count = 0;\n    while (key_count < max_iter) {\n        size_t n_in = fread(key, 1, key_size, ins);\n        if (n_in < key_size)\n            break;\n\n        hash(key, key_size, hvalue);\n        ++key_count;\n\n        for (size_t i_byte = 0; i_byte < key_size; ++i_byte) {\n            for (size_t i_bit = 0; i_bit < 8; ++i_bit) {\n                size_t row = i_byte * 8 + i_bit;\n\n                // flip the i-th bit of this byte and re-hash\n                char i_mask = 0x80 >> i_bit;\n                key[i_byte] ^= i_mask;\n                hash(key, key_size, htemp);\n                key[i_byte] ^= i_mask;\n\n                for (size_t j_word = 0; j_word < hash_words; ++j_word) {\n                    for (size_t j_bit = 0; j_bit < 32; ++j_bit) {\n                        size_t col = j_word * 32 + j_bit;\n\n                        // test whether hvalue & htemp differ at j-th bit.\n                        uint32_t j_mask = 0x80000000 >> j_bit;\n                        if ((hvalue[j_word] ^ htemp[j_word]) & j_mask) {\n                            double curr = MATRIX_GET(results, row, col);\n                            MATRIX_SET(results, row, col, curr + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    free(key);\n    free(hvalue);\n    free(htemp);\n\n    if (key_count) {\n        // convert matrix entries to the mean values\n        size_t n_vals = results->n_cols * results->n_rows;\n        for (size_t k = 0; k < n_vals; ++k)\n            results->vals[k] /= key_count;\n    }\n}\n\nmatrix_t* matrix_alloc(size_t n_rows, size_t n_cols) {\n    matrix_t* M = malloc(sizeof(matrix_t));\n    M->n_rows = n_rows;\n    M->n_cols = n_cols;\n    M->vals = calloc(sizeof(double), n_cols * n_rows);\n    return M;\n}\n\nvoid matrix_free(matrix_t* M) {\n    if (M == NULL)\n        return;\n    free(M->vals);\n    free(M);\n    M = NULL;\n}\n\nvoid matrix_fprintf(FILE* fout, const char* format, const matrix_t* M) {\n    if (M == NULL)\n        return;\n\n    for (size_t r = 0; r < M->n_rows; ++r) {\n        for (size_t c = 0; c < M->n_cols; ++c) {\n            fprintf(fout, format, MATRIX_GET(M, r, c));\n        }\n        fprintf(fout, \"\\n\");\n    }\n}\n```\n\n\nPlease extract the invariants from the code.\n"
}