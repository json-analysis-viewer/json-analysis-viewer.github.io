{
    "name": "bigint",
    "bigint.h": "/*\n * Adam's Big Integer Library\n * Version 1.0\n */\n#ifndef bigint_H\n#define bigint_H\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\ntypedef struct {\n    bool is_negative;\n    int64_t *digits;\n    size_t size;\n} bigint;\n\nvoid bigint_delete(bigint n);\n\nbigint bigint_zero() {\n    bigint result;\n    result.is_negative = false;\n    result.size = 1;\n    result.digits = malloc(sizeof(int64_t));\n    result.digits[0] = 0;\n    return result;\n}\n\nvoid bigint_print(bigint n);\n\nbool bigint_is_64_bit(bigint n) {\n    if (n.is_negative) {\n        if (n.size > 10) {\n            return false;\n        }\n        if (n.size < 10) {\n            return true;\n        }\n    } else {\n        if (n.size > 10) {\n            return false;\n        }\n        if (n.size < 10) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid bigint_remove_leading_zeros(bigint *n) {\n    size_t leading_zeros = 0;\n    for (size_t i = 0; i < n->size; i++) {\n        if (n->digits[i] == 0) {\n            leading_zeros++;\n        } else {\n            break;\n        }\n    }\n\n    // If there are leading zeros, memmove the digits\n    if (leading_zeros > 0) {\n        if (leading_zeros >= n->size) {\n            n->size = 1;\n            n->digits[0] = 0;\n            return;\n        }\n        n->size -= leading_zeros;\n        memmove(n->digits, n->digits + leading_zeros, n->size * sizeof(int64_t));\n    }\n}\n\nbigint bigint_from_int(int64_t n) {\n    bigint result;\n    if (n < 0) {\n        result.is_negative = true;\n        n = -n;\n    } else {\n        result.is_negative = false;\n    }\n    result.size = 1;\n    int64_t m = n;\n    while (m > 0) {\n        m /= 10;\n        result.size++;\n    }\n    result.digits = malloc(result.size * sizeof(int64_t));\n    m = n;\n    for (size_t i = 0; i < result.size; i++) {\n        result.digits[result.size - i - 1] = m % 10;\n        m /= 10;\n    }\n    bigint_remove_leading_zeros(&result);\n    return result;\n}\n\nint64_t bigint_to_int(bigint n) {\n    int64_t result = 0;\n    for (size_t i = 0; i < n.size; i++) {\n        result *= 10;\n        result += n.digits[i];\n    }\n    if (n.is_negative) {\n        result = -result;\n    }\n    return result;\n}\n\n/* Create a new bigint from an integer \n* @param n The integer to create a bigint from\n* @return A new bigint with the value of n\n*/\nbigint bigint_from_string(const char *n) {\n    bigint result;\n    \n    // Determine if the number is negative\n    if (n[0] == '-') {\n        result.is_negative = true;\n        n++;\n    } else {\n        result.is_negative = false;\n    }\n\n    // Determine the size of the number\n    result.size = strlen(n);\n\n    // Allocate memory for the digits\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n    // Copy the digits into the bigint\n    for (size_t i = 0; i < result.size; i++) {\n        result.digits[i] = n[i] - '0';\n    }\n    \n    return result;\n}\n\n\nbigint bigint_copy(bigint n) {\n    bigint result;\n    result.is_negative = n.is_negative;\n    result.size = n.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    memcpy(result.digits, n.digits, result.size * sizeof(int64_t));\n    return result;\n}\n\n/* Print a bigint\n* @param n The bigint to print\n*/\nvoid bigint_print(bigint n) {\n    if (n.is_negative) {\n        printf(\"-\");\n    }\n    for (size_t i = 0; i < n.size; i++) {\n        assert(n.digits[i] >= 0 && n.digits[i] <= 9);\n        printf(\"%lld\", n.digits[i]);\n    }\n}\n\n\nbool bigint_gt(bigint a, bigint b) {\n    bigint_remove_leading_zeros(&a);\n    bigint_remove_leading_zeros(&b);\n    if (a.size > b.size) {\n        return !a.is_negative;\n    }\n    if (a.size < b.size) {\n        return a.is_negative;\n    }\n    for (size_t i = 0; i < a.size; i++) {\n        if (a.digits[i] > b.digits[i]) {\n            return !a.is_negative;\n        }\n        if (a.digits[i] < b.digits[i]) {\n            return a.is_negative;\n        }\n    }\n    return false;\n}\n\nbool bigint_eq(bigint a, bigint b) {\n    bigint_remove_leading_zeros(&a);\n    bigint_remove_leading_zeros(&b);\n    if (a.size != b.size) {\n        return false;\n    }\n    if (a.is_negative != b.is_negative) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size; i++) {\n        if (a.digits[i] != b.digits[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool bigint_eqzero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return true;\n    }\n    return false;\n}\n\nbool bigint_ltzero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return false;\n    }\n    return n.is_negative;\n}\nbool bigint_gtzero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return false;\n    }\n    return !n.is_negative;\n}\n\nbool bigint_lezero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return true;\n    }\n    return n.is_negative;\n}\n\nbool bigint_gezero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return true;\n    }\n    return !n.is_negative;\n}\n\nbigint bigint_abs(bigint n) {\n    n.is_negative = false;\n    return n;\n}\n\nbool bigint_ge(bigint a, bigint b) {\n    return bigint_gt(a, b) || bigint_eq(a, b);\n}\n\nbool bigint_lt(bigint a, bigint b) {\n    return !bigint_ge(a, b);\n}\n\nbool bigint_le(bigint a, bigint b) {\n    return !bigint_gt(a, b);\n}\n\n\nbigint bigint_add(bigint a, bigint b);\n\n/* Subtract two bigints\n* @param a The first bigint\n* @param b The second bigint\n* @return The difference of a and b\n*/\nbigint bigint_sub(bigint a, bigint b) {\n    bigint result;\n    if (a.is_negative && b.is_negative) {\n        a.is_negative = false;\n        b.is_negative = false;\n        result = bigint_add(b, a);\n        result.is_negative = true;\n        return result;\n    }\n    \n    if (a.is_negative) {\n        // -a - b = -(a + b)\n        b.is_negative = true;\n        result = bigint_add(a, b);\n        return result;\n    }\n\n    if (b.is_negative) {\n        // a - (-b) = a + b\n        b.is_negative = false;\n        result = bigint_add(a, b);\n        return result;\n    }\n\n    result.size = a.size > b.size ? a.size : b.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n    bool is_negative = bigint_lt(a, b);\n\n\n    // Subtract the digits\n    int64_t carry = 0;\n    bigint larger = bigint_gt(a, b) ? a : b;\n    bigint smaller = bigint_gt(a, b) ? b : a;\n\n    for (size_t i = 0; i < result.size; i++) {\n        int64_t diff = carry;\n        if (i < larger.size) {\n            diff += larger.digits[larger.size - i - 1];\n        }\n        if (i < smaller.size) {\n            diff -= smaller.digits[smaller.size - i - 1];\n        }\n        if (diff < 0) {\n            diff += 10;\n            carry = -1;\n        } else {\n            carry = 0;\n        }\n        result.digits[result.size - i - 1] = diff;\n    }\n    \n    bigint_remove_leading_zeros(&result);\n\n    result.is_negative = is_negative;\n\n    return result;\n}\n\n/* Add two bigints\n* @param a The first bigint\n* @param b The second bigint\n* @return The sum of a and b\n*/\nbigint bigint_add(bigint a, bigint b) {\n    bigint result;\n    if (a.is_negative && b.is_negative) {\n        result.is_negative = true;\n    } else if (a.is_negative) {\n        a.is_negative = false;\n        result = bigint_sub(b, a);\n        return result;\n    } else if (b.is_negative) {\n        b.is_negative = false;\n        result = bigint_sub(a, b);\n        return result;\n    } else {\n        result.is_negative = false;\n    }\n    result.size = a.size > b.size ? a.size : b.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n\n    \n    // Add the digits\n    int64_t carry = 0;\n    for (size_t i = 0; i < result.size; i++) {\n        int64_t sum = carry;\n        if (i < a.size) {\n            sum += a.digits[a.size - i - 1];\n        }\n        if (i < b.size) {\n            sum += b.digits[b.size - i - 1];\n        }\n        result.digits[result.size - i - 1] = sum % 10;\n        carry = sum / 10;\n    }\n    \n    // If there is a carry, add another digit\n    if (carry > 0) {\n        result.size++;\n        result.digits = realloc(result.digits, result.size * sizeof(int64_t));\n        for (size_t i = result.size - 1; i > 0; i--) {\n            result.digits[i] = result.digits[i - 1];\n        }\n        result.digits[0] = carry;\n    }\n    bigint_remove_leading_zeros(&result);\n    \n    return result;\n}\n\n\nbigint bigint_inc(bigint *n) {\n    bigint one = bigint_from_string(\"1\"), tmp;\n    tmp = *n;\n    *n = bigint_add(*n, one);\n    bigint_delete(tmp);\n    bigint_delete(one);\n    return *n;\n}\n\nbigint bigint_dec(bigint *n) {\n    bigint one = bigint_from_string(\"1\"), tmp;\n    tmp = *n;\n    *n = bigint_sub(*n, one);\n    bigint_delete(tmp);\n    bigint_delete(one);\n    return *n;\n}\n\nbigint bigint_mul(bigint a, bigint b) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b)) {\n        return bigint_from_int(bigint_to_int(a) * bigint_to_int(b));\n    }\n\n\n    bigint result;\n    result.size = a.size + b.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n    // Multiply the digits\n    for (size_t i = 0; i < result.size; i++) {\n        result.digits[i] = 0;\n    }\n    for (size_t i = 0; i < a.size; i++) {\n        for (size_t j = 0; j < b.size; j++) {\n            result.digits[result.size - i - j - 1] += a.digits[a.size - i - 1] * b.digits[b.size - j - 1];\n        }\n    }\n\n    // Normalize the result\n    int64_t carry = 0;\n    for (size_t i = 0; i < result.size; i++) {\n        int64_t sum = result.digits[result.size - i - 1] + carry;\n        result.digits[result.size - i - 1] = sum % 10;\n        carry = sum / 10;\n    }\n\n    // If there is a carry, add another digit\n    if (carry > 0) {\n        result.size++;\n        result.digits = realloc(result.digits, result.size * sizeof(int64_t));\n        for (size_t i = result.size - 1; i > 0; i--) {\n            result.digits[i] = result.digits[i - 1];\n        }\n        result.digits[0] = carry;\n    }\n    \n    bigint_remove_leading_zeros(&result);\n    \n    // Check negative\n    result.is_negative = a.is_negative != b.is_negative;\n    \n    return result;\n}\n\n\nbigint bigint_divmod(bigint numerator, bigint denominator, bigint *remainder) {\n    if (bigint_is_64_bit(numerator) && bigint_is_64_bit(denominator)) {\n        int64_t quotient = bigint_to_int(numerator) / bigint_to_int(denominator);\n        int64_t rem = bigint_to_int(numerator) % bigint_to_int(denominator);\n        *remainder = bigint_from_int(rem);\n        return bigint_from_int(quotient);\n    }\n\n    bigint quotient = bigint_from_string(\"0\");\n    \n    bool negative = numerator.is_negative != denominator.is_negative;\n    numerator.is_negative = false;\n    denominator.is_negative = false;\n    \n    bigint tmp1, tmp2;\n    numerator = bigint_copy(numerator);\n\n    // Divide the numerator by the denominator\n    // This is a very slow algorithm\n    // It works by subtracting the denominator from the numerator until the numerator is less than the denominator\n    // The number of times the denominator is subtracted is the quotient\n    // The remainder is the numerator after the last subtraction\n    while (bigint_gtzero(numerator)) {\n        tmp1 = numerator;\n        numerator = bigint_sub(numerator, denominator);\n        bigint_delete(tmp1);\n        if (bigint_ltzero(numerator)) {\n            break;\n        }\n        bigint_inc(&quotient);\n    }\n    if (bigint_ltzero(numerator)) {\n        tmp1 = numerator;\n        numerator = bigint_add(numerator, denominator);\n        bigint_delete(tmp1);\n    }\n\n    // Set the remainder\n    *remainder = numerator;\n\n    bigint_remove_leading_zeros(&quotient);\n\n    if (negative) {\n        quotient.is_negative = true;\n        remainder->is_negative = true;\n    }\n\n    return quotient;\n}\n\nbigint bigint_div(bigint a, bigint b) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b)) {\n        return bigint_from_int(bigint_to_int(a) / bigint_to_int(b));\n    }\n\n    bigint remainder;\n    bigint result = bigint_divmod(a, b, &remainder);\n    bigint_delete(remainder);\n    return result;\n}\n\nbigint bigint_mod(bigint a, bigint b) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b)) {\n        bigint result = bigint_from_int(bigint_to_int(a) % bigint_to_int(b));\n        // printf(\"Computing %lld %% %lld = %lld\\n\", bigint_to_int(a), bigint_to_int(b), bigint_to_int(result));\n        return result;\n    }\n\n    bigint remainder;\n    bigint_delete(bigint_divmod(a, b, &remainder));\n    return remainder;\n}\n\nbigint bigint_pow(bigint a, bigint b) {\n    bigint result, tmp;\n    if (b.is_negative) {\n        result = bigint_from_string(\"0\");\n        return result;\n    }\n    result = bigint_from_string(\"1\");\n    if (bigint_eqzero(b)) {\n        return result;\n    }\n    b = bigint_copy(b);\n    while (!bigint_eqzero(b)) {\n        tmp = result;\n        result = bigint_mul(result, a);\n        bigint_delete(tmp);\n        bigint_dec(&b);\n    }\n    bigint_delete(b);\n    return result;\n}\n\nbool bigint_is_odd(bigint n);\nbool bigint_is_even(bigint n);\n\nbigint bigint_fast_pow(bigint a, bigint b, bigint m) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b) && bigint_is_64_bit(m)) {\n        int64_t result = 1;\n        int64_t base = bigint_to_int(a);\n        int64_t exp = bigint_to_int(b);\n        int64_t mod = bigint_to_int(m);\n        base %= mod;\n        while (exp > 0) {\n            if (exp % 2 == 1) {\n                result = (result * base) % mod;\n            }\n            exp = exp >> 1;\n            base = (base * base) % mod;\n        }\n        return bigint_from_int(result);\n    }\n    \n    bigint result;\n\n    if (b.is_negative) {\n        result = bigint_from_string(\"0\");\n        return result;\n    }\n    if (bigint_eqzero(b)) {\n        result = bigint_from_string(\"1\");\n        return result;\n    }\n\n    bigint tmp1, tmp2;\n    // printf(\"Computing %lld ^ %lld mod %lld\\n\", bigint_to_int(a), bigint_to_int(b), bigint_to_int(m));\n    b = bigint_copy(b);\n    a = bigint_mod(a, m);\n    result = bigint_copy(a);\n    bigint b_save = bigint_copy(b);\n    bigint_dec(&b);\n\n    bigint pow = bigint_from_string(\"1\");\n    while (true) {\n        tmp1 = bigint_from_string(\"2\");\n        tmp2 = bigint_div(b, tmp1);\n        bigint_delete(tmp1);\n        if (!bigint_gtzero(tmp2)) {\n            bigint_delete(tmp2);\n            break;\n        }\n        bigint_delete(tmp2);\n\n        tmp1 = bigint_mul(result, result);\n        tmp2 = result;\n        result = bigint_mod(tmp1, m);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        // Halve b\n        tmp1 = b;\n        tmp2 = bigint_from_string(\"2\");\n        \n        b = bigint_div(b, tmp2);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        \n        tmp1 = pow;\n        pow = bigint_add(pow, pow);\n        bigint_delete(tmp1);\n    }\n    \n    tmp1 = b_save;\n    b_save = bigint_sub(b_save, pow);\n    bigint_delete(tmp1);\n\n    if (bigint_is_odd(b_save)) {\n        tmp1 = result;\n        tmp2 = bigint_mul(result, a);\n        result = bigint_mod(tmp2, m);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        bigint_dec(&b_save);\n        bigint_inc(&pow);\n    }\n\n    if (bigint_lt(b_save, bigint_from_int(5))) {\n        while (!bigint_eqzero(b_save)) {\n            tmp1 = result;\n            tmp2 = bigint_mul(result, a);\n            result = bigint_mod(tmp2, m);\n            bigint_delete(tmp1);\n            bigint_delete(tmp2);\n            bigint_dec(&b_save);\n            bigint_inc(&pow);\n        }\n\n        bigint_delete(b_save);\n        bigint_delete(pow);\n\n        return result;\n    }\n\n    // Do the same halving powers for the subpart\n    bigint subpart = bigint_fast_pow(a, b_save, m);\n\n    tmp1 = result;\n    tmp2 = subpart;\n    result = bigint_mul(result, subpart);\n    bigint_delete(tmp1);\n    bigint_delete(tmp2);\n\n    tmp1 = result;\n    result = bigint_mod(result, m);\n    bigint_delete(tmp1);\n\n    bigint_delete(b_save);\n    bigint_delete(pow);\n    \n    return result;\n}\n\nbigint bigint_modinv(bigint a, bigint m) {\n    bigint m0 = bigint_copy(m);\n    bigint y = bigint_from_string(\"0\");\n    bigint x = bigint_from_string(\"1\");\n    bigint q = bigint_from_string(\"0\");\n    bigint t = bigint_from_string(\"0\");\n    bigint temp = bigint_from_string(\"0\");\n    bigint one = bigint_from_string(\"1\");\n    a = bigint_copy(a);\n    m = bigint_copy(m);\n\n    bigint tmp1, tmp2;\n    while (!bigint_eqzero(a)) {\n        tmp1 = q;\n        q = bigint_div(m, a);\n        bigint_delete(tmp1);\n\n        tmp1 = t;\n        tmp2 = bigint_mul(q, a);\n        t = bigint_sub(m, tmp2);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        tmp1 = m, tmp2 = a;\n        m = bigint_copy(a);\n        a = bigint_copy(t);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        tmp1 = t;\n        tmp2 = bigint_mul(q, x);\n        t = bigint_sub(y, tmp2);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        tmp1 = y, tmp2 = x;\n        y = bigint_copy(x);\n        x = bigint_copy(t);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n    }\n    if (bigint_ltzero(m)) {\n        tmp1 = m;\n        m = bigint_add(m, m0);\n        bigint_delete(tmp1);\n    }\n\n    if (bigint_eq(m, one)) {\n        bigint result = bigint_mod(y, m0);\n        if (bigint_ltzero(result)) {\n            tmp1 = result;\n            result = bigint_add(result, m0);\n            bigint_delete(tmp1);\n        }\n        bigint_delete(a);\n        bigint_delete(m);\n        bigint_delete(m0);\n        bigint_delete(y);\n        bigint_delete(x);\n        bigint_delete(q);\n        bigint_delete(t);\n        bigint_delete(temp);\n        bigint_delete(one);\n        return result;\n    }\n    bigint_delete(a);\n    bigint_delete(m);\n    bigint_delete(m0);\n    bigint_delete(y);\n    bigint_delete(x);\n    bigint_delete(q);\n    bigint_delete(t);\n    bigint_delete(temp);\n    bigint_delete(one);\n    return bigint_from_int(0);\n}\n\nbigint bigint_sqrt(bigint n) {\n    bigint one = bigint_from_string(\"1\");\n    bigint two = bigint_from_string(\"2\");\n    bigint low = bigint_from_string(\"0\");\n    bigint high = bigint_copy(n);\n    bigint mid = bigint_from_string(\"0\");\n    while (bigint_lt(low, high)) {\n        bigint tmp1 = bigint_add(low, high);\n        bigint tmp2 = mid;\n        mid = bigint_div(tmp1, two);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        tmp1 = bigint_mul(mid, mid);\n        if (bigint_lt(tmp1, n)) {\n            tmp2 = low;\n            low = bigint_add(mid, one);\n            bigint_delete(tmp2);\n        } else {\n            tmp2 = high;\n            high = bigint_copy(mid);\n            bigint_delete(tmp2);\n        }\n        bigint_delete(tmp1);\n    }\n\n    bigint_delete(one);\n    bigint_delete(two);\n    bigint_delete(mid);\n    bigint_delete(high);\n\n    return low;\n}\n\nbool bigint_is_even(bigint n) {\n    return n.digits[n.size - 1] % 2 == 0;\n}\n\nbool bigint_is_odd(bigint n) {\n    return n.digits[n.size - 1] % 2 == 1;\n}\n\nbool bigint_is_prime(bigint n) {\n    bigint tmp1, tmp2;\n    // Check if the number is even\n    if (bigint_is_even(n)) {\n        return false;\n    }\n\n    // If the last digit is a 5 or 0, the number is divisible by 5\n    if (n.size > 1 && (n.digits[n.size - 1] == 5 || n.digits[n.size - 1] == 0)) {\n        return false;\n    }\n    // Check if the sum of the digits is divisible by 3\n    bigint sum = bigint_from_string(\"0\");\n    for (size_t i = 0; i < n.size; i++) {\n        tmp1 = bigint_from_int(n.digits[i]);\n        tmp2 = sum;\n        sum = bigint_add(sum, tmp1);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n    }\n\n    tmp1 = bigint_from_string(\"3\");\n    tmp2 = bigint_mod(sum, tmp1);\n    if (bigint_eqzero(tmp2)) {\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        bigint_delete(sum);\n        return false;\n    }\n    bigint_delete(tmp1);\n    bigint_delete(tmp2);\n    bigint_delete(sum);\n\n    bigint sqrt_n = bigint_sqrt(n);\n    \n    for (tmp1 = bigint_from_string(\"2\"); bigint_le(tmp1, sqrt_n); bigint_inc(&tmp1)) {\n        tmp2 = bigint_mod(n, tmp1);\n        if (bigint_eqzero(tmp2)) {\n            bigint_delete(tmp1);\n            bigint_delete(tmp2);\n            bigint_delete(sqrt_n);\n            return false;\n        }\n        bigint_delete(tmp2);\n    }\n    bigint_delete(tmp1);\n    bigint_delete(sqrt_n);\n    return true;\n}\n\n/* Delete a bigint\n* @param n The bigint to delete\n*/\n#include <execinfo.h>\nvoid bigint_delete(bigint n) {\n    free(n.digits);\n    n.digits = NULL;\n    n.is_negative = false;\n    n.size = 0;\n}\n\n#endif",
    "c": "",
    "c_pre_post_conditions": "Function: bigint_zero\nPre-condition:\n    \u2013 none\nPost-condition:\n    Returns a bigint result such that\n      \u2022 result.is_negative == false\n      \u2022 result.size == 1\n      \u2022 result.digits points to a heap array of length 1\n      \u2022 result.digits[0] == 0\n\nFunction: bigint_print\nPre-condition:\n    \u2022 n.digits != NULL\n    \u2022 n.size \u2265 1\n    \u2022 \u2200 i < n.size: 0 \u2264 n.digits[i] \u2264 9\nPost-condition:\n    \u2022 The decimal representation of n is written to stdout,\n      prefixed by \u201c-\u201d if n.is_negative is true.\n    \u2022 n is not modified.\n\nFunction: bigint_is_64_bit\nPre-condition:\n    \u2022 n.digits != NULL\n    \u2022 n.size \u2265 1\nPost-condition:\n    Returns true iff the magnitude of n fits in fewer than 10 decimal digits (n.size < 10).\n\nFunction: bigint_remove_leading_zeros\nPre-condition:\n    \u2022 n != NULL\n    \u2022 n->digits points to an array of length n->size\n    \u2022 n->size \u2265 1\n    \u2022 \u2200 i < n->size: 0 \u2264 n->digits[i] \u2264 9\nPost-condition:\n    \u2022 All leading zeros are removed:\n        \u2013 If the entire number was zero, then n->size == 1 and n->digits[0] == 0.\n        \u2013 Otherwise n->digits[0] \u2260 0.\n    \u2022 n->digits still points to the same buffer (contents shifted if needed).\n    \u2022 n->size updated to reflect the new length (\u22651).\n\nFunction: bigint_from_int\nPre-condition:\n    \u2013 none\nPost-condition:\n    Returns result such that\n      \u2022 result.is_negative == (input < 0)\n      \u2022 result represents |input| in base 10 with no leading zeros\n      \u2022 result.size \u2265 1, result.digits[i] in [0,9]\n      \u2022 if input==0, then result.size==1 and result.digits[0]==0\n\nFunction: bigint_to_int\nPre-condition:\n    \u2022 n.digits != NULL\n    \u2022 n.size \u2265 1\n    \u2022 \u2200 i < n.size: 0 \u2264 n.digits[i] \u2264 9\n    \u2022 The numeric value of n fits in int64_t\nPost-condition:\n    Returns the int64_t value of n (negated if n.is_negative).\n\nFunction: bigint_from_string\nPre-condition:\n    \u2022 n is a null-terminated C-string\n    \u2022 After an optional leading '-', all characters are '0'..'9'\nPost-condition:\n    Returns result such that\n      \u2022 result.is_negative == (input string started with '-')\n      \u2022 result.size == length of digit characters\n      \u2022 result.digits[i] == input_digit[i] \u2013 '0'\n      \u2022 leading zeros are preserved (no trimming)\n\nFunction: bigint_copy\nPre-condition:\n    \u2022 n.digits != NULL\n    \u2022 n.size \u2265 1\nPost-condition:\n    Returns a deep copy result with\n      \u2022 result.is_negative == n.is_negative\n      \u2022 result.size == n.size\n      \u2022 result.digits is a distinct heap buffer containing the same digits\n\nFunction: bigint_gt\nPre-condition:\n    \u2022 a.digits, b.digits valid and sized\nPost-condition:\n    Returns true iff numeric value(a) > numeric value(b)\n\nFunction: bigint_eq\nPre-condition:\n    \u2022 a.digits, b.digits valid and sized\nPost-condition:\n    Returns true iff numeric value(a) == numeric value(b)\n\nFunction: bigint_eqzero\nPre-condition:\n    \u2022 n.digits valid\nPost-condition:\n    Returns true iff numeric value(n) == 0\n\nFunction: bigint_ltzero\nPre-condition:\n    \u2022 n.digits valid\nPost-condition:\n    Returns true iff numeric value(n) < 0\n\nFunction: bigint_gtzero\nPre-condition:\n    \u2022 n.digits valid\nPost-condition:\n    Returns true iff numeric value(n) > 0\n\nFunction: bigint_lezero\nPre-condition:\n    \u2022 n.digits valid\nPost-condition:\n    Returns true iff numeric value(n) \u2264 0\n\nFunction: bigint_gezero\nPre-condition:\n    \u2022 n.digits valid\nPost-condition:\n    Returns true iff numeric value(n) \u2265 0\n\nFunction: bigint_abs\nPre-condition:\n    \u2022 n.digits valid\nPost-condition:\n    Returns a bigint equal in magnitude to n but with is_negative == false\n\nFunction: bigint_ge\nPre-condition:\n    \u2022 a, b are valid bigints\nPost-condition:\n    Returns true iff a \u2265 b\n\nFunction: bigint_lt\nPre-condition:\n    \u2022 a, b are valid bigints\nPost-condition:\n    Returns true iff a < b\n\nFunction: bigint_le\nPre-condition:\n    \u2022 a, b are valid bigints\nPost-condition:\n    Returns true iff a \u2264 b\n\nFunction: bigint_sub\nPre-condition:\n    \u2022 a.digits, b.digits valid\nPost-condition:\n    Returns result = a \u2013 b (exact subtraction)\n      \u2022 result.digits describe |a\u2212b| in base 10, no leading zeros\n      \u2022 result.is_negative matches the sign of (a \u2212 b)\n      \u2022 result.size \u2265 1, digits in [0,9]\n\nFunction: bigint_add\nPre-condition:\n    \u2022 a.digits, b.digits valid\nPost-condition:\n    Returns result = a + b (exact addition)\n      \u2022 result.digits describe |a+b| in base 10, no leading zeros\n      \u2022 result.is_negative matches the sign of (a + b)\n      \u2022 result.size \u2265 1, digits in [0,9]\n\nFunction: bigint_inc\nPre-condition:\n    \u2022 n points to a valid bigint\nPost-condition:\n    \u2022 *n is incremented by 1 exactly\n    \u2022 Returned value equals the new *n\n\nFunction: bigint_dec\nPre-condition:\n    \u2022 n points to a valid bigint\nPost-condition:\n    \u2022 *n is decremented by 1 exactly\n    \u2022 Returned value equals the new *n\n\nFunction: bigint_mul\nPre-condition:\n    \u2022 a.digits, b.digits valid\nPost-condition:\n    Returns result = a * b (exact multiplication)\n      \u2022 result.digits describe |a\u00b7b| in base 10, no leading zeros\n      \u2022 result.is_negative == (a.is_negative XOR b.is_negative)\n      \u2022 result.size \u2265 1, digits in [0,9]\n\nFunction: bigint_divmod\nPre-condition:\n    \u2022 numerator.digits, denominator.digits valid\n    \u2022 denominator \u2260 0\nPost-condition:\n    \u2022 Returns quotient = floor(numerator/denominator)\n    \u2022 *remainder = numerator mod denominator, with 0 \u2264 |*remainder| < |denominator|\n    \u2022 quotient and *remainder satisfy numerator == quotient\u00b7denominator + *remainder\n    \u2022 quotient.is_negative == (num.sign XOR den.sign)\n    \u2022 remainder.is_negative == num.sign\n    \u2022 no leading zeros in quotient or *remainder\n\nFunction: bigint_div\nPre-condition:\n    \u2022 a.digits, b.digits valid\n    \u2022 b \u2260 0\nPost-condition:\n    Returns floor(a/b), equivalent to bigint_divmod(a,b,&rem).quotient\n\nFunction: bigint_mod\nPre-condition:\n    \u2022 a.digits, b.digits valid\n    \u2022 b \u2260 0\nPost-condition:\n    Returns a mod b, equivalent to bigint_divmod(a,b,&rem).remainder\n\nFunction: bigint_pow\nPre-condition:\n    \u2022 a, b are valid bigints\nPost-condition:\n    Returns result = a^b if b \u2265 0, else returns 0\n      \u2022 result.is_negative == false (no negatives produced)\n      \u2022 result.size \u2265 1, digits in [0,9]\n\nFunction: bigint_fast_pow\nPre-condition:\n    \u2022 a, b, m valid bigints\n    \u2022 m > 0\nPost-condition:\n    Returns result = a^b mod m if b \u2265 0, else returns 0\n      \u2022 0 \u2264 result < |m|\n      \u2022 result.size \u2265 1, digits in [0,9]\n\nFunction: bigint_modinv\nPre-condition:\n    \u2022 a, m valid bigints\n    \u2022 gcd(a,m) == 1 (invertible)\nPost-condition:\n    Returns result such that (a * result) mod m == 1\n      \u2022 0 \u2264 result < |m|\n      \u2022 if no inverse exists, returns 0\n\nFunction: bigint_sqrt\nPre-condition:\n    \u2022 n.digits valid\n    \u2022 n \u2265 0\nPost-condition:\n    Returns the smallest x \u2265 0 such that x^2 \u2265 n\n      \u2022 (x\u22121)^2 < n \u2264 x^2\n      \u2022 result.size \u2265 1, digits in [0,9]\n\nFunction: bigint_is_even\nPre-condition:\n    \u2022 n.digits valid, n.size \u2265 1\nPost-condition:\n    Returns true iff the least-significant digit is even\n\nFunction: bigint_is_odd\nPre-condition:\n    \u2022 n.digits valid, n.size \u2265 1\nPost-condition:\n    Returns true iff the least-significant digit is odd\n\nFunction: bigint_is_prime\nPre-condition:\n    \u2022 n.digits valid, n.size \u2265 1\n    \u2022 n > 1\nPost-condition:\n    Returns true iff n is prime by trial division:\n      \u2022 checks 2, 3, 5 divisibility and trial divides up to sqrt(n)\n\nFunction: bigint_delete\nPre-condition:\n    \u2022 n.digits was allocated on the heap (malloc/realloc)\n    \u2022 n.size \u2265 1\nPost-condition:\n    \u2022 The heap buffer n.digits is freed\n    \u2022 n.digits is set to NULL, n.size = 0, n.is_negative = false",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\nFunction: function_name\nPre-condition: description of the pre-condition\nPost-condition: description of the post-condition\n```\n\nHere is the code:\n{{bigint.h}}\n```c\n/*\n * Adam's Big Integer Library\n * Version 1.0\n */\n#ifndef bigint_H\n#define bigint_H\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\ntypedef struct {\n    bool is_negative;\n    int64_t *digits;\n    size_t size;\n} bigint;\n\nvoid bigint_delete(bigint n);\n\nbigint bigint_zero() {\n    bigint result;\n    result.is_negative = false;\n    result.size = 1;\n    result.digits = malloc(sizeof(int64_t));\n    result.digits[0] = 0;\n    return result;\n}\n\nvoid bigint_print(bigint n);\n\nbool bigint_is_64_bit(bigint n) {\n    if (n.is_negative) {\n        if (n.size > 10) {\n            return false;\n        }\n        if (n.size < 10) {\n            return true;\n        }\n    } else {\n        if (n.size > 10) {\n            return false;\n        }\n        if (n.size < 10) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid bigint_remove_leading_zeros(bigint *n) {\n    size_t leading_zeros = 0;\n    for (size_t i = 0; i < n->size; i++) {\n        if (n->digits[i] == 0) {\n            leading_zeros++;\n        } else {\n            break;\n        }\n    }\n\n    // If there are leading zeros, memmove the digits\n    if (leading_zeros > 0) {\n        if (leading_zeros >= n->size) {\n            n->size = 1;\n            n->digits[0] = 0;\n            return;\n        }\n        n->size -= leading_zeros;\n        memmove(n->digits, n->digits + leading_zeros, n->size * sizeof(int64_t));\n    }\n}\n\nbigint bigint_from_int(int64_t n) {\n    bigint result;\n    if (n < 0) {\n        result.is_negative = true;\n        n = -n;\n    } else {\n        result.is_negative = false;\n    }\n    result.size = 1;\n    int64_t m = n;\n    while (m > 0) {\n        m /= 10;\n        result.size++;\n    }\n    result.digits = malloc(result.size * sizeof(int64_t));\n    m = n;\n    for (size_t i = 0; i < result.size; i++) {\n        result.digits[result.size - i - 1] = m % 10;\n        m /= 10;\n    }\n    bigint_remove_leading_zeros(&result);\n    return result;\n}\n\nint64_t bigint_to_int(bigint n) {\n    int64_t result = 0;\n    for (size_t i = 0; i < n.size; i++) {\n        result *= 10;\n        result += n.digits[i];\n    }\n    if (n.is_negative) {\n        result = -result;\n    }\n    return result;\n}\n\n/* Create a new bigint from an integer \n* @param n The integer to create a bigint from\n* @return A new bigint with the value of n\n*/\nbigint bigint_from_string(const char *n) {\n    bigint result;\n    \n    // Determine if the number is negative\n    if (n[0] == '-') {\n        result.is_negative = true;\n        n++;\n    } else {\n        result.is_negative = false;\n    }\n\n    // Determine the size of the number\n    result.size = strlen(n);\n\n    // Allocate memory for the digits\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n    // Copy the digits into the bigint\n    for (size_t i = 0; i < result.size; i++) {\n        result.digits[i] = n[i] - '0';\n    }\n    \n    return result;\n}\n\n\nbigint bigint_copy(bigint n) {\n    bigint result;\n    result.is_negative = n.is_negative;\n    result.size = n.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    memcpy(result.digits, n.digits, result.size * sizeof(int64_t));\n    return result;\n}\n\n/* Print a bigint\n* @param n The bigint to print\n*/\nvoid bigint_print(bigint n) {\n    if (n.is_negative) {\n        printf(\"-\");\n    }\n    for (size_t i = 0; i < n.size; i++) {\n        assert(n.digits[i] >= 0 && n.digits[i] <= 9);\n        printf(\"%lld\", n.digits[i]);\n    }\n}\n\n\nbool bigint_gt(bigint a, bigint b) {\n    bigint_remove_leading_zeros(&a);\n    bigint_remove_leading_zeros(&b);\n    if (a.size > b.size) {\n        return !a.is_negative;\n    }\n    if (a.size < b.size) {\n        return a.is_negative;\n    }\n    for (size_t i = 0; i < a.size; i++) {\n        if (a.digits[i] > b.digits[i]) {\n            return !a.is_negative;\n        }\n        if (a.digits[i] < b.digits[i]) {\n            return a.is_negative;\n        }\n    }\n    return false;\n}\n\nbool bigint_eq(bigint a, bigint b) {\n    bigint_remove_leading_zeros(&a);\n    bigint_remove_leading_zeros(&b);\n    if (a.size != b.size) {\n        return false;\n    }\n    if (a.is_negative != b.is_negative) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size; i++) {\n        if (a.digits[i] != b.digits[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool bigint_eqzero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return true;\n    }\n    return false;\n}\n\nbool bigint_ltzero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return false;\n    }\n    return n.is_negative;\n}\nbool bigint_gtzero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return false;\n    }\n    return !n.is_negative;\n}\n\nbool bigint_lezero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return true;\n    }\n    return n.is_negative;\n}\n\nbool bigint_gezero(bigint n) {\n    bigint_remove_leading_zeros(&n);\n    if (n.size == 1 && n.digits[0] == 0) {\n        return true;\n    }\n    return !n.is_negative;\n}\n\nbigint bigint_abs(bigint n) {\n    n.is_negative = false;\n    return n;\n}\n\nbool bigint_ge(bigint a, bigint b) {\n    return bigint_gt(a, b) || bigint_eq(a, b);\n}\n\nbool bigint_lt(bigint a, bigint b) {\n    return !bigint_ge(a, b);\n}\n\nbool bigint_le(bigint a, bigint b) {\n    return !bigint_gt(a, b);\n}\n\n\nbigint bigint_add(bigint a, bigint b);\n\n/* Subtract two bigints\n* @param a The first bigint\n* @param b The second bigint\n* @return The difference of a and b\n*/\nbigint bigint_sub(bigint a, bigint b) {\n    bigint result;\n    if (a.is_negative && b.is_negative) {\n        a.is_negative = false;\n        b.is_negative = false;\n        result = bigint_add(b, a);\n        result.is_negative = true;\n        return result;\n    }\n    \n    if (a.is_negative) {\n        // -a - b = -(a + b)\n        b.is_negative = true;\n        result = bigint_add(a, b);\n        return result;\n    }\n\n    if (b.is_negative) {\n        // a - (-b) = a + b\n        b.is_negative = false;\n        result = bigint_add(a, b);\n        return result;\n    }\n\n    result.size = a.size > b.size ? a.size : b.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n    bool is_negative = bigint_lt(a, b);\n\n\n    // Subtract the digits\n    int64_t carry = 0;\n    bigint larger = bigint_gt(a, b) ? a : b;\n    bigint smaller = bigint_gt(a, b) ? b : a;\n\n    for (size_t i = 0; i < result.size; i++) {\n        int64_t diff = carry;\n        if (i < larger.size) {\n            diff += larger.digits[larger.size - i - 1];\n        }\n        if (i < smaller.size) {\n            diff -= smaller.digits[smaller.size - i - 1];\n        }\n        if (diff < 0) {\n            diff += 10;\n            carry = -1;\n        } else {\n            carry = 0;\n        }\n        result.digits[result.size - i - 1] = diff;\n    }\n    \n    bigint_remove_leading_zeros(&result);\n\n    result.is_negative = is_negative;\n\n    return result;\n}\n\n/* Add two bigints\n* @param a The first bigint\n* @param b The second bigint\n* @return The sum of a and b\n*/\nbigint bigint_add(bigint a, bigint b) {\n    bigint result;\n    if (a.is_negative && b.is_negative) {\n        result.is_negative = true;\n    } else if (a.is_negative) {\n        a.is_negative = false;\n        result = bigint_sub(b, a);\n        return result;\n    } else if (b.is_negative) {\n        b.is_negative = false;\n        result = bigint_sub(a, b);\n        return result;\n    } else {\n        result.is_negative = false;\n    }\n    result.size = a.size > b.size ? a.size : b.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n\n    \n    // Add the digits\n    int64_t carry = 0;\n    for (size_t i = 0; i < result.size; i++) {\n        int64_t sum = carry;\n        if (i < a.size) {\n            sum += a.digits[a.size - i - 1];\n        }\n        if (i < b.size) {\n            sum += b.digits[b.size - i - 1];\n        }\n        result.digits[result.size - i - 1] = sum % 10;\n        carry = sum / 10;\n    }\n    \n    // If there is a carry, add another digit\n    if (carry > 0) {\n        result.size++;\n        result.digits = realloc(result.digits, result.size * sizeof(int64_t));\n        for (size_t i = result.size - 1; i > 0; i--) {\n            result.digits[i] = result.digits[i - 1];\n        }\n        result.digits[0] = carry;\n    }\n    bigint_remove_leading_zeros(&result);\n    \n    return result;\n}\n\n\nbigint bigint_inc(bigint *n) {\n    bigint one = bigint_from_string(\"1\"), tmp;\n    tmp = *n;\n    *n = bigint_add(*n, one);\n    bigint_delete(tmp);\n    bigint_delete(one);\n    return *n;\n}\n\nbigint bigint_dec(bigint *n) {\n    bigint one = bigint_from_string(\"1\"), tmp;\n    tmp = *n;\n    *n = bigint_sub(*n, one);\n    bigint_delete(tmp);\n    bigint_delete(one);\n    return *n;\n}\n\nbigint bigint_mul(bigint a, bigint b) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b)) {\n        return bigint_from_int(bigint_to_int(a) * bigint_to_int(b));\n    }\n\n\n    bigint result;\n    result.size = a.size + b.size;\n    result.digits = malloc(result.size * sizeof(int64_t));\n    \n    // Multiply the digits\n    for (size_t i = 0; i < result.size; i++) {\n        result.digits[i] = 0;\n    }\n    for (size_t i = 0; i < a.size; i++) {\n        for (size_t j = 0; j < b.size; j++) {\n            result.digits[result.size - i - j - 1] += a.digits[a.size - i - 1] * b.digits[b.size - j - 1];\n        }\n    }\n\n    // Normalize the result\n    int64_t carry = 0;\n    for (size_t i = 0; i < result.size; i++) {\n        int64_t sum = result.digits[result.size - i - 1] + carry;\n        result.digits[result.size - i - 1] = sum % 10;\n        carry = sum / 10;\n    }\n\n    // If there is a carry, add another digit\n    if (carry > 0) {\n        result.size++;\n        result.digits = realloc(result.digits, result.size * sizeof(int64_t));\n        for (size_t i = result.size - 1; i > 0; i--) {\n            result.digits[i] = result.digits[i - 1];\n        }\n        result.digits[0] = carry;\n    }\n    \n    bigint_remove_leading_zeros(&result);\n    \n    // Check negative\n    result.is_negative = a.is_negative != b.is_negative;\n    \n    return result;\n}\n\n\nbigint bigint_divmod(bigint numerator, bigint denominator, bigint *remainder) {\n    if (bigint_is_64_bit(numerator) && bigint_is_64_bit(denominator)) {\n        int64_t quotient = bigint_to_int(numerator) / bigint_to_int(denominator);\n        int64_t rem = bigint_to_int(numerator) % bigint_to_int(denominator);\n        *remainder = bigint_from_int(rem);\n        return bigint_from_int(quotient);\n    }\n\n    bigint quotient = bigint_from_string(\"0\");\n    \n    bool negative = numerator.is_negative != denominator.is_negative;\n    numerator.is_negative = false;\n    denominator.is_negative = false;\n    \n    bigint tmp1, tmp2;\n    numerator = bigint_copy(numerator);\n\n    // Divide the numerator by the denominator\n    // This is a very slow algorithm\n    // It works by subtracting the denominator from the numerator until the numerator is less than the denominator\n    // The number of times the denominator is subtracted is the quotient\n    // The remainder is the numerator after the last subtraction\n    while (bigint_gtzero(numerator)) {\n        tmp1 = numerator;\n        numerator = bigint_sub(numerator, denominator);\n        bigint_delete(tmp1);\n        if (bigint_ltzero(numerator)) {\n            break;\n        }\n        bigint_inc(&quotient);\n    }\n    if (bigint_ltzero(numerator)) {\n        tmp1 = numerator;\n        numerator = bigint_add(numerator, denominator);\n        bigint_delete(tmp1);\n    }\n\n    // Set the remainder\n    *remainder = numerator;\n\n    bigint_remove_leading_zeros(&quotient);\n\n    if (negative) {\n        quotient.is_negative = true;\n        remainder->is_negative = true;\n    }\n\n    return quotient;\n}\n\nbigint bigint_div(bigint a, bigint b) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b)) {\n        return bigint_from_int(bigint_to_int(a) / bigint_to_int(b));\n    }\n\n    bigint remainder;\n    bigint result = bigint_divmod(a, b, &remainder);\n    bigint_delete(remainder);\n    return result;\n}\n\nbigint bigint_mod(bigint a, bigint b) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b)) {\n        bigint result = bigint_from_int(bigint_to_int(a) % bigint_to_int(b));\n        // printf(\"Computing %lld %% %lld = %lld\\n\", bigint_to_int(a), bigint_to_int(b), bigint_to_int(result));\n        return result;\n    }\n\n    bigint remainder;\n    bigint_delete(bigint_divmod(a, b, &remainder));\n    return remainder;\n}\n\nbigint bigint_pow(bigint a, bigint b) {\n    bigint result, tmp;\n    if (b.is_negative) {\n        result = bigint_from_string(\"0\");\n        return result;\n    }\n    result = bigint_from_string(\"1\");\n    if (bigint_eqzero(b)) {\n        return result;\n    }\n    b = bigint_copy(b);\n    while (!bigint_eqzero(b)) {\n        tmp = result;\n        result = bigint_mul(result, a);\n        bigint_delete(tmp);\n        bigint_dec(&b);\n    }\n    bigint_delete(b);\n    return result;\n}\n\nbool bigint_is_odd(bigint n);\nbool bigint_is_even(bigint n);\n\nbigint bigint_fast_pow(bigint a, bigint b, bigint m) {\n    if (bigint_is_64_bit(a) && bigint_is_64_bit(b) && bigint_is_64_bit(m)) {\n        int64_t result = 1;\n        int64_t base = bigint_to_int(a);\n        int64_t exp = bigint_to_int(b);\n        int64_t mod = bigint_to_int(m);\n        base %= mod;\n        while (exp > 0) {\n            if (exp % 2 == 1) {\n                result = (result * base) % mod;\n            }\n            exp = exp >> 1;\n            base = (base * base) % mod;\n        }\n        return bigint_from_int(result);\n    }\n    \n    bigint result;\n\n    if (b.is_negative) {\n        result = bigint_from_string(\"0\");\n        return result;\n    }\n    if (bigint_eqzero(b)) {\n        result = bigint_from_string(\"1\");\n        return result;\n    }\n\n    bigint tmp1, tmp2;\n    // printf(\"Computing %lld ^ %lld mod %lld\\n\", bigint_to_int(a), bigint_to_int(b), bigint_to_int(m));\n    b = bigint_copy(b);\n    a = bigint_mod(a, m);\n    result = bigint_copy(a);\n    bigint b_save = bigint_copy(b);\n    bigint_dec(&b);\n\n    bigint pow = bigint_from_string(\"1\");\n    while (true) {\n        tmp1 = bigint_from_string(\"2\");\n        tmp2 = bigint_div(b, tmp1);\n        bigint_delete(tmp1);\n        if (!bigint_gtzero(tmp2)) {\n            bigint_delete(tmp2);\n            break;\n        }\n        bigint_delete(tmp2);\n\n        tmp1 = bigint_mul(result, result);\n        tmp2 = result;\n        result = bigint_mod(tmp1, m);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        // Halve b\n        tmp1 = b;\n        tmp2 = bigint_from_string(\"2\");\n        \n        b = bigint_div(b, tmp2);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        \n        tmp1 = pow;\n        pow = bigint_add(pow, pow);\n        bigint_delete(tmp1);\n    }\n    \n    tmp1 = b_save;\n    b_save = bigint_sub(b_save, pow);\n    bigint_delete(tmp1);\n\n    if (bigint_is_odd(b_save)) {\n        tmp1 = result;\n        tmp2 = bigint_mul(result, a);\n        result = bigint_mod(tmp2, m);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        bigint_dec(&b_save);\n        bigint_inc(&pow);\n    }\n\n    if (bigint_lt(b_save, bigint_from_int(5))) {\n        while (!bigint_eqzero(b_save)) {\n            tmp1 = result;\n            tmp2 = bigint_mul(result, a);\n            result = bigint_mod(tmp2, m);\n            bigint_delete(tmp1);\n            bigint_delete(tmp2);\n            bigint_dec(&b_save);\n            bigint_inc(&pow);\n        }\n\n        bigint_delete(b_save);\n        bigint_delete(pow);\n\n        return result;\n    }\n\n    // Do the same halving powers for the subpart\n    bigint subpart = bigint_fast_pow(a, b_save, m);\n\n    tmp1 = result;\n    tmp2 = subpart;\n    result = bigint_mul(result, subpart);\n    bigint_delete(tmp1);\n    bigint_delete(tmp2);\n\n    tmp1 = result;\n    result = bigint_mod(result, m);\n    bigint_delete(tmp1);\n\n    bigint_delete(b_save);\n    bigint_delete(pow);\n    \n    return result;\n}\n\nbigint bigint_modinv(bigint a, bigint m) {\n    bigint m0 = bigint_copy(m);\n    bigint y = bigint_from_string(\"0\");\n    bigint x = bigint_from_string(\"1\");\n    bigint q = bigint_from_string(\"0\");\n    bigint t = bigint_from_string(\"0\");\n    bigint temp = bigint_from_string(\"0\");\n    bigint one = bigint_from_string(\"1\");\n    a = bigint_copy(a);\n    m = bigint_copy(m);\n\n    bigint tmp1, tmp2;\n    while (!bigint_eqzero(a)) {\n        tmp1 = q;\n        q = bigint_div(m, a);\n        bigint_delete(tmp1);\n\n        tmp1 = t;\n        tmp2 = bigint_mul(q, a);\n        t = bigint_sub(m, tmp2);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        tmp1 = m, tmp2 = a;\n        m = bigint_copy(a);\n        a = bigint_copy(t);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        tmp1 = t;\n        tmp2 = bigint_mul(q, x);\n        t = bigint_sub(y, tmp2);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n\n        tmp1 = y, tmp2 = x;\n        y = bigint_copy(x);\n        x = bigint_copy(t);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n    }\n    if (bigint_ltzero(m)) {\n        tmp1 = m;\n        m = bigint_add(m, m0);\n        bigint_delete(tmp1);\n    }\n\n    if (bigint_eq(m, one)) {\n        bigint result = bigint_mod(y, m0);\n        if (bigint_ltzero(result)) {\n            tmp1 = result;\n            result = bigint_add(result, m0);\n            bigint_delete(tmp1);\n        }\n        bigint_delete(a);\n        bigint_delete(m);\n        bigint_delete(m0);\n        bigint_delete(y);\n        bigint_delete(x);\n        bigint_delete(q);\n        bigint_delete(t);\n        bigint_delete(temp);\n        bigint_delete(one);\n        return result;\n    }\n    bigint_delete(a);\n    bigint_delete(m);\n    bigint_delete(m0);\n    bigint_delete(y);\n    bigint_delete(x);\n    bigint_delete(q);\n    bigint_delete(t);\n    bigint_delete(temp);\n    bigint_delete(one);\n    return bigint_from_int(0);\n}\n\nbigint bigint_sqrt(bigint n) {\n    bigint one = bigint_from_string(\"1\");\n    bigint two = bigint_from_string(\"2\");\n    bigint low = bigint_from_string(\"0\");\n    bigint high = bigint_copy(n);\n    bigint mid = bigint_from_string(\"0\");\n    while (bigint_lt(low, high)) {\n        bigint tmp1 = bigint_add(low, high);\n        bigint tmp2 = mid;\n        mid = bigint_div(tmp1, two);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        tmp1 = bigint_mul(mid, mid);\n        if (bigint_lt(tmp1, n)) {\n            tmp2 = low;\n            low = bigint_add(mid, one);\n            bigint_delete(tmp2);\n        } else {\n            tmp2 = high;\n            high = bigint_copy(mid);\n            bigint_delete(tmp2);\n        }\n        bigint_delete(tmp1);\n    }\n\n    bigint_delete(one);\n    bigint_delete(two);\n    bigint_delete(mid);\n    bigint_delete(high);\n\n    return low;\n}\n\nbool bigint_is_even(bigint n) {\n    return n.digits[n.size - 1] % 2 == 0;\n}\n\nbool bigint_is_odd(bigint n) {\n    return n.digits[n.size - 1] % 2 == 1;\n}\n\nbool bigint_is_prime(bigint n) {\n    bigint tmp1, tmp2;\n    // Check if the number is even\n    if (bigint_is_even(n)) {\n        return false;\n    }\n\n    // If the last digit is a 5 or 0, the number is divisible by 5\n    if (n.size > 1 && (n.digits[n.size - 1] == 5 || n.digits[n.size - 1] == 0)) {\n        return false;\n    }\n    // Check if the sum of the digits is divisible by 3\n    bigint sum = bigint_from_string(\"0\");\n    for (size_t i = 0; i < n.size; i++) {\n        tmp1 = bigint_from_int(n.digits[i]);\n        tmp2 = sum;\n        sum = bigint_add(sum, tmp1);\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n    }\n\n    tmp1 = bigint_from_string(\"3\");\n    tmp2 = bigint_mod(sum, tmp1);\n    if (bigint_eqzero(tmp2)) {\n        bigint_delete(tmp1);\n        bigint_delete(tmp2);\n        bigint_delete(sum);\n        return false;\n    }\n    bigint_delete(tmp1);\n    bigint_delete(tmp2);\n    bigint_delete(sum);\n\n    bigint sqrt_n = bigint_sqrt(n);\n    \n    for (tmp1 = bigint_from_string(\"2\"); bigint_le(tmp1, sqrt_n); bigint_inc(&tmp1)) {\n        tmp2 = bigint_mod(n, tmp1);\n        if (bigint_eqzero(tmp2)) {\n            bigint_delete(tmp1);\n            bigint_delete(tmp2);\n            bigint_delete(sqrt_n);\n            return false;\n        }\n        bigint_delete(tmp2);\n    }\n    bigint_delete(tmp1);\n    bigint_delete(sqrt_n);\n    return true;\n}\n\n/* Delete a bigint\n* @param n The bigint to delete\n*/\n#include <execinfo.h>\nvoid bigint_delete(bigint n) {\n    free(n.digits);\n    n.digits = NULL;\n    n.is_negative = false;\n    n.size = 0;\n}\n\n#endif```\n\n\nPlease extract the invariants from the code.\n"
}