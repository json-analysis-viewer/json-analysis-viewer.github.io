{
    "name": "csyncmers",
    "manual_invs": "```rust\nuse std::u128;\nuse crate::{\n    base_to_bits, complement_base,\n    compute_closed_syncmers, add_minimizer,\n    MinimizerResult,\n};\n\n/// Performs invariant checks extracted from the C implementation of `compute_closed_syncmers`.\n/// Panics if any invariant is violated.\npub fn check_invariants() {\n    // Invariant 1: base_to_bits maps the four DNA bases to 0..3,\n    // and complement_base is the 2-bit complement and involutive.\n    let bases = [('A', 0u8), ('C', 1u8), ('G', 2u8), ('T', 3u8)];\n    for &(ch, expected_bits) in &bases {\n        let bits = base_to_bits(ch);\n        assert_eq!(\n            bits, expected_bits,\n            \"base_to_bits('{}') = {}, expected {}\",\n            ch, bits, expected_bits\n        );\n        let comp = complement_base(bits);\n        let expected_comp = 3u8 - bits; // A<->T and C<->G\n        assert_eq!(\n            comp, expected_comp,\n            \"complement_base({}) = {}, expected {}\",\n            bits, comp, expected_comp\n        );\n        // Double complement yields original bits\n        let comp2 = complement_base(comp);\n        assert_eq!(\n            comp2, bits,\n            \"complement_base(complement_base({})) = {}, expected {}\",\n            bits, comp2, bits\n        );\n    }\n\n    // Invariant 2: add_minimizer appends exactly one new entry and updates num correctly.\n    let mut results: Vec<MinimizerResult> = Vec::new();\n    let mut num = 0i32;\n    add_minimizer(&mut results, &mut num, 0xDEAD_BEEFu128, 5usize, 7usize);\n    assert_eq!(num, 1, \"num_results after add_minimizer should be 1, got {}\", num);\n    assert_eq!(\n        results.len(),\n        1,\n        \"results.len() after add_minimizer should be 1, got {}\",\n        results.len()\n    );\n    let r = &results[0];\n    assert_eq!(\n        r.minimizer_hash, 0xDEAD_BEEFu128,\n        \"minimizer_hash in stored result mismatch\"\n    );\n    assert_eq!(\n        r.kmer_position, 5usize,\n        \"kmer_position in stored result mismatch\"\n    );\n    assert_eq!(\n        r.smer_position, 7usize,\n        \"smer_position in stored result mismatch\"\n    );\n\n    // Invariant 3: compute_closed_syncmers returns no results when len < K.\n    let seq_short = \"ACGT\";\n    let mut results = Vec::new();\n    let mut num = -1i32;\n    compute_closed_syncmers(seq_short, seq_short.len() as i32, /*K=*/ 10, /*S=*/ 3, &mut results, &mut num);\n    assert_eq!(\n        num, 0,\n        \"When sequence length < K, num_results must be 0, got {}\",\n        num\n    );\n    assert!(\n        results.is_empty(),\n        \"When sequence length < K, results must be empty\"\n    );\n\n    // Invariant 4: On a small known sequence, every MinimizerResult obeys:\n    //   1) kmer_position + K <= seq.len()\n    //   2) smer_position in [kmer_position .. kmer_position + (K-S)]\n    //   3) minimizer_hash <= (1 << (2*S)) - 1\n    let seq = \"ACGTACGT\";\n    let S = 2;\n    let K = 3;\n    let mut results = Vec::new();\n    let mut num = 0i32;\n    compute_closed_syncmers(seq, seq.len() as i32, K, S, &mut results, &mut num);\n    let seq_len = seq.len();\n    let mask_max = ((1u128) << (2 * (S as usize))) - 1;\n    for r in &results {\n        // 1) kmer window fits\n        assert!(\n            r.kmer_position + (K as usize) <= seq_len,\n            \"kmer_position {} + K {} exceeds sequence length {}\",\n            r.kmer_position,\n            K,\n            seq_len\n        );\n        // 2) syncmer index in valid subrange\n        let max_offset = (K as usize).saturating_sub(S as usize);\n        assert!(\n            r.smer_position >= r.kmer_position,\n            \"smer_position {} < kmer_position {}\",\n            r.smer_position,\n            r.kmer_position\n        );\n        assert!(\n            r.smer_position <= r.kmer_position + max_offset,\n            \"smer_position {} > kmer_position+K-S {}\",\n            r.smer_position,\n            r.kmer_position + max_offset\n        );\n        // 3) hash within mask\n        assert!(\n            r.minimizer_hash <= mask_max,\n            \"minimizer_hash {} exceeds mask {}\",\n            r.minimizer_hash,\n            mask_max\n        );\n    }\n\n    // Invariant 5: Results are sorted by kmer_position and never skip more than one.\n    for win in results.windows(2) {\n        let a = &win[0];\n        let b = &win[1];\n        assert!(\n            a.kmer_position <= b.kmer_position,\n            \"Results not sorted by kmer_position: {} > {}\",\n            a.kmer_position,\n            b.kmer_position\n        );\n        assert!(\n            b.kmer_position - a.kmer_position <= 1,\n            \"kmer_position jumped from {} to {} (>1)\",\n            a.kmer_position,\n            b.kmer_position\n        );\n    }\n}\n\n/// Invariants enforced:\n/// - base_to_bits maps 'A','C','G','T' to 0,1,2,3 respectively.\n/// - complement_base computes 2-bit DNA complement (A\u2194T, C\u2194G) and is an involution.\n/// - add_minimizer appends exactly one result and increments num_results accordingly.\n/// - compute_closed_syncmers produces no results when sequence length < K (num_results==0).\n/// - For each MinimizerResult:\n///     * kmer_position + K \u2264 sequence length.\n///     * kmer_position \u2264 smer_position \u2264 kmer_position + (K\u2013S).\n///     * minimizer_hash \u2264 (1 << (2 \u00d7 S)) \u2013 1.\n/// - The sequence of kmer_positions in results is non-decreasing and steps by at most 1.\n```",
    "rri_prompt": "Task: Extract invariants from C  code and emit a Rust function called `check_invariants`\nRole: You are a rigorous program analyst. You will study a C program and its Rust interface files. Your job is to derive invariants of the program and implement a Rust model checker function named check_invariants.\nDo any reasoning internally; only output the requested sections and code.\n\nInputs\n\n1. C function under analysis.\n2. C test case that is currently failing.\n3. Rust interface relevant to the C function.\n\nYou must implement a single Rust model checker-style function named `check_invariants`:\n1. Perform non-trivial invariant checks derived from the C program\u2019s behavior (no placeholders).\n2. Use `assert!` / `assert_eq!` with clear failure messages that include key values.\n3. You should not add unit tests but rather infer general invariants that hold for all valid states of the program.\n\nIf some invalid states cannot be constructed via safe APIs, then:\n\n1. Assert that the public constructors/validators correctly reject them (e.g., expect Err), or\n2. Skip those specific negative cases and document why in a short code comment (no speculation, just interface-limited reasoning).\n3. A brief bullet list titled \u201cInvariants enforced\u201d summarizing each invariant in plain language (no derivations or chain-of-thought; just the final invariants).\n\nConstraints & style\n\n1. Use only items available in the Rust interface (no new public types or deps).\n2. Prefer safe Rust; do not use unsafe unless the interface explicitly requires it.\n3. No logging/printing. No randomness. No external crates.\n4. If the interface already includes a validator that returns Result, you may call it and assert on Ok/Err instead of re-implementing internals.\n\nImplementation checklist\n1. Read the Rust interface to understand how to construct states.\n2. From the C code, enumerate and infer candidate invariants. Keep only those that must hold for all reachable states.\n3. Valid cases: assert the invariant holds.\n\nNow you will be provided with the C source code and Rust interface definitions.\n\nC source (program under analysis):\n```c\nvoid compute_closed_syncmers(const char *sequence_input, int len, int K, int S, MinimizerResult *results, int *num_results) {\n    *num_results = 0;\n    if(len < K) {\n        fprintf(stderr, \"Sequence length is less than K\\n\");\n        return;\n    }\n\n    size_t num_s_mers = len - S + 1;\n    __uint128_t *s_mer_hashes = (__uint128_t *)malloc(num_s_mers * sizeof(__uint128_t));\n\n    // Precompute all s-mer hashes\n    __uint128_t mask = (((__uint128_t)1) << (2 * S)) - 1;\n    __uint128_t hash_fwd = 0, hash_rev = 0;\n    __uint128_t rc_shift = 2 * (S - 1);\n\n    for(size_t i = 0; i < len; i++) {\n        uint8_t base = base_to_bits(sequence_input[i]);\n        hash_fwd = ((hash_fwd << 2) | base) & mask;\n        uint8_t comp_base = complement_base(base);\n        hash_rev = ((hash_rev >> 2) | ((__uint128_t)comp_base << rc_shift)) & mask;\n        if(i >= S - 1) {\n            size_t s_mer_pos = i - S + 1;\n            __uint128_t canonical_hash = (hash_fwd < hash_rev) ? hash_fwd : hash_rev;\n            s_mer_hashes[s_mer_pos] = canonical_hash;\n        }\n    }\n\n    // Initialize deque\n    size_t window_size = K - S + 1;\n    size_t *deque = (size_t *)malloc(num_s_mers * sizeof(size_t));\n    size_t front = 0, back = 0;\n\n    // Use deque to find minimal s-mers in O(N)\n    for(size_t i = 0; i < num_s_mers; i++) {\n        while(back > front  && s_mer_hashes[deque[back-1]] > s_mer_hashes[i]) {\n            back--;\n        }\n        deque[back++] = i;\n\t if(i >= window_size && deque[front] <= i - window_size) {\n            front++;\n\t}\n\n        // Check for closed syncmer condition\n        if(i >= window_size - 1) {\n            size_t min_pos = deque[front];\n            size_t kmer_pos = i - window_size + 1;\n            if(min_pos == kmer_pos || min_pos == kmer_pos + K - S) {\n            \t//printf(\"%.*s\\n\", K, &sequence_input[i]);\n                add_minimizer(results, num_results, s_mer_hashes[min_pos], kmer_pos, min_pos);\n            }\n        }\n    }\n\n    free(s_mer_hashes);\n    free(deque);\n}\n```\n\nC Tests (the test cases used for the program under analysis):\n\n```c\nint main() {\n    srand(time(NULL)); // Seed the random number generator\n\n    int num_tests = 10;\n    int sequence_length = 1050;\n    char sequence[sequence_length + 1]; // +1 for the null terminator\n\n    for (int test = 1; test <= num_tests; test++) {\n        // Generate a random sequence\n        generate_sequence(sequence, sequence_length);\n\n        // Generate random 'a' such that 10 < a < 1000\n        int a = rand() % 989 + 11; // Random integer between 11 and 999 inclusive\n\n        // Calculate 'b' constraints: 6 < b < a and b < 100\n        int b_min = 7;\n        int b_max = (a - 1 < 63) ? a - 1 : 63;\n\n        // Ensure b_min does not exceed b_max\n        int b = (b_max < b_min) ? b_min : (rand() % (b_max - b_min + 1) + b_min);\n\n        printf(\"Test %d: Sequence Length=%d, K=%d, S=%d\\n\", test, sequence_length, a, b);\n\n        int num_results;\n        MinimizerResult results[10000];\n        compute_closed_syncmers(sequence, strlen(sequence), a, b, results, &num_results);\n\n        printf(\"Closed Syncmers:\\n\");\n        printf(\"%-20s %-20s\\n\", \"Position\", \"Minimizer Hash\");\n        for (int i = 0; i < num_results; i++) {\n            printf(\"%-20zu %-20llu\\n\", results[i].kmer_position, (unsigned long long)results[i].minimizer_hash);\n        }\n\n        // Compute closed syncmers using the naive method\n        int num_naive_results;\n        MinimizerResult naive_results[10000];\n        compute_closed_syncmers_naive(sequence, strlen(sequence), a, b, naive_results, &num_naive_results);\n\n        printf(\"\\nClosed Syncmers (Naive):\\n\");\n        printf(\"%-20s %-20s\\n\", \"Position\", \"Minimizer Hash\");\n        for (int i = 0; i < num_naive_results; i++) {\n            printf(\"%-20zu %-20llu\\n\", naive_results[i].kmer_position, (unsigned long long)naive_results[i].minimizer_hash);\n        }\n\n        // Compare the results\n        if (num_results != num_naive_results) {\n            printf(\"\\nMismatch in number of closed syncmers: %d (original) vs %d (naive)\\n\", num_results, num_naive_results);\n            return 1;\n        } else {\n            printf(\"\\nNumber of closed syncmers matches: %d\\n\", num_results);\n        }\n\n        // Compare each result\n        int mismatch = 0;\n        for (int i = 0; i < num_results; i++) {\n            if (results[i].kmer_position != naive_results[i].kmer_position ||\n                results[i].minimizer_hash != naive_results[i].minimizer_hash) {\n                printf(\"Mismatch at index %d:\\n\", i);\n                printf(\"  Original -> Position: %zu, Hash: %llu\\n\",\n                       results[i].kmer_position, (unsigned long long)results[i].minimizer_hash);\n                printf(\"  Naive    -> Position: %zu, Hash: %llu\\n\",\n                       naive_results[i].kmer_position, (unsigned long long)naive_results[i].minimizer_hash);\n                mismatch = 1;\n                break;\n            }\n        }\n        if (mismatch) {\n            printf(\"Test %d failed.\\n\", test);\n            return 1;\n        }\n\n        printf(\"Test %d passed. All closed syncmers match between original and naive method.\\n\\n\", test);\n    }\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}\n```\n\nRust test that fails (the test case that currently fails):\n```rust\nfn test() {\n    let num_tests = 10;\n    let sequence_length = 1050;\n\n    for test in 1..=num_tests {\n        let sequence = generate_sequence(sequence_length);\n        let a = rand::thread_rng().gen_range(11..=999);\n        let b_min = 7;\n        let b_max = if a - 1 < 63 { a - 1 } else { 63 };\n        let b = if b_max < b_min { b_min } else { rand::thread_rng().gen_range(b_min..=b_max) };\n\n        println!(\"Test {}: Sequence Length={}, K={}, S={}\", test, sequence_length, a, b);\n\n        let mut results = Vec::new();\n        let mut num_results = 0;\n        compute_closed_syncmers(&sequence, sequence.len() as i32, a, b, &mut results, &mut num_results);\n\n        println!(\"Closed Syncmers:\");\n        println!(\"{:<20} {:<20}\", \"Position\", \"Minimizer Hash\");\n        for result in &results {\n            println!(\"{:<20} {:<20}\", result.kmer_position, result.minimizer_hash);\n        }\n\n        let mut naive_results = Vec::new();\n        let mut num_naive_results = 0;\n        compute_closed_syncmers_naive(&sequence, sequence.len(), a, b, &mut naive_results, &mut num_naive_results);\n\n        println!(\"\\nClosed Syncmers (Naive):\");\n        println!(\"{:<20} {:<20}\", \"Position\", \"Minimizer Hash\");\n        for result in &naive_results {\n            println!(\"{:<20} {:<20}\", result.kmer_position, result.minimizer_hash);\n        }\n\n        assert_eq!(num_results, num_naive_results, \"Mismatch in number of closed syncmers: {} (original) vs {} (naive)\", num_results, num_naive_results);\n\n        for (i, (result, naive_result)) in results.iter().zip(naive_results.iter()).enumerate() {\n            assert_eq!(result.kmer_position, naive_result.kmer_position, \"Mismatch at index {}: Position\", i);\n            assert_eq!(result.minimizer_hash, naive_result.minimizer_hash, \"Mismatch at index {}: Hash\", i);\n        }\n\n        println!(\"Test {} passed. All closed syncmers match between original and naive method.\\n\", test);\n    }\n\n    println!(\"All tests passed.\");\n}\n```\n\n\nRust interface files (types, functions, signatures you MUST use to build test fixtures):\n```rust\n// Import necessary modules\nuse std::collections::HashMap;\n// Struct Definitions\n#[derive(Debug, Clone)]\npub struct MinimizerResult {\n    pub minimizer_hash: u128,\n    pub kmer_position: usize,\n    pub smer_position: usize,\n}\n// Function Declarations\npub fn compute_closed_syncmers(sequence_input: &str, len: i32, k: i32, s: i32, results: &mut Vec<MinimizerResult>, num_results: &mut i32) {\n    unimplemented!()\n}\npub fn base_to_bits(base: char) -> u8 {\n    unimplemented!()\n}\npub fn complement_base(base: u8) -> u8 {\n    unimplemented!()\n}\npub fn add_minimizer(results: &mut Vec<MinimizerResult>, size: &mut i32, minimizer_hash: u128, kmer_position: usize, smer_position: usize) {\n    unimplemented!()\n}\n```\n\nPlease provide the final code in ```rust ``` tags"
}