{
    "name": "clhash",
    "manual_invs": "```rust\nuse std::convert::TryInto;\n\n// Bring in the clhash function and constants from the interface under test.\nuse your_crate::{clhash, RANDOM_BYTES_NEEDED_FOR_CLHASH};\n\n/// Run a suite of invariants derived from the C implementation of CLHASH.\n/// Panics if any invariant is violated.\npub fn check_invariants() {\n    // 1) Construct a valid random key buffer the same way the tests do.\n    //    We fill it deterministically so that invariants are reproducible.\n    let mut rnd_u8 = Vec::with_capacity(RANDOM_BYTES_NEEDED_FOR_CLHASH);\n    for i in 0..RANDOM_BYTES_NEEDED_FOR_CLHASH {\n        // mirror the C avalanche test key-generation: rs[k] = k+1 - k*k\n        let k = i as i64;\n        let v = (k + 1 - k * k) as i64;\n        rnd_u8.push((v as u8).wrapping_mul(1));\n    }\n    let random = &rnd_u8[..];\n\n    // Invariant 1 & 2 & 3: For all lengths up to 8 bytes:\n    //  - flipping any single bit changes the hash\n    //  - flipping the same bit twice returns to the original hash\n    //  - for two different base fill-values, the XOR-difference on flip is identical\n    for len in 1..=std::mem::size_of::<u64>() {\n        // Prepare two base messages: all-zero and all-35\n        let mut m0 = vec![0u8; len];\n        let mut m1 = vec![35u8; len];\n\n        // Compute original hashes\n        let h0_orig = clhash(random, &m0);\n        let h1_orig = clhash(random, &m1);\n\n        for bit in 0..(len * 8) {\n            // Flip in m0\n            let byte_idx = bit / 8;\n            let bit_mask = 1u8 << (bit % 8);\n\n            // flip once\n            m0[byte_idx] ^= bit_mask;\n            let h0_flip = clhash(random, &m0);\n            // invariant: hash must change\n            assert_ne!(\n                h0_flip, h0_orig,\n                \"Invariant violation: flipping bit {} in len {} did NOT change hash (h0)\",\n                bit,\n                len\n            );\n            // flip back\n            m0[byte_idx] ^= bit_mask;\n            let h0_back = clhash(random, &m0);\n            // invariant: flipping twice returns to original\n            assert_eq!(\n                h0_back, h0_orig,\n                \"Invariant violation: flipping bit {} twice in len {} did not revert hash (h0)\",\n                bit,\n                len\n            );\n\n            // repeat for m1\n            m1[byte_idx] ^= bit_mask;\n            let h1_flip = clhash(random, &m1);\n            assert_ne!(\n                h1_flip, h1_orig,\n                \"Invariant violation: flipping bit {} in len {} did NOT change hash (h1)\",\n                bit,\n                len\n            );\n            m1[byte_idx] ^= bit_mask;\n            let h1_back = clhash(random, &m1);\n            assert_eq!(\n                h1_back, h1_orig,\n                \"Invariant violation: flipping bit {} twice in len {} did not revert hash (h1)\",\n                bit,\n                len\n            );\n\n            // XOR-difference invariance across different base-values\n            let delta0 = h0_orig ^ h0_flip;\n            let delta1 = h1_orig ^ h1_flip;\n            assert_eq!(\n                delta0, delta1,\n                \"Invariant violation: XOR-delta differs for len {} bit {}: delta0=0x{:016X}, delta1=0x{:016X}\",\n                len,\n                bit,\n                delta0,\n                delta1\n            );\n        }\n    }\n\n    // Invariant 4: Changing the last byte of long messages never produces a collision.\n    // We test several block multiples + small tail, as in the C collision test.\n    const CLNH_NUM_BYTES_PER_BLOCK: usize = 1024;\n    const NUM_TRIALS: usize = 5; // scale down for speed, still exercises the path\n    for i in 1..=NUM_TRIALS {\n        for tail in 1..=8 {\n            let mlen = i * CLNH_NUM_BYTES_PER_BLOCK + tail;\n            // construct message [0,1,2,...]\n            let mut m = Vec::with_capacity(mlen);\n            for j in 0..mlen {\n                m.push((j & 0xFF) as u8);\n            }\n            let h1 = clhash(random, &m);\n            // flip the last byte\n            let last = mlen - 1;\n            m[last] = m[last].wrapping_add(1);\n            let h2 = clhash(random, &m);\n            assert_ne!(\n                h1, h2,\n                \"Invariant violation: collision detected at len {}: hash1=0x{:016X}, hash2=0x{:016X}\",\n                mlen,\n                h1,\n                h2\n            );\n        }\n    }\n}\n\n/// Summary of Invariants enforced:\n///\n/// - Flipping any single bit in an input of length \u2264 8 bytes always changes the hash.\n/// - Flipping the same bit twice in such inputs restores the original hash.\n/// - For inputs of length \u2264 8 bytes, the XOR difference resulting from flipping a given bit\n///   is independent of the input\u2019s base fill\u2010value.\n/// - For many large message lengths (multiples of 1024 + 1\u20268),\n///   changing only the last byte never produces a hash collision.\n```\n\nInvariants enforced\n\n- Flipping any single bit in an input of length \u2264 8 bytes always changes the hash.\n- Flipping the same bit twice in such inputs restores the original hash.\n- For inputs of length \u2264 8 bytes, the XOR difference resulting from flipping a given bit is independent of the input\u2019s base fill\u2010value.\n- For many large message lengths (multiples of 1024 + 1\u20268), changing only the last byte never produces a hash collision.",
    "rri_prompt": "Task: Extract invariants from C  code and emit a Rust function called `check_invariants`\nRole: You are a rigorous program analyst. You will study a C program and its Rust interface files. Your job is to derive invariants of the program and implement a Rust model checker function named check_invariants.\nDo any reasoning internally; only output the requested sections and code.\n\nInputs\n\n1. C function under analysis.\n2. C test case that is currently failing.\n3. Rust interface relevant to the C function.\n\nYou must implement a single Rust model checker-style function named `check_invariants`:\n1. Perform non-trivial invariant checks derived from the C program\u2019s behavior (no placeholders).\n2. Use `assert!` / `assert_eq!` with clear failure messages that include key values.\n3. You should not add unit tests but rather infer general invariants that hold for all valid states of the program.\n\nIf some invalid states cannot be constructed via safe APIs, then:\n\n1. Assert that the public constructors/validators correctly reject them (e.g., expect Err), or\n2. Skip those specific negative cases and document why in a short code comment (no speculation, just interface-limited reasoning).\n3. A brief bullet list titled \u201cInvariants enforced\u201d summarizing each invariant in plain language (no derivations or chain-of-thought; just the final invariants).\n\nConstraints & style\n\n1. Use only items available in the Rust interface (no new public types or deps).\n2. Prefer safe Rust; do not use unsafe unless the interface explicitly requires it.\n3. No logging/printing. No randomness. No external crates.\n4. If the interface already includes a validator that returns Result, you may call it and assert on Ok/Err instead of re-implementing internals.\n\nImplementation checklist\n1. Read the Rust interface to understand how to construct states.\n2. From the C code, enumerate and infer candidate invariants. Keep only those that must hold for all reachable states.\n3. Valid cases: assert the invariant holds.\n\nNow you will be provided with the C source code and Rust interface definitions.\n\nC source (program under analysis):\n```c\nuint64_t clhash(const void* random, const char * stringbyte,\n                const size_t lengthbyte) {\n    assert(sizeof(size_t)<=sizeof(uint64_t));// otherwise, we need to worry\n    assert(((uintptr_t) random & 15) == 0);// we expect cache line alignment for the keys\n    const unsigned int  m = 128;// we process the data in chunks of 16 cache lines\n    if(CLHASH_DEBUG) assert((m  & 3) == 0); //m should be divisible by 4\n    const int m128neededperblock = m / 2;// that is how many 128-bit words of random bits we use per block\n    const __m128i * rs64 = (__m128i *) random;\n    __m128i polyvalue =  _mm_load_si128(rs64 + m128neededperblock); // to preserve alignment on cache lines for main loop, we pick random bits at the end\n    polyvalue = _mm_and_si128(polyvalue,_mm_setr_epi32(0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0x3fffffff));// setting two highest bits to zero\n    // we should check that polyvalue is non-zero, though this is best done outside the function and highly unlikely\n    const size_t length = lengthbyte / sizeof(uint64_t); // # of complete words\n    const size_t lengthinc = (lengthbyte + sizeof(uint64_t) - 1) / sizeof(uint64_t); // # of words, including partial ones\n\n    const uint64_t * string = (const uint64_t *)  stringbyte;\n    if (m < lengthinc) { // long strings // modified from length to lengthinc to address issue #3 raised by Eik List\n        __m128i  acc =  __clmulhalfscalarproductwithoutreduction(rs64, string,m);\n        size_t t = m;\n        for (; t +  m <= length; t +=  m) {\n            // we compute something like\n            // acc+= polyvalue * acc + h1\n            acc =  mul128by128to128_lazymod127(polyvalue,acc);\n            const __m128i h1 =  __clmulhalfscalarproductwithoutreduction(rs64, string+t,m);\n            acc = _mm_xor_si128(acc,h1);\n        }\n        const int remain = length - t;  // number of completely filled words\n\n        if (remain != 0) {\n            // we compute something like\n            // acc+= polyvalue * acc + h1\n            acc = mul128by128to128_lazymod127(polyvalue, acc);\n            if (lengthbyte % sizeof(uint64_t) == 0) {\n                const __m128i h1 =\n                    __clmulhalfscalarproductwithtailwithoutreduction(rs64,\n                            string + t, remain);\n                acc = _mm_xor_si128(acc, h1);\n            } else {\n                const uint64_t lastword = createLastWord(lengthbyte,\n                                          (string + length));\n                const __m128i h1 =\n                    __clmulhalfscalarproductwithtailwithoutreductionWithExtraWord(\n                        rs64, string + t, remain, lastword);\n                acc = _mm_xor_si128(acc, h1);\n            }\n        } else if (lengthbyte % sizeof(uint64_t) != 0) {// added to address issue #2 raised by Eik List\n            // there are no completely filled words left, but there is one partial word.\n            acc = mul128by128to128_lazymod127(polyvalue, acc);\n            const uint64_t lastword = createLastWord(lengthbyte, (string + length));\n            const __m128i h1 = __clmulhalfscalarproductOnlyExtraWord( rs64, lastword);\n            acc = _mm_xor_si128(acc, h1);\n        }\n\n        const __m128i finalkey = _mm_load_si128(rs64 + m128neededperblock + 1);\n        const uint64_t keylength = *(const uint64_t *)(rs64 + m128neededperblock + 2);\n        return simple128to64hashwithlength(acc,finalkey,keylength, (uint64_t)lengthbyte);\n    } else { // short strings\n        if(lengthbyte % sizeof(uint64_t) == 0) {\n            __m128i  acc = __clmulhalfscalarproductwithtailwithoutreduction(rs64, string, length);\n            const uint64_t keylength = *(const uint64_t *)(rs64 + m128neededperblock + 2);\n            acc = _mm_xor_si128(acc,lazyLengthHash(keylength, (uint64_t)lengthbyte));\n#ifdef BITMIX\n            return fmix64(precompReduction64(acc)) ;\n#else\n            return precompReduction64(acc) ;\n#endif\n        }\n        const uint64_t lastword = createLastWord(lengthbyte, (string + length));\n        __m128i acc = __clmulhalfscalarproductwithtailwithoutreductionWithExtraWord(\n                          rs64, string, length, lastword);\n        const uint64_t keylength =  *(const uint64_t *)(rs64 + m128neededperblock + 2);\n        acc = _mm_xor_si128(acc,lazyLengthHash(keylength, (uint64_t)lengthbyte));\n#ifdef BITMIX\n        return fmix64(precompReduction64(acc)) ;\n#else\n        return precompReduction64(acc) ;\n#endif\n    }\n}\n```\n\nC Tests (the test cases used for the program under analysis):\n\n```c\nstatic void clhashavalanchetest() {\n    const int N = 1024;\n    char * array  = (char*)malloc(N);\n    char * array1  = (char*)malloc(N);\n\n    char *  rs = (char*)malloc(RANDOM_BYTES_NEEDED_FOR_CLHASH);\n    for(int k = 0; k<N; ++k) {\n        array[k] = 0;\n        array1[k] = 0;\n    }\n    for(int k = 0; k<RANDOM_BYTES_NEEDED_FOR_CLHASH; ++k) {\n        rs[k] = k+1-k*k;\n    }\n    int K = 16;\n    printf(\"[clhashavalanchetest] Testing CLHASH avalanche effect.\\n\");\n\n    for(int bytelength = 1; bytelength < K; ++bytelength ) {\n\n        for(int whichcase = 0; whichcase < 256; ++whichcase) {\n\n            for(int k = 0; k<bytelength; ++k) {\n                array[k] = whichcase;\n                array1[k] = whichcase + 35;\n            }\n            uint64_t orighash = clhash(rs, array, bytelength);\n            uint64_t orighash1 = clhash(rs, array1, bytelength);\n\n            for(int z = 0; z < 8*bytelength; ++z) {\n                flipbit(array,bytelength,z);\n                uint64_t newhash = clhash(rs, array, bytelength);\n                flipbit(array,bytelength,z);\n                assert(orighash != newhash);\n\n                flipbit(array1,bytelength,z);\n                uint64_t newhash1 = clhash(rs, array1, bytelength);\n                flipbit(array1,bytelength,z);\n                assert(orighash1 != newhash1);\n\n                if((unsigned int) bytelength <= sizeof(uint64_t))\n                    assert((orighash ^ newhash) == (orighash1 ^ newhash1));\n\n            }\n        }\n    }\n    free(array);\n    free(array1);\n    free(rs);\n    printf(\"Test passed! \\n\");\n}\n\nstatic void clhashtest() {\n    const int N = 1024;\n    char * array  = (char*)malloc(N);\n    char *  rs = (char*)malloc(RANDOM_BYTES_NEEDED_FOR_CLHASH);\n    for(int k = 0; k<N; ++k) {\n        array[k] = 0;\n    }\n    for(int k = 0; k < RANDOM_BYTES_NEEDED_FOR_CLHASH ; ++k) {\n        rs[k] = (char) (1-k);\n    }\n\n    printf(\"[clhashtest] checking that flipping a bit changes hash value with clhash \\n\");\n    for(int bit = 0; bit < 64; ++bit ) {\n        for(int length = (bit+8)/8; length <= (int)sizeof(uint64_t); ++length) {\n            uint64_t x = 0;\n            uint64_t orig = clhash(rs, (const char *)&x, length);\n            x ^= ((uint64_t)1) << bit;\n            uint64_t flip = clhash(rs, (const char *)&x, length);\n            assert(flip != orig);\n            x ^= ((uint64_t)1) << bit;\n            uint64_t back = clhash(rs, (const char *)&x, length);\n            assert(back == orig);\n        }\n    }\n\n    free(array);\n    free(rs);\n    printf(\"Test passed! \\n\");\n}\n\nstatic void clhashcollisiontest() {\n    printf(\"[clhashcollisiontest] Testing whether we can induce collisions by hacking the right bytes (Eik List's test).\\n\");\n    const size_t NUM_TRIALS = 10;\n    const size_t CLNH_NUM_BYTES_PER_BLOCK = 1024;\n    const uint8_t KEY_OFFSET = 0x63; // Anything to prevent that K = M\n\n    uint8_t* k = (uint8_t*)malloc(RANDOM_BYTES_NEEDED_FOR_CLHASH);\n    size_t j2;\n\n    // Fill key with some deterministic information\n    for (j2 = 0; j2 < RANDOM_BYTES_NEEDED_FOR_CLHASH; ++j2) {\n        k[j2] = (j2 + KEY_OFFSET) & 0xFF;\n    }\n\n    for (size_t i = 1; i < NUM_TRIALS; ++i) {\n        for (size_t j = 1; j <= sizeof(uint64_t); ++j) {\n            // #Bytes / block + x, with 1 <= x < 8\n            const uint64_t mlen = i * CLNH_NUM_BYTES_PER_BLOCK + j;\n            uint8_t* m = (uint8_t*)malloc(mlen);\n\n            for (j2 = 0; j2 < mlen; ++j2) {\n                m[j2] = j2 & 0xFF;\n            }\n\n            const uint64_t actual1 = clhash(k, (const char*)m, mlen);\n\n            // Change final byte\n            m[mlen-1] = (m[mlen-1] + 1) & 0xFF;\n\n            const uint64_t actual2 = clhash(k, (const char*)m, mlen);\n            const int are_equal = !memcmp(&actual1, &actual2, sizeof(uint64_t));\n\n            if(are_equal) printf(\"Testing %\" PRIu64 \" bytes, H1: %\" PRIX64 \", H2: %\" PRIX64 \", equal: %d \\n\", mlen, actual1, actual2, are_equal);\n            free(m);\n            assert(!are_equal); // strictly speaking this would not be a bug, but if it happens, it is very likely to be a bug!\n        }\n    }\n\n    free(k);\n    printf(\"Test passed! \\n\");\n}\n```\n\nRust test that fails (the test case that currently fails):\n```rust\nfn clhash_avalanche_test() {\nconst N: usize = 1024;\nlet mut array = vec![0u8; N];\nlet mut array1 = vec![0u8; N];\nlet mut rs = vec![0u64; RANDOM_BYTES_NEEDED_FOR_CLHASH];\nfor k in 0..RANDOM_BYTES_NEEDED_FOR_CLHASH {\nrs[k] = (k + 1 - k * k) as u64;\n}\nlet rs = [rs[0], rs[1]];\nlet rs_bytes: &[u8] = bytemuck::bytes_of(&rs);\nconst K: usize = 16;\nprintln!(\"[clhashavalanchetest] Testing CLHASH avalanche effect.\");\nfor bytelength in 1..K {\nfor whichcase in 0..256 {\nfor k in 0..bytelength {\narray[k] = whichcase as u8;\narray1[k] = (whichcase + 35) as u8;\n}\nlet orighash = clhash(rs_bytes, &array[..bytelength]);\nlet orighash1 = clhash(rs_bytes, &array1[..bytelength]);\nfor z in 0..8 * bytelength {\nflipbit(&mut array, z as u32);\nlet newhash = clhash(rs_bytes, &array[..bytelength]);\nflipbit(&mut array, z as u32);\nassert_ne!(orighash, newhash);\nflipbit(&mut array1, z as u32);\nlet newhash1 = clhash(rs_bytes, &array1[..bytelength]);\nflipbit(&mut array1, z as u32);\nassert_ne!(orighash1, newhash1);\nif bytelength <= std::mem::size_of::<u64>() {\nassert_eq!(orighash ^ newhash, orighash1 ^ newhash1);\n}\n}\n}\n}\nprintln!(\"Test passed!\");\n}\n\n#[test]\nfn clhash_test() {\nconst N: usize = 1024;\nlet mut array = vec![0u8; N];\nlet mut rs = vec![0u64; RANDOM_BYTES_NEEDED_FOR_CLHASH];\nfor k in 0..RANDOM_BYTES_NEEDED_FOR_CLHASH {\nrs[k] = (1 - k) as u64;\n}\n// convert the vec into a tuple of (&[u8], &[u8])\nlet rs = [rs[0], rs[1]];\nlet rs_bytes: &[u8] = bytemuck::bytes_of(&rs);\nprintln!(\"[clhashtest] checking that flipping a bit changes hash value with clhash\");\nfor bit in 0..64 {\nfor length in ((bit + 8) / 8)..=std::mem::size_of::<u64>() {\nlet mut x: u64 = 0;\nlet orig = clhash(rs_bytes, &x.to_le_bytes()[..length]);\nx ^= 1 << bit;\nlet flip = clhash(rs_bytes, &x.to_le_bytes()[..length]);\nassert_ne!(flip, orig);\nx ^= 1 << bit;\nlet back = clhash(rs_bytes, &x.to_le_bytes()[..length]);\nassert_eq!(back, orig);\n}\n}\nprintln!(\"Test passed!\");\n}\n#[test]\nfn clhash_collision_test() {\nprintln!(\"[clhashcollisiontest] Testing whether we can induce collisions by hacking the right bytes (Eik List's test).\");\nconst NUM_TRIALS: usize = 10;\nconst CLNH_NUM_BYTES_PER_BLOCK: usize = 1024;\nconst KEY_OFFSET: u8 = 0x63;\nlet mut k = vec![0u64; RANDOM_BYTES_NEEDED_FOR_CLHASH];\nfor j2 in 0..RANDOM_BYTES_NEEDED_FOR_CLHASH {\nk[j2] = (j2 + KEY_OFFSET as usize) as u64 & 0xFF;\n}\nlet k = (k[0], k[1]);\nfor i in 1..NUM_TRIALS {\nfor j in 1..=std::mem::size_of::<u64>() {\nlet mlen = i * CLNH_NUM_BYTES_PER_BLOCK + j;\nlet mut m = vec![0u8; mlen];\nfor j2 in 0..mlen {\nm[j2] = (j2 & 0xFF) as u8;\n}\nlet k = [k.0, k.1];\nlet actual1 = clhash(bytemuck::bytes_of(&k), &m);\nm[mlen - 1] = (m[mlen - 1] + 1) & 0xFF;\nlet actual2 = clhash(bytemuck::bytes_of(&k), &m);\nlet are_equal = actual1 == actual2;\nif are_equal {\nprintln!(\"Testing {} bytes, H1: {:X}, H2: {:X}, equal: {}\", mlen, actual1, actual2, are_equal);\n}\nassert!(!are_equal);\n}\n}\nprintln!(\"Test passed!\");\n}\n```\n\n\nRust interface files (types, functions, signatures you MUST use to build test fixtures):\n```rust\npub fn clhash(random: &[u8], stringbyte: &[u8]) -> u64 {\nunimplemented!();\n}\n```\n\nPlease provide the final code in ```rust ``` tags"
}