{
    "name": "avalanche",
    "avalanche.c": "/* avalanche.c\n */\n#include \"avalanche.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid avalanche(hash_f hash, FILE* ins, uint64_t max_iter, matrix_t* results)\n{\n    size_t key_size = results->n_rows / 8;\n    size_t hash_words = results->n_cols / 32;\n\n    char* key = malloc(key_size);\n    uint32_t* hvalue = malloc(4 * hash_words);\n    uint32_t* htemp = malloc(4 * hash_words);\n\n    uint64_t key_count = 0;\n    while (key_count < max_iter) {\n        size_t n_in = fread(key, 1, key_size, ins);\n        if (n_in < key_size)\n            break;\n\n        hash(key, key_size, hvalue);\n        ++key_count;\n\n        for (size_t i_byte = 0; i_byte < key_size; ++i_byte) {\n            for (size_t i_bit = 0; i_bit < 8; ++i_bit) {\n                size_t row = i_byte * 8 + i_bit;\n\n                // flip the i-th bit of this byte and re-hash\n                char i_mask = 0x80 >> i_bit;\n                key[i_byte] ^= i_mask;\n                hash(key, key_size, htemp);\n                key[i_byte] ^= i_mask;\n\n                for (size_t j_word = 0; j_word < hash_words; ++j_word) {\n                    for (size_t j_bit = 0; j_bit < 32; ++j_bit) {\n                        size_t col = j_word * 32 + j_bit;\n\n                        // test whether hvalue & htemp differ at j-th bit.\n                        uint32_t j_mask = 0x80000000 >> j_bit;\n                        if ((hvalue[j_word] ^ htemp[j_word]) & j_mask) {\n                            double curr = MATRIX_GET(results, row, col);\n                            MATRIX_SET(results, row, col, curr + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    free(key);\n    free(hvalue);\n    free(htemp);\n\n    if (key_count) {\n        // convert matrix entries to the mean values\n        size_t n_vals = results->n_cols * results->n_rows;\n        for (size_t k = 0; k < n_vals; ++k)\n            results->vals[k] /= key_count;\n    }\n}\n\nmatrix_t* matrix_alloc(size_t n_rows, size_t n_cols) {\n    matrix_t* M = malloc(sizeof(matrix_t));\n    M->n_rows = n_rows;\n    M->n_cols = n_cols;\n    M->vals = calloc(sizeof(double), n_cols * n_rows);\n    return M;\n}\n\nvoid matrix_free(matrix_t* M) {\n    if (M == NULL)\n        return;\n    free(M->vals);\n    free(M);\n    M = NULL;\n}\n\nvoid matrix_fprintf(FILE* fout, const char* format, const matrix_t* M) {\n    if (M == NULL)\n        return;\n\n    for (size_t r = 0; r < M->n_rows; ++r) {\n        for (size_t c = 0; c < M->n_cols; ++c) {\n            fprintf(fout, format, MATRIX_GET(M, r, c));\n        }\n        fprintf(fout, \"\\n\");\n    }\n}\n",
    "avalanche.h": "#ifndef AVALANCHE_H\n#define AVALANCHE_H\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/** Protypical hash function: converts a `key` of bytes to a hash value,\n represented as an array of 32-bit blocks.\n */\ntypedef void (* hash_f)(char* key, size_t key_len, uint32_t* hash_value);\n\n/** Simple matrix structure.\n */\ntypedef struct {\n    size_t n_rows, n_cols;\n    double* vals;\n} matrix_t;\n\n// macros for enforcing row-major layout of matrix\n#define MATRIX_GET(M, ROW, COL) ((M)->vals[(ROW) * (M)->n_cols + (COL)])\n#define MATRIX_SET(M, ROW, COL, VAL) ((M)->vals[(ROW) * (M)->n_cols + (COL)] = (VAL))\n\n/** Avalanche test for hash function.\n\n All test keys are read successively from the stream `ins`, and the probability\n that flipping i-th input bit affects the j-th output bit is recorded as the\n ij-th entry of the matrix.\n\n All keys read have the same length, so that the key length and size of the\n hash value (in words) are parameterized by the row and columns of the mattrix.\n */\nvoid avalanche(hash_f hash, FILE* ins, uint64_t max_iter, matrix_t* results);\n\nmatrix_t* matrix_alloc(size_t n_rows, size_t n_cols);\nvoid matrix_free(matrix_t*);\nvoid matrix_fprintf(FILE* fout, const char* format, const matrix_t*);\n\n#endif // AVALANCHE_H\n",
    "c": "",
    "c_pre_post_conditions": "Function: avalanche\nPre-condition:\n  \u2022 hash \u2260 NULL and points to a well\u2010behaved hash function\n  \u2022 ins \u2260 NULL and corresponds to an open readable stream\n  \u2022 max_iter \u2265 0\n  \u2022 results \u2260 NULL\n  \u2022 results->vals points to an array of at least\n      results->n_rows * results->n_cols doubles\n  \u2022 results->n_rows is a multiple of 8\n  \u2022 results->n_cols is a multiple of 32\n  \u2022 All entries in results->vals are initialized (typically to 0.0)\n\nPost-condition:\n  \u2022 results->n_rows and results->n_cols are unchanged\n  \u2022 Memory allocated internally for key, hvalue, htemp has been freed\n  \u2022 Suppose key_count full keys were read (0 \u2264 key_count \u2264 max_iter).\n    \u2013 For each input\u2010bit index r\u2208[0..n_rows\u22121] and output\u2010bit index c\u2208[0..n_cols\u22121],\n      results->vals[r * n_cols + c]\n        = (number of times flipping bit r changed bit c in the hash)\n          / key_count\n    \u2013 Equivalently, each entry is the empirical probability in [0.0..1.0].\n  \u2022 If key_count==0 (no full key was read), then results->vals remains exactly as it was on entry.\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nFunction: matrix_alloc\nPre-condition:\n  \u2022 n_rows \u2265 0, n_cols \u2265 0  (zero dimensions are allowed; calloc(0) is well-defined)\n\nPost-condition:\n  \u2022 Returns M \u2260 NULL (unless malloc/calloc fails, in which case it returns NULL)\n  \u2022 M->n_rows == n_rows\n  \u2022 M->n_cols == n_cols\n  \u2022 M->vals points to a newly allocated array of n_rows*n_cols doubles\n  \u2022 All entries in M->vals are zero (calloc\u2019ed)\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nFunction: matrix_free\nPre-condition:\n  \u2022 M is either NULL or was returned by a previous matrix_alloc\n\nPost-condition:\n  \u2022 If M == NULL, does nothing\n  \u2022 Otherwise:\n      \u2013 M->vals has been freed\n      \u2013 M itself has been freed\n  \u2022 Note: The local parameter M is set to NULL, but the caller\u2019s pointer is not\n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nFunction: matrix_fprintf\nPre-condition:\n  \u2022 fout \u2260 NULL and is an open writable stream\n  \u2022 format \u2260 NULL and is a valid printf\u2010style format for a double\n  \u2022 M \u2260 NULL and was returned by matrix_alloc\n  \u2022 M->vals is a valid array of length M->n_rows * M->n_cols\n\nPost-condition:\n  \u2022 Writes exactly M->n_rows lines of text to fout\n  \u2022 On each line r, prints M->n_cols numbers:\n      fprintf(fout, format, M->vals[r*M->n_cols + c]);\n  \u2022 M itself (its fields and M->vals) is not modified",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\nFunction: function_name\nPre-condition: description of the pre-condition\nPost-condition: description of the post-condition\n```\n\nHere is the code:\n{{avalanche.c}}\n```c\n// header file\n/*#ifndef AVALANCHE_H\n#define AVALANCHE_H\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/** Protypical hash function: converts a `key` of bytes to a hash value,\n represented as an array of 32-bit blocks.\n */\ntypedef void (* hash_f)(char* key, size_t key_len, uint32_t* hash_value);\n\n/** Simple matrix structure.\n */\ntypedef struct {\n    size_t n_rows, n_cols;\n    double* vals;\n} matrix_t;\n\n// macros for enforcing row-major layout of matrix\n#define MATRIX_GET(M, ROW, COL) ((M)->vals[(ROW) * (M)->n_cols + (COL)])\n#define MATRIX_SET(M, ROW, COL, VAL) ((M)->vals[(ROW) * (M)->n_cols + (COL)] = (VAL))\n\n/** Avalanche test for hash function.\n\n All test keys are read successively from the stream `ins`, and the probability\n that flipping i-th input bit affects the j-th output bit is recorded as the\n ij-th entry of the matrix.\n\n All keys read have the same length, so that the key length and size of the\n hash value (in words) are parameterized by the row and columns of the mattrix.\n */\nvoid avalanche(hash_f hash, FILE* ins, uint64_t max_iter, matrix_t* results);\n\nmatrix_t* matrix_alloc(size_t n_rows, size_t n_cols);\nvoid matrix_free(matrix_t*);\nvoid matrix_fprintf(FILE* fout, const char* format, const matrix_t*);\n\n#endif // AVALANCHE_H\n*/\n/* avalanche.c\n */\n#include \"avalanche.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid avalanche(hash_f hash, FILE* ins, uint64_t max_iter, matrix_t* results)\n{\n    size_t key_size = results->n_rows / 8;\n    size_t hash_words = results->n_cols / 32;\n\n    char* key = malloc(key_size);\n    uint32_t* hvalue = malloc(4 * hash_words);\n    uint32_t* htemp = malloc(4 * hash_words);\n\n    uint64_t key_count = 0;\n    while (key_count < max_iter) {\n        size_t n_in = fread(key, 1, key_size, ins);\n        if (n_in < key_size)\n            break;\n\n        hash(key, key_size, hvalue);\n        ++key_count;\n\n        for (size_t i_byte = 0; i_byte < key_size; ++i_byte) {\n            for (size_t i_bit = 0; i_bit < 8; ++i_bit) {\n                size_t row = i_byte * 8 + i_bit;\n\n                // flip the i-th bit of this byte and re-hash\n                char i_mask = 0x80 >> i_bit;\n                key[i_byte] ^= i_mask;\n                hash(key, key_size, htemp);\n                key[i_byte] ^= i_mask;\n\n                for (size_t j_word = 0; j_word < hash_words; ++j_word) {\n                    for (size_t j_bit = 0; j_bit < 32; ++j_bit) {\n                        size_t col = j_word * 32 + j_bit;\n\n                        // test whether hvalue & htemp differ at j-th bit.\n                        uint32_t j_mask = 0x80000000 >> j_bit;\n                        if ((hvalue[j_word] ^ htemp[j_word]) & j_mask) {\n                            double curr = MATRIX_GET(results, row, col);\n                            MATRIX_SET(results, row, col, curr + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    free(key);\n    free(hvalue);\n    free(htemp);\n\n    if (key_count) {\n        // convert matrix entries to the mean values\n        size_t n_vals = results->n_cols * results->n_rows;\n        for (size_t k = 0; k < n_vals; ++k)\n            results->vals[k] /= key_count;\n    }\n}\n\nmatrix_t* matrix_alloc(size_t n_rows, size_t n_cols) {\n    matrix_t* M = malloc(sizeof(matrix_t));\n    M->n_rows = n_rows;\n    M->n_cols = n_cols;\n    M->vals = calloc(sizeof(double), n_cols * n_rows);\n    return M;\n}\n\nvoid matrix_free(matrix_t* M) {\n    if (M == NULL)\n        return;\n    free(M->vals);\n    free(M);\n    M = NULL;\n}\n\nvoid matrix_fprintf(FILE* fout, const char* format, const matrix_t* M) {\n    if (M == NULL)\n        return;\n\n    for (size_t r = 0; r < M->n_rows; ++r) {\n        for (size_t c = 0; c < M->n_cols; ++c) {\n            fprintf(fout, format, MATRIX_GET(M, r, c));\n        }\n        fprintf(fout, \"\\n\");\n    }\n}\n```\n\n\nPlease extract the invariants from the code.\n"
}