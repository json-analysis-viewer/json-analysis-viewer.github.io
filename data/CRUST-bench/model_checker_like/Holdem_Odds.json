{
    "name": "Holdem_Odds",
    "manual_invs": "```rust\nuse std::collections::HashSet;\nuse crate::cards::Card;\nuse crate::{new_deck, deck_shuffle, CARDS_PER_DECK};\n\n/// A simple model\u2010checker style function that validates\n/// core invariants of `new_deck` and `deck_shuffle`.\npub fn check_invariants() {\n    // 1. new_deck produces exactly 52 cards.\n    let deck = new_deck();\n    assert_eq!(\n        deck.len(),\n        CARDS_PER_DECK,\n        \"Invariant failed: new_deck returned {} cards, expected {}\",\n        deck.len(),\n        CARDS_PER_DECK\n    );\n\n    // 2. All cards in the deck are unique.\n    {\n        let mut seen = HashSet::new();\n        for card in &deck {\n            assert!(\n                seen.insert(card),\n                \"Invariant failed: duplicate card found in new_deck: {:?}\",\n                card\n            );\n        }\n    }\n\n    // 3. deck_shuffle does not change the size of the deck.\n    let mut shuffled = deck.clone();\n    deck_shuffle(&mut shuffled);\n    assert_eq!(\n        shuffled.len(),\n        deck.len(),\n        \"Invariant failed: deck_shuffle changed deck length from {} to {}\",\n        deck.len(),\n        shuffled.len()\n    );\n\n    // 4. deck_shuffle preserves the exact multiset of cards.\n    //    (i.e., no card is lost, no card is duplicated)\n    {\n        // After shuffle, every original card must still be present.\n        for card in &deck {\n            assert!(\n                shuffled.contains(card),\n                \"Invariant failed: deck_shuffle lost card {:?}\",\n                card\n            );\n        }\n        // And the shuffled deck must still have all-unique cards.\n        let mut seen_after = HashSet::new();\n        for card in &shuffled {\n            assert!(\n                seen_after.insert(card),\n                \"Invariant failed: duplicate card after deck_shuffle: {:?}\",\n                card\n            );\n        }\n    }\n}\n\n// Invariants enforced:\n// - new_deck() returns exactly CARDS_PER_DECK cards.\n// - new_deck() contains no duplicate cards.\n// - deck_shuffle() preserves deck length.\n// - deck_shuffle() preserves the exact multiset of cards (no losses or duplicates).\n```",
    "rri_prompt": "Task: Extract invariants from C  code and emit a Rust function called `check_invariants`\nRole: You are a rigorous program analyst. You will study a C program and its Rust interface files. Your job is to derive invariants of the program and implement a Rust model checker function named check_invariants.\nDo any reasoning internally; only output the requested sections and code.\n\nInputs\n\n1. C function under analysis.\n2. C test case that is currently failing.\n3. Rust interface relevant to the C function.\n\nYou must implement a single Rust model checker-style function named `check_invariants`:\n1. Perform non-trivial invariant checks derived from the C program\u2019s behavior (no placeholders).\n2. Use `assert!` / `assert_eq!` with clear failure messages that include key values.\n3. You should not add unit tests but rather infer general invariants that hold for all valid states of the program.\n\nIf some invalid states cannot be constructed via safe APIs, then:\n\n1. Assert that the public constructors/validators correctly reject them (e.g., expect Err), or\n2. Skip those specific negative cases and document why in a short code comment (no speculation, just interface-limited reasoning).\n3. A brief bullet list titled \u201cInvariants enforced\u201d summarizing each invariant in plain language (no derivations or chain-of-thought; just the final invariants).\n\nConstraints & style\n\n1. Use only items available in the Rust interface (no new public types or deps).\n2. Prefer safe Rust; do not use unsafe unless the interface explicitly requires it.\n3. No logging/printing. No randomness. No external crates.\n4. If the interface already includes a validator that returns Result, you may call it and assert on Ok/Err instead of re-implementing internals.\n\nImplementation checklist\n1. Read the Rust interface to understand how to construct states.\n2. From the C code, enumerate and infer candidate invariants. Keep only those that must hold for all reachable states.\n3. Valid cases: assert the invariant holds.\n\nNow you will be provided with the C source code and Rust interface definitions.\n\nC source (program under analysis):\n```c\n// deck.c\n#include <stdbool.h>\n#include <string.h>\n\n#include \"bucket.h\"\n#include \"cards.h\"\n#include \"hands.h\"\n\n\nstatic bool HandIsStraightFlush(const Card*);\nstatic bool HandIsWheelFlush(const Card*);\nstatic bool HandIsFourOfAKind(const Card*);\nstatic bool HandIsFullHouse(const Card*);\nstatic bool HandIsFlush(const Card*);\nstatic bool HandIsStraight(const Card*);\nstatic bool HandIsWheel(const Card*);\nstatic bool HandIsThreeOfAKind(const Card*);\nstatic bool HandIsTwoPair(const Card*);\nstatic bool HandIsPair(const Card*);\nstatic bool HandIsHighCard(const Card*);\n\n\n/*\n * Compare two hands and return:\n *   < 0 if hand1 < hand2\n *     0 if hand1 = hand2\n *   > 0 if hand1 > hand2\n */\nint HandCompare(Card* hand1, Card* hand2) {\n    HandType hand1_type = HandClassify(hand1);\n    HandType hand2_type = HandClassify(hand2);\n    int diff = hand1_type - hand2_type;\n\n    if (diff != 0)\n        return diff;\n\n    // Tie breaker when two hands of the same type.\n    // Find the strongest hand by going card-by-card\n    // until one card is higher.  If no card is higher\n    // we have a tie.\n    for (size_t i = 0; i < HAND_LENGTH; ++i) {\n        int cmp = CardCompare(&hand1[i], &hand2[i]);\n        if (cmp != 0)\n            return cmp;\n    }\n    return 0;\n}\n\n\n/*\n * Sort the cards by the number of cards of the same\n * rank that appear in the hand and then by rank from\n * strongest to weakest.\n */\nvoid HandSort(Card* hand) {\n    Bucket buckets[RANKS_PER_DECK] = {{{{InvalidRank, InvalidSuit}}, 0}};\n\n    // Copy the cards into the buckets.\n    for (size_t i = 0; i < HAND_LENGTH; ++i) {\n        size_t bucket_index = hand[i].rank - 1;\n        BucketAdd(&buckets[bucket_index], &hand[i]);\n    }\n\n    size_t index = 0; // Index of the next card to insert in hand\n\n    // Search for buckets with 4 cards first, then 3, 2 and 1.\n    for (size_t count = 4; count > 0; --count) {\n\n        // Go from the highest rank to the lowest rank when inserting into hand\n        for (size_t j = RANKS_PER_DECK - 1; j != (size_t)-1; --j) {\n\n            // If the number of cards in the bucket matches the number\n            // we're looking for, insert them into the hand.\n            if (buckets[j].count == count) {\n                memcpy(&hand[index], &buckets[j].cards, sizeof(Card) * count);\n                index += count;\n            }\n        }\n    }\n}\n\n\n\n/*\n * Find the type of the hand that's been given to us.  Go\n * from strongest to weakest type; this assures us that a\n * full house is not classified as merely a pair.\n *\n * The cards *must* be sorted in order for this function\n * to work properly.\n */\nHandType HandClassify(Card* cards) {\n    if (HandIsFlush(cards)) {\n        if (HandIsStraight(cards)) return StraightFlush;\n        if (HandIsWheel(cards))    return WheelFlush;\n        return Flush;\n    }\n    else {\n        if (HandIsFourOfAKind(cards))   return FourOfAKind;\n        if (HandIsFullHouse(cards))     return FullHouse;\n        if (HandIsStraight(cards))      return Straight;\n        if (HandIsWheel(cards))         return Wheel;\n        if (HandIsThreeOfAKind(cards))  return ThreeOfAKind;\n        if (HandIsTwoPair(cards))       return TwoPair;\n        if (HandIsPair(cards))          return Pair;\n        return HighCard;\n    }\n}\n\n\n/*\n * A valid hand has 5 cards in decreasing order.\n */\nbool HandIsValid(const Card* cards) {\n    for (size_t i = 0; i < HAND_LENGTH; ++i)\n        if (!CardIsValid(&cards[i]))\n            return false;\n\n    return true;\n}\n\n\n/*\n * A straight flush is a straight _and_ a flush.\n */\nstatic bool HandIsStraightFlush(const Card* cards) {\n    return HandIsStraight(cards) && HandIsFlush(cards);\n}\n\n\n/*\n * A wheel flush is a wheel _and_ a flush.\n */\nstatic bool HandIsWheelFlush(const Card* cards) {\n    return HandIsWheel(cards) && HandIsFlush(cards);\n}\n\n\n/*\n * Four of a kind is when 4 of the 5 cards have the same rank.\n */\nstatic bool HandIsFourOfAKind(const Card* cards) {\n    // If the cards are properly ordered, only in the\n    // case of quads should the first and fourth card\n    // be of the same rank.\n    return cards[0].rank == cards[3].rank;\n}\n\n\n/*\n * A full house is when a hand is composed of a pair and three of a\n * kind.\n */\nstatic bool HandIsFullHouse(const Card* cards) {\n    // If the cards are properly ordered, only in the\n    // case of a full house should the first and third\n    // card be the same and the last two cards be the same.\n    return cards[0].rank == cards[2].rank\n        && cards[3].rank == cards[4].rank;\n}\n\n\n/*\n * A flush is a hand where all cards have the same suit.\n */\nstatic bool HandIsFlush(const Card* cards) {\n    for (size_t i = 1; i < HAND_LENGTH; ++i)\n        if (cards[i].suit != cards[0].suit)\n            return false;\n\n    return true;\n}\n\n\n/*\n * A straight is a hand where all cards are successive.  The Ace\n * is considered both high and low, meaning it can follow a King\n * or precede a Deuce.\n */\nstatic bool HandIsStraight(const Card* cards) {\n    // If the cards are properly ordered, if the first\n    // card's rank is equal to the rank of the next card\n    // plus 1 (meaning they have different ranks) and if\n    // the fifth card is 4 ranks lower than the first card,\n    // then we have a straight.\n    return cards[0].rank == cards[1].rank + 1\n        && cards[0].rank == cards[4].rank + 4;\n}\n\n\n/*\n * A wheel is a straight from A to 5\n */\nstatic bool HandIsWheel(const Card* cards) {\n       return cards[0].rank == Ace && cards[1].rank == Five;\n}\n\n\n/*\n * A hand is three of a kind if three cards have the same rank\n * and the other two cards don't match.\n */\nstatic bool HandIsThreeOfAKind(const Card* cards) {\n    // If the cards are properly ordered and a full house\n    // wasn't found, if the first and third cards are of\n    // the same rank, we have trips.\n    return cards[0].rank == cards[2].rank;\n}\n\n\n/*\n * A hand has two pairs if two sets of two cards share\n * the same rank and the other card doesn't match.\n */\nstatic bool HandIsTwoPair(const Card* cards) {\n    // If the4 cards are properly ordered and quads\n    // haven't been found, if the third and fourth\n    // cards are of the same rank, we have two pairs.\n    return cards[2].rank == cards[3].rank;\n}\n\n\n/*\n * A hand is a pair if two cards share the same rank\n * and the other three cards all have different ranks.\n */\nstatic bool HandIsPair(const Card* cards) {\n    return cards[0].rank == cards[1].rank;\n}\n\n\n/*\n * A hand is high card if there is no pair, no straight or\n * no flush.  (Any hand is a high card hand)\n */\nstatic bool HandIsHighCard(const Card* cards) {\n    (void)cards;\n    return true;\n}\n```\n\nC Tests (the test cases used for the program under analysis):\n\n```c\nvoid TestNewDeck(CuTest* tc) {\n    Card deck[CARDS_PER_DECK];\n    NewDeck(deck, NULL, 0);\n\n    size_t i = 0;\n    char cardStr1[3];\n    char cardStr2[3];\n    char output[OUTPUT_LENGTH];\n\n    for (Rank r = Deuce; r <= Ace; ++r) {\n        for (Suit s = Club; s <= Spade; ++s) {\n            Card c = NewCard(r, s);\n            CardToString(cardStr1, &c);\n            CardToString(cardStr2, &deck[i]);\n            snprintf(output, OUTPUT_LENGTH, \"%s != %s\", cardStr1, cardStr2);\n            CuAssert(tc, output, CardCompare(&c, &deck[i]) == 0);\n            i++;\n        }\n    }\n\n}\n```\n\nRust test that fails (the test case that currently fails):\n```rust\nfn test_new_deck() {\n    let deck = new_deck();\n    let mut expected_deck = Vec::new();\n    for suit in [Suit::Club, Suit::Diamond, Suit::Heart, Suit::Spade] {\n        for rank in [Rank::Deuce, Rank::Trey, Rank::Four, Rank::Five, Rank::Six, Rank::Seven, Rank::Eight,\n                     Rank::Nine, Rank::Ten, Rank::Jack, Rank::Queen, Rank::King, Rank::Ace] {\n            expected_deck.push(Card::new(rank, suit));\n        }\n    }\n    assert_eq!(deck, expected_deck, \"Deck is not properly initialized\");\n}\n```\n\n\nRust interface files (types, functions, signatures you MUST use to build test fixtures):\n```rust\nuse rand::seq::SliceRandom;\nuse rand::thread_rng;\nuse crate::cards::{Card, RANKS_PER_DECK, SUITS_PER_DECK, Rank, Suit};\npub const CARDS_PER_DECK: usize = 52;\npub fn new_deck() -> Vec<Card> {\n    unimplemented!()\n}\npub fn deck_shuffle(deck: &mut Vec<Card>) {\n    unimplemented!()\n}\n```\n\nPlease provide the final code in ```rust ``` tags"
}