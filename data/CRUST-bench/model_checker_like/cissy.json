{
    "name": "cissy",
    "manual_invs": "```rust\nuse std::panic::catch_unwind;\n\npub fn check_invariants() {\n    // 1) Public preconditions: start must be > 0, end >= start.\n    //    Passing invalid parameters should panic.\n    assert!(\n        catch_unwind(|| RangeElement::add_start_end(0, 1, None)).is_err(),\n        \"add_start_end(0,1, None) did not panic on start == 0\"\n    );\n    assert!(\n        catch_unwind(|| RangeElement::add_start_end(5, 4, None)).is_err(),\n        \"add_start_end(5,4, None) did not panic on end < start\"\n    );\n\n    // 2) A valid single-element range (start == end) prints as \"[start]\".\n    let single = RangeElement::add_start_end(7, 7, None);\n    let mut buf = String::new();\n    RangeElement::list_to_string(&mut buf, 128, &single);\n    assert_eq!(\n        buf, \"[7]\",\n        \"Single-element range must be printed as [7], got `{}`\",\n        buf\n    );\n\n    // 3) A valid start\u2013end range (start < end) prints as \"[start-end]\".\n    let se = RangeElement::add_start_end(5, 10, None);\n    buf.clear();\n    RangeElement::list_to_string(&mut buf, 128, &se);\n    assert_eq!(\n        buf, \"[5-10]\",\n        \"Start\u2013end range must be printed as [5-10], got `{}`\",\n        buf\n    );\n\n    // 4) Adding a second non-overlapping range appends in order.\n    let mut seq = RangeElement::add_start_end(1, 2, None);\n    seq = RangeElement::add_start_end(3, 4, seq);\n    buf.clear();\n    RangeElement::list_to_string(&mut buf, 128, &seq);\n    assert_eq!(\n        buf, \"[1-2][3-4]\",\n        \"Two appended ranges must preserve order, got `{}`\",\n        buf\n    );\n\n    // 5) add_single is equivalent to add_start_end with start == end.\n    let mut via_single = RangeElement::add_single(42, None);\n    let via_se   = RangeElement::add_start_end(42, 42, None);\n    buf.clear();\n    RangeElement::list_to_string(&mut buf, 128, &via_single);\n    let mut buf2 = String::new();\n    RangeElement::list_to_string(&mut buf2, 128, &via_se);\n    assert_eq!(\n        buf, buf2,\n        \"add_single(42) and add_start_end(42,42) must yield same repr, got `{}` vs `{}`\",\n        buf, buf2\n    );\n\n    // 6) greater_equal range prints as \"[start-]\" and appends at end.\n    let ge = RangeElement::add_greater_equal(8, None);\n    buf.clear();\n    RangeElement::list_to_string(&mut buf, 128, &ge);\n    assert_eq!(\n        buf, \"[8-]\",\n        \"greater_equal range must be printed as [8-], got `{}`\",\n        buf\n    );\n    // and if appended to an existing list, it appears last\n    let mut mix = seq.clone();\n    mix = RangeElement::add_greater_equal(99, mix);\n    buf.clear();\n    RangeElement::list_to_string(&mut buf, 128, &mix);\n    assert!(\n        buf.ends_with(\"[99-]\"),\n        \"greater_equal appended must appear last, got `{}`\",\n        buf\n    );\n\n    // 7) parse_int_ranges produces the same sequence as manual adds.\n    let parsed = RangeElement::parse_int_ranges(\"2,2-4,7-,9\");\n    let mut manual = None;\n    manual = RangeElement::add_single(2, manual);\n    manual = RangeElement::add_start_end(2, 4, manual);\n    manual = RangeElement::add_greater_equal(7, manual);\n    manual = RangeElement::add_start_end(9, 9, manual);\n    buf.clear();\n    RangeElement::list_to_string(&mut buf, 128, &parsed);\n    let mut buf3 = String::new();\n    RangeElement::list_to_string(&mut buf3, 128, &manual);\n    assert_eq!(\n        buf, buf3,\n        \"parse_int_ranges and manual construction must match, got `{}` vs `{}`\",\n        buf, buf3\n    );\n}\n\n/// Invariants enforced:\n/// - add_start_end panics if start == 0 or end < start.\n/// - Ranges with start == end print as \u201c[start]\u201d; with start < end print as \u201c[start-end]\u201d.\n/// - add_single(start) \u2261 add_start_end(start, start).\n/// - add_greater_equal(start) prints as \u201c[start-]\u201d and always occupies the final position.\n/// - Sequence of add_* calls preserves insertion order.\n/// - parse_int_ranges yields exactly the same sequence and print\u2010out as equivalent manual adds.\n```",
    "rri_prompt": "Task: Extract invariants from C  code and emit a Rust function called `check_invariants`\nRole: You are a rigorous program analyst. You will study a C program and its Rust interface files. Your job is to derive invariants of the program and implement a Rust model checker function named check_invariants.\nDo any reasoning internally; only output the requested sections and code.\n\nInputs\n\n1. C function under analysis.\n2. C test case that is currently failing.\n3. Rust interface relevant to the C function.\n\nYou must implement a single Rust model checker-style function named `check_invariants`:\n1. Perform non-trivial invariant checks derived from the C program\u2019s behavior (no placeholders).\n2. Use `assert!` / `assert_eq!` with clear failure messages that include key values.\n3. You should not add unit tests but rather infer general invariants that hold for all valid states of the program.\n\nIf some invalid states cannot be constructed via safe APIs, then:\n\n1. Assert that the public constructors/validators correctly reject them (e.g., expect Err), or\n2. Skip those specific negative cases and document why in a short code comment (no speculation, just interface-limited reasoning).\n3. A brief bullet list titled \u201cInvariants enforced\u201d summarizing each invariant in plain language (no derivations or chain-of-thought; just the final invariants).\n\nConstraints & style\n\n1. Use only items available in the Rust interface (no new public types or deps).\n2. Prefer safe Rust; do not use unsafe unless the interface explicitly requires it.\n3. No logging/printing. No randomness. No external crates.\n4. If the interface already includes a validator that returns Result, you may call it and assert on Ok/Err instead of re-implementing internals.\n\nImplementation checklist\n1. Read the Rust interface to understand how to construct states.\n2. From the C code, enumerate and infer candidate invariants. Keep only those that must hold for all reachable states.\n3. Valid cases: assert the invariant holds.\n\nNow you will be provided with the C source code and Rust interface definitions.\n\nC source (program under analysis):\n```c\nstruct rangeElement* rangeCreate() {\n  struct rangeElement* ptr = malloc(sizeof(struct rangeElement));\n  if (ptr == NULL) {\n    fprintf(stderr, \"rangeCreate: malloc error\\n\");\n    exit(-1);\n  }\n  ptr->start = -1;\n  ptr->end = -1;\n  ptr->next = NULL;\n  return ptr;\n}\n\n// pass NULL list to create new list\n/**\n* add a n-m range to the list\n*\n* Add start-end range.  Create a new list if necessary\n*\n* @param start beginning \n* @param end ending\n* @param startOfList list\n* @return list\n*/\nstruct rangeElement* rangeAddStartEnd(uint32_t start, uint32_t end, struct rangeElement* startOfList) {\n  assert(start > 0);\n  assert(end >= start);\n  if (startOfList == NULL) {\n    startOfList = rangeCreate();\n    startOfList->start = start;\n    if (start == end) {\n      startOfList->rangetype = SINGLE;\n    }\n    else {\n      startOfList->rangetype = STARTEND;\n      startOfList->end = end;\n    }\n    return startOfList;\n  }\n  struct rangeElement* ptr = startOfList;\n  //advance to the end of list\n  while (ptr->next != NULL) {\n    ptr = ptr->next;\n  }\n  ptr->next = rangeCreate();\n  ptr = ptr->next;\n  ptr->start = start;\n  if (end == start) {\n    ptr->rangetype = SINGLE;\n  }\n  else {\n    ptr->rangetype = STARTEND;\n    ptr->end = end;\n  }\n  return startOfList;\n}\n```\nC Tests (the test cases used for the program under analysis):\n\n```c\nint main(int argc, char** argv) {\n  printf(\"start\\n\");\n  struct rangeElement* list = NULL;\n  bool b;\n  int bufsize=1024;\n  char buf[bufsize];\n  char* rv;\n\n  //////////////////////////////////////////////\n  list = rangeAddSingle(5, list);\n  printf(\"list = 5\\n\");\n\n  printf(\"test: not contains 4\\n\");\n  b = rangeContainsNum(4, list);\n  assert(b == false);\n  printf(\"\\tok\\n\");\n\n  printf(\"test: contains 5\\n\");\n  b = rangeContainsNum(5, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test: element to string\\n\");\n  memset(buf, 0, bufsize);\n  rangeElementToString(buf, bufsize, list);\n  rv = \"[5]\";\n  printf(\"\\t%s == %s ???\", rv, buf);\n  assert(strcmp(rv, buf) == 0);\n  printf(\"\\tok\\n\");\n\n\n  printf(\"test: list to string\\n\");\n  memset(buf, 0, bufsize);\n  rangeListToString(buf, bufsize, list);\n  rv = \"[5]\";\n  printf(\"\\t%s == %s ???\\n\", rv, buf);\n  assert(strcmp(\"[5]\", buf) == 0);\n  printf(\"\\tok\\n\");\n\n  printf(\"test: free\\n\");\n  rangeFree(list);\n  assert(true);\n  printf(\"\\tok\\n\");\n\n  /////////////////////////////////////////////////\n  list = NULL;\n  list = rangeAddStartEnd(5, 10, list);\n\n  printf(\"test b1:\\n\");\n  b = rangeContainsNum(4, list);\n  assert(b == false);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b2:\\n\");\n  b = rangeContainsNum(5, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b3:\\n\");\n  b = rangeContainsNum(7, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b4:\\n\");\n  b = rangeContainsNum(10, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b5:\\n\");\n  b = rangeContainsNum(12, list);\n  assert(b == false);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b6:\\n\");\n  memset(buf, 0, bufsize);\n  rangeElementToString(buf, bufsize, list);\n  rv = \"[5-10]\";\n  printf(\"\\t%s == %s ???\", rv, buf);\n  assert(strcmp(rv, buf) == 0);\n  printf(\"\\tok\\n\");\n\n  printf(\"test b7:\\n\");\n  memset(buf, 0, bufsize);\n  rangeListToString(buf, bufsize, list);\n  rv = \"[5-10]\";\n  printf(\"\\t%s == %s ???\", rv, buf);\n  assert(strcmp(rv, buf) == 0);\n  printf(\"\\tok\\n\");\n\n  rangeFree(list);\n\n  /////////////////////////////////////////////////\n  list = NULL;\n  list = rangeAddStartEnd(5, 10, list);\n  list = rangeAddSingle(15, list);\n  list = rangeAddGreaterEqual(40, list);\n\n\n  printf(\"test c1:\\n\");\n  b = rangeContainsNum(1, list);\n  assert(b == false);\n  printf(\"\\tok\\n\");\n\n  printf(\"test c2:\\n\");\n  b = rangeContainsNum(6, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test c3:\\n\");\n  b = rangeContainsNum(12, list);\n  assert(b == false);\n  printf(\"\\tok\\n\");\n\n  printf(\"test c4:\\n\");\n  b = rangeContainsNum(50, list);\n  assert(b == true);\n  printf(\"\\tok\\n\");\n\n  printf(\"test c6:\\n\");\n  memset(buf, 0, bufsize);\n  rangeElementToString(buf, bufsize, list);\n  printf(\"\\t%s\", buf);\n  rv = \"[5-10]\";\n  assert(strcmp(buf, rv) == 0);\n  printf(\"\\tok\\n\");\n\n  printf(\"test c7:\");\n  memset(buf, 0, bufsize);\n  rangeListToString(buf, bufsize, list);\n  rv = \"[5-10][15][40-]\";\n  printf(\"\\t%s == %s ???\", rv, buf);\n  assert(strcmp(buf, rv) == 0);\n  printf(\"\\tok\\n\");\n  \n  rangeFree(list);\n\n  /////////////////////////////////////////////////\n  list = NULL;\n  list = rangeAddSingle(2, list);\n  list = rangeAddStartEnd(2, 4, list);\n\n  printf(\"testd:\");\n  memset(buf, 0, bufsize);\n  rangeListToString(buf, bufsize, list);\n  rv = \"[2][2-4]\";\n  printf(\"\\t%s == %s ???\\n\", rv, buf);\n  assert(strcmp(buf, rv) == 0);\n  printf(\"\\tok\\n\");\n\n\n  printf(\"test:\");\n  struct rangeElement* l2 = parseIntRanges(\"2,2-4\");\n  memset(buf, 0, bufsize);\n  rangeListToString(buf, bufsize, l2);\n  rv = \"[2][2-4]\";\n  printf(\"\\t%s == %s ???\\n\", rv, buf);\n  assert(strcmp(buf, rv) == 0);\n  printf(\"\\tok\\n\");\n  \n\n  return 0;\n}\n```\n\nRust test that fails (the test case that currently fails):\n```rust\n#[test]\nfn test_range() {\nlet mut list = None;\nlet mut buf = String::new();\nlet bufsize = 1024;\n\nlist = RangeElement::add_single(5, list);\nassert!(!RangeElement::contains_num(4, &list));\nassert!(RangeElement::contains_num(5, &list));\n\nbuf.clear();\nRangeElement::list_to_string(&mut buf, bufsize, &list);\nassert_eq!(buf, \"[5]\");\n\nlist = RangeElement::add_start_end(5, 10, list);\nassert!(!RangeElement::contains_num(4, &list));\nassert!(RangeElement::contains_num(5, &list));\nassert!(RangeElement::contains_num(7, &list));\nassert!(RangeElement::contains_num(10, &list));\nassert!(!RangeElement::contains_num(12, &list));\n\nbuf.clear();\nRangeElement::list_to_string(&mut buf, bufsize, &list);\nassert_eq!(buf, \"[5-10]\");\n\nlist = RangeElement::add_start_end(5, 10, list);\nlist = RangeElement::add_single(15, list);\nlist = RangeElement::add_greater_equal(40, list);\nassert!(!RangeElement::contains_num(1, &list));\nassert!(RangeElement::contains_num(6, &list));\nassert!(!RangeElement::contains_num(12, &list));\nassert!(RangeElement::contains_num(50, &list));\n\nbuf.clear();\nRangeElement::list_to_string(&mut buf, bufsize, &list);\nassert_eq!(buf, \"[5-10][15][40-]\");\n\nlist = RangeElement::add_single(2, list);\nlist = RangeElement::add_start_end(2, 4, list);\nbuf.clear();\nRangeElement::list_to_string(&mut buf, bufsize, &list);\nassert_eq!(buf, \"[2][2-4]\");\n\nlet l2 = RangeElement::parse_int_ranges(\"2,2-4\");\nbuf.clear();\nRangeElement::list_to_string(&mut buf, bufsize, &l2);\nassert_eq!(buf, \"[2][2-4]\");\n}\n\nfn main() {}\n```\n\n\nRust interface files (types, functions, signatures you MUST use to build test fixtures):\n```rust\npub fn add_start_end(start: u32, end: u32, start_of_list: Option<Box<RangeElement>>) -> Option<Box<RangeElement>> {\n    unimplemented!();\n}\n```\n\nPlease provide the final code in ```rust ``` tags"
}