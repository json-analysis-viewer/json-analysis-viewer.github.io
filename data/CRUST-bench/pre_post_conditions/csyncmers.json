{
    "name": "csyncmers",
    "manual_invs_pre_post": "```rust\nuse crate::{\n    base_to_bits, complement_base, MinimizerResult,\n};\n \n/// Check pre- and post-condition invariants of `compute_closed_syncmers`.\npub fn check_invariants(\n    sequence_input: &str,\n    len: i32,\n    K: i32,\n    S: i32,\n    results: &Vec<MinimizerResult>,\n    num_results: i32,\n) {\n    // Preconditions\n    assert!(\n        len >= 0,\n        \"Invalid len: {} (must be non-negative)\",\n        len\n    );\n    let seq_len = sequence_input.len() as i32;\n    assert!(\n        len == seq_len,\n        \"len parameter {} does not match sequence length {}\",\n        len,\n        seq_len\n    );\n    assert!(\n        K >= 1,\n        \"Invalid K: {} (must be \u2265 1)\",\n        K\n    );\n    assert!(\n        S >= 1,\n        \"Invalid S: {} (must be \u2265 1)\",\n        S\n    );\n    assert!(\n        len >= K,\n        \"Sequence length {} must be at least K {}\",\n        len,\n        K\n    );\n    assert!(\n        K >= S,\n        \"K {} must be at least S {}\",\n        K,\n        S\n    );\n    // To fit in a 128-bit rolling hash, 2*S \u2264 128\n    assert!(\n        (2 * S) <= 128,\n        \"S = {} too large for 128-bit hash (2*S = {})\",\n        S,\n        2 * S\n    );\n \n    // Postcondition: results length matches num_results\n    assert_eq!(\n        results.len(),\n        num_results as usize,\n        \"results.len() = {} but num_results = {}\",\n        results.len(),\n        num_results\n    );\n \n    // Prepare for per-result checks\n    let max_kmer_pos = (len - K) as usize;\n    let max_smer_pos = (len - S + 1) as usize;\n    let span = (K - S) as usize;\n \n    // Build a char buffer for random-access\n    let seq_chars: Vec<char> = sequence_input.chars().collect();\n \n    // Build mask = (1 << (2*S)) - 1, or u128::MAX if 2*S == 128\n    let mask: u128 = if 2 * (S as usize) == 128 {\n        u128::MAX\n    } else {\n        (1u128 << (2 * (S as usize))) - 1\n    };\n \n    let mut prev_kpos: Option<usize> = None;\n    for (i, r) in results.iter().enumerate() {\n        let kp = r.kmer_position;\n        let sp = r.smer_position;\n        let h  = r.minimizer_hash;\n \n        // k-mer and s-mer position bounds\n        assert!(\n            kp <= max_kmer_pos,\n            \"result[{}].kmer_position = {} exceeds max {}\",\n            i,\n            kp,\n            max_kmer_pos\n        );\n        assert!(\n            sp < max_smer_pos,\n            \"result[{}].smer_position = {} exceeds max {}\",\n            i,\n            sp,\n            max_smer_pos - 1\n        );\n \n        // s-mer must lie at one of the two closed-syncmer positions\n        assert!(\n            sp == kp || sp == kp + span,\n            \"result[{}]: smer_position {} not in {{kmer_position {}, kmer_position+K-S {}}}\",\n            i,\n            sp,\n            kp,\n            kp + span\n        );\n \n        // k-mer positions must strictly increase\n        if let Some(prev) = prev_kpos {\n            assert!(\n                kp > prev,\n                \"result[{}].kmer_position = {} not > previous {}\",\n                i,\n                kp,\n                prev\n            );\n        }\n        prev_kpos = Some(kp);\n \n        // Recompute the canonical hash of the s-mer at `sp`\n        let mut hash_fwd: u128 = 0;\n        let mut hash_rev: u128 = 0;\n        for j in 0..(S as usize) {\n            let base_c = seq_chars[sp + j];\n            let b = base_to_bits(base_c) as u128;\n            hash_fwd = ((hash_fwd << 2) | b) & mask;\n            // reverse-compliment: take from back of the s-mer\n            let b_back = base_to_bits(seq_chars[sp + (S as usize) - 1 - j]);\n            let cb = complement_base(b_back as u8) as u128;\n            let shift = 2 * ((S as usize) - 1 - j);\n            hash_rev |= (cb << shift) & mask;\n        }\n        let canonical = if hash_fwd < hash_rev {\n            hash_fwd\n        } else {\n            hash_rev\n        };\n \n        assert_eq!(\n            h, canonical,\n            \"result[{}].minimizer_hash = {:#x} but canonical s-mer hash = {:#x}\",\n            i, h, canonical\n        );\n    }\n}\n \n/* Invariants enforced:\n- Sequence length `len` matches the string length and is non-negative.\n- K \u2265 1, S \u2265 1, len \u2265 K, and K \u2265 S.\n- 2*S \u2264 128 so that 128-bit hashes fit.\n- `results.len()` equals `num_results`.\n- Each `kmer_position` \u2208 [0, len\u2212K], each `smer_position` \u2208 [0, len\u2212S].\n- For every result, `smer_position` == `kmer_position` or `kmer_position + (K\u2212S)`.\n- `kmer_position`s are strictly increasing across results.\n- `minimizer_hash` equals the canonical (forward vs reverse-complement) hash of the S-mer.\n*/",
    "rri_prompt": "Task: Extract invariants from C  code and emit a Rust function called `check_invariants`\nRole: You are a rigorous program analyst. You will study a C program and its Rust interface files. Your job is to derive pre and post conditions of the program. \nDo any reasoning internally; only output the requested sections and code.\n\nInputs\n\n1. C function under analysis.\n2. C test case that is currently failing.\n3. Rust interface relevant to the C function.\n\nYou must implement a single Rust function named `check_invariants`:\n1. Perform non-trivial pre and post condition checks derived from the C program\u2019s behavior.\n2. Use `assert!` / `assert_eq!` with clear failure messages that include key values.\n3. You should not add unit tests but rather infer general invariants that hold for all valid states of the program.\n4. A brief bullet list titled \u201cInvariants enforced\u201d summarizing each invariant in plain language (no derivations or chain-of-thought; just the final invariants).\n\nConstraints & style\n\n1. Use only items available in the Rust interface (no new public types or deps).\n2. Prefer safe Rust; do not use unsafe unless the interface explicitly requires it.\n3. No logging/printing. No randomness. No external crates.\n4. If the interface already includes a validator that returns Result, you may call it and assert on Ok/Err instead of re-implementing internals.\n\nImplementation checklist\n1. Read the Rust interface to understand how to construct states.\n2. From the C code, enumerate and infer candidate invariants. Keep only those that must hold for all reachable states.\n3. Valid cases: assert the invariant holds.\n\nNow you will be provided with the C source code and Rust interface definitions.\n\nC source (program under analysis):\n```c\nvoid compute_closed_syncmers(const char *sequence_input, int len, int K, int S, MinimizerResult *results, int *num_results) {\n    *num_results = 0;\n    if(len < K) {\n        fprintf(stderr, \"Sequence length is less than K\\n\");\n        return;\n    }\n\n    size_t num_s_mers = len - S + 1;\n    __uint128_t *s_mer_hashes = (__uint128_t *)malloc(num_s_mers * sizeof(__uint128_t));\n\n    // Precompute all s-mer hashes\n    __uint128_t mask = (((__uint128_t)1) << (2 * S)) - 1;\n    __uint128_t hash_fwd = 0, hash_rev = 0;\n    __uint128_t rc_shift = 2 * (S - 1);\n\n    for(size_t i = 0; i < len; i++) {\n        uint8_t base = base_to_bits(sequence_input[i]);\n        hash_fwd = ((hash_fwd << 2) | base) & mask;\n        uint8_t comp_base = complement_base(base);\n        hash_rev = ((hash_rev >> 2) | ((__uint128_t)comp_base << rc_shift)) & mask;\n        if(i >= S - 1) {\n            size_t s_mer_pos = i - S + 1;\n            __uint128_t canonical_hash = (hash_fwd < hash_rev) ? hash_fwd : hash_rev;\n            s_mer_hashes[s_mer_pos] = canonical_hash;\n        }\n    }\n\n    // Initialize deque\n    size_t window_size = K - S + 1;\n    size_t *deque = (size_t *)malloc(num_s_mers * sizeof(size_t));\n    size_t front = 0, back = 0;\n\n    // Use deque to find minimal s-mers in O(N)\n    for(size_t i = 0; i < num_s_mers; i++) {\n        while(back > front  && s_mer_hashes[deque[back-1]] > s_mer_hashes[i]) {\n            back--;\n        }\n        deque[back++] = i;\n\t if(i >= window_size && deque[front] <= i - window_size) {\n            front++;\n\t}\n\n        // Check for closed syncmer condition\n        if(i >= window_size - 1) {\n            size_t min_pos = deque[front];\n            size_t kmer_pos = i - window_size + 1;\n            if(min_pos == kmer_pos || min_pos == kmer_pos + K - S) {\n            \t//printf(\"%.*s\\n\", K, &sequence_input[i]);\n                add_minimizer(results, num_results, s_mer_hashes[min_pos], kmer_pos, min_pos);\n            }\n        }\n    }\n\n    free(s_mer_hashes);\n    free(deque);\n}\n```\n\nC Tests (the test cases that are failing):\n\n```c\nint main() {\n    srand(time(NULL)); // Seed the random number generator\n\n    int num_tests = 10;\n    int sequence_length = 1050;\n    char sequence[sequence_length + 1]; // +1 for the null terminator\n\n    for (int test = 1; test <= num_tests; test++) {\n        // Generate a random sequence\n        generate_sequence(sequence, sequence_length);\n\n        // Generate random 'a' such that 10 < a < 1000\n        int a = rand() % 989 + 11; // Random integer between 11 and 999 inclusive\n\n        // Calculate 'b' constraints: 6 < b < a and b < 100\n        int b_min = 7;\n        int b_max = (a - 1 < 63) ? a - 1 : 63;\n\n        // Ensure b_min does not exceed b_max\n        int b = (b_max < b_min) ? b_min : (rand() % (b_max - b_min + 1) + b_min);\n\n        printf(\"Test %d: Sequence Length=%d, K=%d, S=%d\\n\", test, sequence_length, a, b);\n\n        int num_results;\n        MinimizerResult results[10000];\n        compute_closed_syncmers(sequence, strlen(sequence), a, b, results, &num_results);\n\n        printf(\"Closed Syncmers:\\n\");\n        printf(\"%-20s %-20s\\n\", \"Position\", \"Minimizer Hash\");\n        for (int i = 0; i < num_results; i++) {\n            printf(\"%-20zu %-20llu\\n\", results[i].kmer_position, (unsigned long long)results[i].minimizer_hash);\n        }\n\n        // Compute closed syncmers using the naive method\n        int num_naive_results;\n        MinimizerResult naive_results[10000];\n        compute_closed_syncmers_naive(sequence, strlen(sequence), a, b, naive_results, &num_naive_results);\n\n        printf(\"\\nClosed Syncmers (Naive):\\n\");\n        printf(\"%-20s %-20s\\n\", \"Position\", \"Minimizer Hash\");\n        for (int i = 0; i < num_naive_results; i++) {\n            printf(\"%-20zu %-20llu\\n\", naive_results[i].kmer_position, (unsigned long long)naive_results[i].minimizer_hash);\n        }\n\n        // Compare the results\n        if (num_results != num_naive_results) {\n            printf(\"\\nMismatch in number of closed syncmers: %d (original) vs %d (naive)\\n\", num_results, num_naive_results);\n            return 1;\n        } else {\n            printf(\"\\nNumber of closed syncmers matches: %d\\n\", num_results);\n        }\n\n        // Compare each result\n        int mismatch = 0;\n        for (int i = 0; i < num_results; i++) {\n            if (results[i].kmer_position != naive_results[i].kmer_position ||\n                results[i].minimizer_hash != naive_results[i].minimizer_hash) {\n                printf(\"Mismatch at index %d:\\n\", i);\n                printf(\"  Original -> Position: %zu, Hash: %llu\\n\",\n                       results[i].kmer_position, (unsigned long long)results[i].minimizer_hash);\n                printf(\"  Naive    -> Position: %zu, Hash: %llu\\n\",\n                       naive_results[i].kmer_position, (unsigned long long)naive_results[i].minimizer_hash);\n                mismatch = 1;\n                break;\n            }\n        }\n        if (mismatch) {\n            printf(\"Test %d failed.\\n\", test);\n            return 1;\n        }\n\n        printf(\"Test %d passed. All closed syncmers match between original and naive method.\\n\\n\", test);\n    }\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}\n```\n\nRust test that fails (the test case that currently fails):\n```rust\nfn test() {\n    let num_tests = 10;\n    let sequence_length = 1050;\n\n    for test in 1..=num_tests {\n        let sequence = generate_sequence(sequence_length);\n        let a = rand::thread_rng().gen_range(11..=999);\n        let b_min = 7;\n        let b_max = if a - 1 < 63 { a - 1 } else { 63 };\n        let b = if b_max < b_min { b_min } else { rand::thread_rng().gen_range(b_min..=b_max) };\n\n        println!(\"Test {}: Sequence Length={}, K={}, S={}\", test, sequence_length, a, b);\n\n        let mut results = Vec::new();\n        let mut num_results = 0;\n        compute_closed_syncmers(&sequence, sequence.len() as i32, a, b, &mut results, &mut num_results);\n\n        println!(\"Closed Syncmers:\");\n        println!(\"{:<20} {:<20}\", \"Position\", \"Minimizer Hash\");\n        for result in &results {\n            println!(\"{:<20} {:<20}\", result.kmer_position, result.minimizer_hash);\n        }\n\n        let mut naive_results = Vec::new();\n        let mut num_naive_results = 0;\n        compute_closed_syncmers_naive(&sequence, sequence.len(), a, b, &mut naive_results, &mut num_naive_results);\n\n        println!(\"\\nClosed Syncmers (Naive):\");\n        println!(\"{:<20} {:<20}\", \"Position\", \"Minimizer Hash\");\n        for result in &naive_results {\n            println!(\"{:<20} {:<20}\", result.kmer_position, result.minimizer_hash);\n        }\n\n        assert_eq!(num_results, num_naive_results, \"Mismatch in number of closed syncmers: {} (original) vs {} (naive)\", num_results, num_naive_results);\n\n        for (i, (result, naive_result)) in results.iter().zip(naive_results.iter()).enumerate() {\n            assert_eq!(result.kmer_position, naive_result.kmer_position, \"Mismatch at index {}: Position\", i);\n            assert_eq!(result.minimizer_hash, naive_result.minimizer_hash, \"Mismatch at index {}: Hash\", i);\n        }\n\n        println!(\"Test {} passed. All closed syncmers match between original and naive method.\\n\", test);\n    }\n\n    println!(\"All tests passed.\");\n}\n```\n\n\nRust interface files (types, functions, signatures you MUST use to build test fixtures):\n```rust\n// Import necessary modules\nuse std::collections::HashMap;\n// Struct Definitions\n#[derive(Debug, Clone)]\npub struct MinimizerResult {\n    pub minimizer_hash: u128,\n    pub kmer_position: usize,\n    pub smer_position: usize,\n}\n// Function Declarations\npub fn compute_closed_syncmers(sequence_input: &str, len: i32, k: i32, s: i32, results: &mut Vec<MinimizerResult>, num_results: &mut i32) {\n    unimplemented!()\n}\npub fn base_to_bits(base: char) -> u8 {\n    unimplemented!()\n}\npub fn complement_base(base: u8) -> u8 {\n    unimplemented!()\n}\npub fn add_minimizer(results: &mut Vec<MinimizerResult>, size: &mut i32, minimizer_hash: u128, kmer_position: usize, smer_position: usize) {\n    unimplemented!()\n}\n```\n\nPlease provide the final code in ```rust ``` tags"
}