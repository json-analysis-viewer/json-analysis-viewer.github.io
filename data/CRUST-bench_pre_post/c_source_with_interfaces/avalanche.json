{
    "name": "avalanche",
    "avalanche.c": "/* avalanche.c\n */\n#include \"avalanche.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid avalanche(hash_f hash, FILE* ins, uint64_t max_iter, matrix_t* results)\n{\n    size_t key_size = results->n_rows / 8;\n    size_t hash_words = results->n_cols / 32;\n\n    char* key = malloc(key_size);\n    uint32_t* hvalue = malloc(4 * hash_words);\n    uint32_t* htemp = malloc(4 * hash_words);\n\n    uint64_t key_count = 0;\n    while (key_count < max_iter) {\n        size_t n_in = fread(key, 1, key_size, ins);\n        if (n_in < key_size)\n            break;\n\n        hash(key, key_size, hvalue);\n        ++key_count;\n\n        for (size_t i_byte = 0; i_byte < key_size; ++i_byte) {\n            for (size_t i_bit = 0; i_bit < 8; ++i_bit) {\n                size_t row = i_byte * 8 + i_bit;\n\n                // flip the i-th bit of this byte and re-hash\n                char i_mask = 0x80 >> i_bit;\n                key[i_byte] ^= i_mask;\n                hash(key, key_size, htemp);\n                key[i_byte] ^= i_mask;\n\n                for (size_t j_word = 0; j_word < hash_words; ++j_word) {\n                    for (size_t j_bit = 0; j_bit < 32; ++j_bit) {\n                        size_t col = j_word * 32 + j_bit;\n\n                        // test whether hvalue & htemp differ at j-th bit.\n                        uint32_t j_mask = 0x80000000 >> j_bit;\n                        if ((hvalue[j_word] ^ htemp[j_word]) & j_mask) {\n                            double curr = MATRIX_GET(results, row, col);\n                            MATRIX_SET(results, row, col, curr + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    free(key);\n    free(hvalue);\n    free(htemp);\n\n    if (key_count) {\n        // convert matrix entries to the mean values\n        size_t n_vals = results->n_cols * results->n_rows;\n        for (size_t k = 0; k < n_vals; ++k)\n            results->vals[k] /= key_count;\n    }\n}\n\nmatrix_t* matrix_alloc(size_t n_rows, size_t n_cols) {\n    matrix_t* M = malloc(sizeof(matrix_t));\n    M->n_rows = n_rows;\n    M->n_cols = n_cols;\n    M->vals = calloc(sizeof(double), n_cols * n_rows);\n    return M;\n}\n\nvoid matrix_free(matrix_t* M) {\n    if (M == NULL)\n        return;\n    free(M->vals);\n    free(M);\n    M = NULL;\n}\n\nvoid matrix_fprintf(FILE* fout, const char* format, const matrix_t* M) {\n    if (M == NULL)\n        return;\n\n    for (size_t r = 0; r < M->n_rows; ++r) {\n        for (size_t c = 0; c < M->n_cols; ++c) {\n            fprintf(fout, format, MATRIX_GET(M, r, c));\n        }\n        fprintf(fout, \"\\n\");\n    }\n}\n",
    "avalanche.h": "#ifndef AVALANCHE_H\n#define AVALANCHE_H\n#include <stdio.h>\n#include <stdint.h>\n#include <stddef.h>\n\n/** Protypical hash function: converts a `key` of bytes to a hash value,\n represented as an array of 32-bit blocks.\n */\ntypedef void (* hash_f)(char* key, size_t key_len, uint32_t* hash_value);\n\n/** Simple matrix structure.\n */\ntypedef struct {\n    size_t n_rows, n_cols;\n    double* vals;\n} matrix_t;\n\n// macros for enforcing row-major layout of matrix\n#define MATRIX_GET(M, ROW, COL) ((M)->vals[(ROW) * (M)->n_cols + (COL)])\n#define MATRIX_SET(M, ROW, COL, VAL) ((M)->vals[(ROW) * (M)->n_cols + (COL)] = (VAL))\n\n/** Avalanche test for hash function.\n\n All test keys are read successively from the stream `ins`, and the probability\n that flipping i-th input bit affects the j-th output bit is recorded as the\n ij-th entry of the matrix.\n\n All keys read have the same length, so that the key length and size of the\n hash value (in words) are parameterized by the row and columns of the mattrix.\n */\nvoid avalanche(hash_f hash, FILE* ins, uint64_t max_iter, matrix_t* results);\n\nmatrix_t* matrix_alloc(size_t n_rows, size_t n_cols);\nvoid matrix_free(matrix_t*);\nvoid matrix_fprintf(FILE* fout, const char* format, const matrix_t*);\n\n#endif // AVALANCHE_H\n",
    "c_rust": "",
    "c_rust_pre_post_conditions": "// Preconditions and postconditions for the Rust interface to the C avalanche library\n\nFunction: avalanche\nPreconditions:\n- `results.n_rows % 8 == 0` and `results.n_cols % 32 == 0`.\n- `results.vals.len() == results.n_rows * results.n_cols`.\n- `hash` must accept any `&[u8]` of length `key_size = results.n_rows/8` and write exactly `hash_words = results.n_cols/32` u32 words into its `&mut [u32]`.\n- `ins` must implement `Read` and supply at least `key_size` bytes per iteration until EOF or `max_iter` is reached.\nPostconditions:\n- Let `key_count` be the number of full keys read (\u2264 `max_iter`).  \n  - If `key_count == 0`, `results.vals` is unchanged (remains as on entry).  \n  - Otherwise each entry `results.vals[row*results.n_cols + col]` is set to  \n    (# of times flipping input bit `row` changed output bit `col`) \u00f7 `key_count`.\n- The read position of `ins` is advanced by `key_count * key_size` bytes (plus any partial remainder on EOF).\n- No allocation or leak remains: all temporary buffers are freed before return.\n\nFunction: Matrix::matrix_alloc\nPreconditions:\n- `n_rows * n_cols` does not overflow `usize`.\n- Sufficient memory exists to allocate `n_rows * n_cols` f64s and the struct itself.\nPostconditions:\n- Returns a `Matrix` with  \n  - `n_rows ==` the argument  \n  - `n_cols ==` the argument  \n  - `vals.len() == n_rows * n_cols`  \n  - every entry of `vals` is initialized to `0.0`.\n\nFunction: Matrix::matrix_fprintf\nPreconditions:\n- `format` is a valid format string for a single `f64` (e.g. `\"%f \"`).\n- `fout` implements `Write`.\n- `self.vals.len() == self.n_rows * self.n_cols`.\nPostconditions:\n- Writes exactly `n_rows` lines to `fout`.\n- On line `r` it writes `n_cols` formatted values (`format` applied to each `self.vals[r*n_cols + c]`), followed by a newline.\n\nFunction: Matrix::matrix_get\nPreconditions:\n- `row < self.n_rows`\n- `col < self.n_cols`\nPostconditions:\n- Returns the value `self.vals[row * self.n_cols + col]`.\n- Does not modify the matrix.\n\nFunction: Matrix::matrix_set\nPreconditions:\n- `row < self.n_rows`\n- `col < self.n_cols`\nPostconditions:\n- Sets `self.vals[row * self.n_cols + col] = val`.\n- All other entries of `self.vals` are unchanged.",
    "rri_prompt": ""
}