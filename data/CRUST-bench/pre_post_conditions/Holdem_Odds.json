{
    "name": "Holdem_Odds",
    "manual_invs_pre_post": "```rust\nuse std::collections::HashSet;\nuse crate::cards::{Card, Rank, Suit, RANKS_PER_DECK, SUITS_PER_DECK};\nuse crate::{CARDS_PER_DECK};\n\n/// Check the core invariants for a deck of cards, as established\n/// by the C implementation of `NewDeck` and `deck_shuffle`.\n///\n/// Panics if any invariant is violated.\npub fn check_invariants(deck: &Vec<Card>) {\n    // Invariant 1: Deck has exactly 52 cards.\n    assert_eq!(\n        deck.len(),\n        CARDS_PER_DECK,\n        \"Deck length mismatch: expected {} cards, got {}\",\n        CARDS_PER_DECK,\n        deck.len()\n    );\n\n    // Invariant 2: Every card in the deck is valid.\n    let invalids: Vec<_> = deck.iter().filter(|c| !c.is_valid()).collect();\n    assert!(\n        invalids.is_empty(),\n        \"Deck contains invalid cards: {:?}\",\n        invalids\n    );\n\n    // Invariant 3: No duplicate cards (i.e., it's a proper permutation).\n    let unique_cards: HashSet<_> = deck.iter().cloned().collect();\n    assert_eq!(\n        unique_cards.len(),\n        CARDS_PER_DECK,\n        \"Deck contains duplicate cards\"\n    );\n\n    // Invariant 4: Cards are sorted by ascending rank, then ascending suit\n    // (matching C's NewDeck order: rank-major from Deuce..Ace, suit-minor Club..Spade).\n    for window in deck.windows(2) {\n        let a = &window[0];\n        let b = &window[1];\n        let rank_cmp = a.rank().cmp(&b.rank());\n        let suit_cmp = a.suit().cmp(&b.suit());\n\n        let properly_ordered = match rank_cmp {\n            std::cmp::Ordering::Less => true,\n            std::cmp::Ordering::Equal => suit_cmp == std::cmp::Ordering::Less,\n            std::cmp::Ordering::Greater => false,\n        };\n\n        assert!(\n            properly_ordered,\n            \"Deck not sorted: card {:?} should not come before {:?}\",\n            a,\n            b\n        );\n    }\n}\n\n//\n// Invariants enforced:\n// - The deck contains exactly 52 cards.\n// - Every card in the deck is valid.\n// - No two cards in the deck are the same.\n// - Cards are in ascending order by rank (Deuce\u2192Ace), then by suit (Club\u2192Spade).\n```",
    "rri_prompt": "Task: Extract invariants from C  code and emit a Rust function called `check_invariants`\nRole: You are a rigorous program analyst. You will study a C program and its Rust interface files. Your job is to derive pre and post conditions of the program. \nDo any reasoning internally; only output the requested sections and code.\n\nInputs\n\n1. C function under analysis.\n2. C test case that is currently failing.\n3. Rust interface relevant to the C function.\n\nYou must implement a single Rust function named `check_invariants`:\n1. Perform non-trivial pre and post condition checks derived from the C program\u2019s behavior.\n2. Use `assert!` / `assert_eq!` with clear failure messages that include key values.\n3. You should not add unit tests but rather infer general invariants that hold for all valid states of the program.\n4. A brief bullet list titled \u201cInvariants enforced\u201d summarizing each invariant in plain language (no derivations or chain-of-thought; just the final invariants).\n\nConstraints & style\n\n1. Use only items available in the Rust interface (no new public types or deps).\n2. Prefer safe Rust; do not use unsafe unless the interface explicitly requires it.\n3. No logging/printing. No randomness. No external crates.\n4. If the interface already includes a validator that returns Result, you may call it and assert on Ok/Err instead of re-implementing internals.\n\nImplementation checklist\n1. Read the Rust interface to understand how to construct states.\n2. From the C code, enumerate and infer candidate invariants. Keep only those that must hold for all reachable states.\n3. Valid cases: assert the invariant holds.\n\nNow you will be provided with the C source code and Rust interface definitions.\n\nC source (program under analysis):\n```c\n// deck.c\n#include <stdbool.h>\n#include <string.h>\n\n#include \"bucket.h\"\n#include \"cards.h\"\n#include \"hands.h\"\n\n\nstatic bool HandIsStraightFlush(const Card*);\nstatic bool HandIsWheelFlush(const Card*);\nstatic bool HandIsFourOfAKind(const Card*);\nstatic bool HandIsFullHouse(const Card*);\nstatic bool HandIsFlush(const Card*);\nstatic bool HandIsStraight(const Card*);\nstatic bool HandIsWheel(const Card*);\nstatic bool HandIsThreeOfAKind(const Card*);\nstatic bool HandIsTwoPair(const Card*);\nstatic bool HandIsPair(const Card*);\nstatic bool HandIsHighCard(const Card*);\n\n\n/*\n * Compare two hands and return:\n *   < 0 if hand1 < hand2\n *     0 if hand1 = hand2\n *   > 0 if hand1 > hand2\n */\nint HandCompare(Card* hand1, Card* hand2) {\n    HandType hand1_type = HandClassify(hand1);\n    HandType hand2_type = HandClassify(hand2);\n    int diff = hand1_type - hand2_type;\n\n    if (diff != 0)\n        return diff;\n\n    // Tie breaker when two hands of the same type.\n    // Find the strongest hand by going card-by-card\n    // until one card is higher.  If no card is higher\n    // we have a tie.\n    for (size_t i = 0; i < HAND_LENGTH; ++i) {\n        int cmp = CardCompare(&hand1[i], &hand2[i]);\n        if (cmp != 0)\n            return cmp;\n    }\n    return 0;\n}\n\n\n/*\n * Sort the cards by the number of cards of the same\n * rank that appear in the hand and then by rank from\n * strongest to weakest.\n */\nvoid HandSort(Card* hand) {\n    Bucket buckets[RANKS_PER_DECK] = {{{{InvalidRank, InvalidSuit}}, 0}};\n\n    // Copy the cards into the buckets.\n    for (size_t i = 0; i < HAND_LENGTH; ++i) {\n        size_t bucket_index = hand[i].rank - 1;\n        BucketAdd(&buckets[bucket_index], &hand[i]);\n    }\n\n    size_t index = 0; // Index of the next card to insert in hand\n\n    // Search for buckets with 4 cards first, then 3, 2 and 1.\n    for (size_t count = 4; count > 0; --count) {\n\n        // Go from the highest rank to the lowest rank when inserting into hand\n        for (size_t j = RANKS_PER_DECK - 1; j != (size_t)-1; --j) {\n\n            // If the number of cards in the bucket matches the number\n            // we're looking for, insert them into the hand.\n            if (buckets[j].count == count) {\n                memcpy(&hand[index], &buckets[j].cards, sizeof(Card) * count);\n                index += count;\n            }\n        }\n    }\n}\n\n\n\n/*\n * Find the type of the hand that's been given to us.  Go\n * from strongest to weakest type; this assures us that a\n * full house is not classified as merely a pair.\n *\n * The cards *must* be sorted in order for this function\n * to work properly.\n */\nHandType HandClassify(Card* cards) {\n    if (HandIsFlush(cards)) {\n        if (HandIsStraight(cards)) return StraightFlush;\n        if (HandIsWheel(cards))    return WheelFlush;\n        return Flush;\n    }\n    else {\n        if (HandIsFourOfAKind(cards))   return FourOfAKind;\n        if (HandIsFullHouse(cards))     return FullHouse;\n        if (HandIsStraight(cards))      return Straight;\n        if (HandIsWheel(cards))         return Wheel;\n        if (HandIsThreeOfAKind(cards))  return ThreeOfAKind;\n        if (HandIsTwoPair(cards))       return TwoPair;\n        if (HandIsPair(cards))          return Pair;\n        return HighCard;\n    }\n}\n\n\n/*\n * A valid hand has 5 cards in decreasing order.\n */\nbool HandIsValid(const Card* cards) {\n    for (size_t i = 0; i < HAND_LENGTH; ++i)\n        if (!CardIsValid(&cards[i]))\n            return false;\n\n    return true;\n}\n\n\n/*\n * A straight flush is a straight _and_ a flush.\n */\nstatic bool HandIsStraightFlush(const Card* cards) {\n    return HandIsStraight(cards) && HandIsFlush(cards);\n}\n\n\n/*\n * A wheel flush is a wheel _and_ a flush.\n */\nstatic bool HandIsWheelFlush(const Card* cards) {\n    return HandIsWheel(cards) && HandIsFlush(cards);\n}\n\n\n/*\n * Four of a kind is when 4 of the 5 cards have the same rank.\n */\nstatic bool HandIsFourOfAKind(const Card* cards) {\n    // If the cards are properly ordered, only in the\n    // case of quads should the first and fourth card\n    // be of the same rank.\n    return cards[0].rank == cards[3].rank;\n}\n\n\n/*\n * A full house is when a hand is composed of a pair and three of a\n * kind.\n */\nstatic bool HandIsFullHouse(const Card* cards) {\n    // If the cards are properly ordered, only in the\n    // case of a full house should the first and third\n    // card be the same and the last two cards be the same.\n    return cards[0].rank == cards[2].rank\n        && cards[3].rank == cards[4].rank;\n}\n\n\n/*\n * A flush is a hand where all cards have the same suit.\n */\nstatic bool HandIsFlush(const Card* cards) {\n    for (size_t i = 1; i < HAND_LENGTH; ++i)\n        if (cards[i].suit != cards[0].suit)\n            return false;\n\n    return true;\n}\n\n\n/*\n * A straight is a hand where all cards are successive.  The Ace\n * is considered both high and low, meaning it can follow a King\n * or precede a Deuce.\n */\nstatic bool HandIsStraight(const Card* cards) {\n    // If the cards are properly ordered, if the first\n    // card's rank is equal to the rank of the next card\n    // plus 1 (meaning they have different ranks) and if\n    // the fifth card is 4 ranks lower than the first card,\n    // then we have a straight.\n    return cards[0].rank == cards[1].rank + 1\n        && cards[0].rank == cards[4].rank + 4;\n}\n\n\n/*\n * A wheel is a straight from A to 5\n */\nstatic bool HandIsWheel(const Card* cards) {\n       return cards[0].rank == Ace && cards[1].rank == Five;\n}\n\n\n/*\n * A hand is three of a kind if three cards have the same rank\n * and the other two cards don't match.\n */\nstatic bool HandIsThreeOfAKind(const Card* cards) {\n    // If the cards are properly ordered and a full house\n    // wasn't found, if the first and third cards are of\n    // the same rank, we have trips.\n    return cards[0].rank == cards[2].rank;\n}\n\n\n/*\n * A hand has two pairs if two sets of two cards share\n * the same rank and the other card doesn't match.\n */\nstatic bool HandIsTwoPair(const Card* cards) {\n    // If the4 cards are properly ordered and quads\n    // haven't been found, if the third and fourth\n    // cards are of the same rank, we have two pairs.\n    return cards[2].rank == cards[3].rank;\n}\n\n\n/*\n * A hand is a pair if two cards share the same rank\n * and the other three cards all have different ranks.\n */\nstatic bool HandIsPair(const Card* cards) {\n    return cards[0].rank == cards[1].rank;\n}\n\n\n/*\n * A hand is high card if there is no pair, no straight or\n * no flush.  (Any hand is a high card hand)\n */\nstatic bool HandIsHighCard(const Card* cards) {\n    (void)cards;\n    return true;\n}\n```\n\nC Tests (the test cases that are failing):\n\n```c\nvoid TestNewDeck(CuTest* tc) {\n    Card deck[CARDS_PER_DECK];\n    NewDeck(deck, NULL, 0);\n\n    size_t i = 0;\n    char cardStr1[3];\n    char cardStr2[3];\n    char output[OUTPUT_LENGTH];\n\n    for (Rank r = Deuce; r <= Ace; ++r) {\n        for (Suit s = Club; s <= Spade; ++s) {\n            Card c = NewCard(r, s);\n            CardToString(cardStr1, &c);\n            CardToString(cardStr2, &deck[i]);\n            snprintf(output, OUTPUT_LENGTH, \"%s != %s\", cardStr1, cardStr2);\n            CuAssert(tc, output, CardCompare(&c, &deck[i]) == 0);\n            i++;\n        }\n    }\n\n}\n```\n\nRust test that fails (the test case that currently fails):\n```rust\nfn test_new_deck() {\n    let deck = new_deck();\n    let mut expected_deck = Vec::new();\n    for suit in [Suit::Club, Suit::Diamond, Suit::Heart, Suit::Spade] {\n        for rank in [Rank::Deuce, Rank::Trey, Rank::Four, Rank::Five, Rank::Six, Rank::Seven, Rank::Eight,\n                     Rank::Nine, Rank::Ten, Rank::Jack, Rank::Queen, Rank::King, Rank::Ace] {\n            expected_deck.push(Card::new(rank, suit));\n        }\n    }\n    assert_eq!(deck, expected_deck, \"Deck is not properly initialized\");\n}\n```\n\n\nRust interface files (types, functions, signatures you MUST use to build test fixtures):\n```rust\nuse rand::seq::SliceRandom;\nuse rand::thread_rng;\nuse crate::cards::{Card, RANKS_PER_DECK, SUITS_PER_DECK, Rank, Suit};\npub const CARDS_PER_DECK: usize = 52;\npub fn new_deck() -> Vec<Card> {\n    unimplemented!()\n}\npub fn deck_shuffle(deck: &mut Vec<Card>) {\n    unimplemented!()\n}\n```\n\nPlease provide the final code in ```rust ``` tags"
}