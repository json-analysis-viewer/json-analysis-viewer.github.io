{
    "name": "bhshell",
    "bhshell.c": "#include <linux/limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <strings.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <stdbool.h>\n\n#include \"include/dynamicarr.h\"\n#include \"include/input.h\"\n#include \"include/bhshell.h\"\n#include \"include/xalloc.h\"\n\n#define BUF_SIZE 64\n\nchar* bhshell_builtin_str[] = {\n\t\"cd\",\n\t\"help\",\n\t\"exit\",\n};\n\nint (*bhshell_builtin_func[]) (char**) = {\n\t&bhshell_cd,\n\t&bhshell_help,\n\t&bhshell_exit,\n};\n\nvoid bhshell_loop() {\n\tchar** args; \n\tint status = 1;\n\n\tdo {\n\t\tchar* dir = getcwd(NULL, 0);\n\t\tif (!dir) exit(EXIT_FAILURE);\n\n\t\tprintf(\"[%s] $ \", dir);\n\n\t\tchar* line = bhshell_read_line();\n\t\tcommand* cmd = bhshell_parse(line);\n\t\tif (cmd == NULL) {\n\t\t\tprintf(\"Invalid Command\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = bhshell_execute(cmd); \n\t\t\n\t\tfree(dir);\n\t\tfree(line);\n\t\tdestroy_command(cmd);\n\t} while(status); \n}\n\nint bhshell_execute(command* cmd) {\n\tif (cmd->args[0] == NULL) {\n\t\treturn 1;\n\t}\n\n\tfor (int i = 0; i < bhshell_num_builtins(); i++) {\n\t\tif (strcmp(cmd->args[0], bhshell_builtin_str[i]) == 0) {\n\t\t\treturn (*bhshell_builtin_func[i])(cmd->args);\n\t\t}\n\t}\n\treturn bhshell_launch(cmd);\n}\n\nint bhshell_launch(command* cmd) {\n\tpid_t pid;\n\tint status;\n\n\tint redirect_fd[2];\n\tif (cmd->redirect_file_name != NULL) {\n\t\tif (pipe(redirect_fd) == -1) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\t\n\tint pipe_fd[2];\n\tif (cmd->pipe_args != NULL) {\n\t\tif (pipe(pipe_fd) == -1) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tpid = fork();\n\tif (pid == 0) {\n\t\tif (cmd->pipe_args != NULL) {\n\t\t\tclose(pipe_fd[0]);\n\t\t\tif (dup2(pipe_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(pipe_fd[1]);\n\t\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\t\tclose(redirect_fd[0]);\n\t\t\t\tclose(redirect_fd[1]);\n\t\t\t}\n\t\t}\n\t\tif (cmd->pipe_args == NULL && cmd->redirect_file_name != NULL) {\n\t\t\tclose(redirect_fd[0]);\n\t\t\tif (dup2(redirect_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout to file\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(redirect_fd[1]);\n\t\t} \n\t\t\n\t\tif (execvp(cmd->args[0], cmd->args) == -1) {\n\t\t\tperror(\"bhshell\");\n\t\t}\n\t\t// execvp takes over the entire process\n\t\t// so if return backs to the child process\n\t\texit(EXIT_FAILURE);\n\n\t} else if (pid < 0) {\n\t\t// error forking\n\t\tperror(\"bhshell: Could not create child process\");\n\t\texit(EXIT_FAILURE);\n\t} \n\t// Main process\n\tif (cmd->pipe_args != NULL) {\n\t\tpid_t pid_pipe = fork();\n\t\tint pipe_status;\n\t\tif (pid_pipe == 0) {\n\t\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\t\tclose(redirect_fd[0]);\n\t\t\t\tif (dup2(redirect_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout to file\\n\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tclose(redirect_fd[1]);\n\t\t\t}\n\n\t\t\tclose(pipe_fd[1]);\n\t\t\tif (dup2(pipe_fd[0], STDIN_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdin\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(pipe_fd[0]);\n\n\n\t\t\tif (execvp(cmd->pipe_args[0], cmd->pipe_args) == -1) {\n\t\t\t\tperror(\"bhshell\");\n\t\t\t}\n\t\t\texit(EXIT_FAILURE);\n\t\t} else if (pid_pipe < 0) {\n\t\t\tperror(\"bhshell: Could not create child process\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tclose(pipe_fd[0]);\n\t\tclose(pipe_fd[1]);\n\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\twrite_to_redirect(redirect_fd, cmd);\n\t\t}\n\t\tdo {\n\t\t\twaitpid(pid_pipe, &pipe_status, WUNTRACED);\n\t\t\twaitpid(pid, &status, WUNTRACED);\n\t\t} while(!WIFEXITED(status) && !WIFSIGNALED(status) && !WIFEXITED(pipe_status) && !WIFSIGNALED(pipe_status));\n\t\n\t\treturn 1;\n\t} else if (cmd->redirect_file_name != NULL) {\n\t\twrite_to_redirect(redirect_fd, cmd);\n\t}\n\tdo {\n\t\twaitpid(pid, &status, WUNTRACED);\n\t} while(!WIFEXITED(status) && !WIFSIGNALED(status));\n\treturn 1;\n}\n\nint bhshell_cd(char** args) {\n\tif (args[1] == NULL) {\n\t\tfprintf(stderr, \"bhshell: expected argument to \\\"cd\\\" into\\n\");\n\t} else {\n\t\tif (chdir(args[1]) != 0) {\n\t\t\tperror(\"bhshell\");\n\t\t}\n\t}\n\treturn 1;\n}\n\nint bhshell_help(char** args) {\n\tprintf(\"A simple shell built to understand how processes work.\\n\");\n\tprintf(\"The following functions are builtin:\\n\");\n\n\tint count = bhshell_num_builtins();\n\tfor (int i = 0; i < count; i++) {\n\t\tprintf(\"\\t %d. %s\\n\", i + 1, bhshell_builtin_str[i]);\n\t}\n\treturn 1;\n}\n\nint bhshell_exit(char** args) {\n\treturn 0;\n}\n\nint bhshell_num_builtins() {\n\treturn sizeof(bhshell_builtin_str) / sizeof(char*);\n}\n\nvoid write_to_redirect(int redirect_fd[2], command* cmd) {\n\tstr s = { DA_NULL };\n\n\tchar temp;\n\t\n\tclose(redirect_fd[1]);\n\tint finished = read(redirect_fd[0], &temp, sizeof(char));\n\tif (finished == -1) {\n\t\tclose(redirect_fd[0]);\n\t\tclose(redirect_fd[1]);\n\t\tfree(s.items);\n\t\texit(EXIT_FAILURE);\n\t}\n\twhile (finished != 0) {\n\t\tda_append(&s, temp);\n\n\t\tfinished = read(redirect_fd[0], &temp, sizeof(char));\n\t}\n\tchar* string = get_string(&s);\n\t\n\tclose(redirect_fd[0]);\n\n\tFILE* f = fopen(cmd->redirect_file_name, \"w\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open file\\n\");\n\t\tfree(s.items);\n\t\texit(EXIT_FAILURE);\n\t}\n\tsize_t written = fwrite(string, strlen(string), 1, f);\n\tif (written == 0) {\n\t\tfprintf(stderr, \"Could not write to file\\n\");\n\t\tfree(string);\n\t\texit(EXIT_FAILURE);\n\t}\n\tfree(string); \n\tfclose(f);\n}\n",
    "bhshell.h": "#ifndef BHSHELL_H\n#define BHSHELL_H\n\n#include \"input.h\"\n\nvoid bhshell_loop();\nint bhshell_execute(command* cmd);\nint bhshell_launch(command* cmd); \nint bhshell_cd(char** args);\nint bhshell_help(char** args);\nint bhshell_exit(char** args);\nint bhshell_num_builtins();\nvoid write_to_redirect(int redirect_fd[2], command* cmd);\n\n#endif // !BHSHELL_H\n",
    "dynamicarr.c": "#include <string.h>\n\n#include \"include/dynamicarr.h\"\n#include \"include/xalloc.h\"\n//\nchar* get_string(str* s) {\n\tda_append(s, '\\0');\n\tchar* string = xmalloc(sizeof(char) * (s->position));\n\tmemcpy(string, s->items, sizeof(char) * s->position);\n\tfree(s->items);\n\ts->position = 0; s->items = NULL; s->bufsize = 0;\n\treturn string;\n}\n\n\nvoid destroy_args(char** args) {\n\tif (!args) return;\n\tsize_t i = 0;\n\twhile(args[i] != NULL) {\n\t\tfree(args[i]);\n\t\ti++;\n\t}\n}\n\nchar** get_args(arg_list* l) {\n\tif (l->position == 0) {\n\t\treturn NULL;\n\t}\n\tda_append(l, NULL);\n\tchar** args = xmalloc(sizeof(char*) * (l->position));\n\tfor (size_t i = 0; i < l->position - 1; i++) {\n\t\tsize_t length = strlen(l->items[i]);\n\t\targs[i] = xmalloc(sizeof(char) * (length + 1));\n\t\tmemcpy(args[i], l->items[i], length + 1);\n\t}\n\targs[l->position - 1] = NULL;\n\treturn args;\n}\n",
    "dynamicarr.h": "#include \"xalloc.h\"\n\n#ifndef DYNAMICARR_H\n#define DYNAMICARR_H\n\n#define DA_BUFFER_SIZE 16\n#define DA_NULL .items = NULL, .position = 0, .bufsize = 0\n\n#define da_append(l, x) \\\n\tdo {\\\n\t\tif ((l)->position >= (l)->bufsize) {\\\n\t\t\tif ((l)->bufsize == 0) (l)->bufsize = DA_BUFFER_SIZE;\\\n\t\t\telse (l)->bufsize *= 2;\\\n\t\t\t(l)->items = xrealloc((l)->items, ((l)->bufsize)*sizeof(*(l)->items));\\\n\t\t}\\\n\t\t(l)->items[(l)->position++] = x;\\\n\t} while(0)\n\ntypedef struct str {\n\tchar* items;\n\tsize_t position;\n\tsize_t bufsize;\n} str;\n\nchar* get_string(str* s);\n\ntypedef struct arg_list {\n\tchar** items;\n\tsize_t position;\n\tsize_t bufsize;\n} arg_list;\n\nchar** get_args(arg_list* l);\nvoid destroy_args(char** args);\n\n#endif\n",
    "input.c": "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#include \"include/input.h\"\n#include \"include/dynamicarr.h\"\n#include \"include/xalloc.h\"\n\nenum ARG_TYPE {\n\tARG,\n\tPIPE_ARG,\n\tREDIRECT\n};\n\nchar* bhshell_read_line() {\n\tstr s = { DA_NULL };\n\twhile(1) {\n\t\tint c = getchar();\n\t\tif (c == '\\n' || c == EOF) {\n\t\t\tchar* string = get_string(&s);\n\t\t\treturn string;\n\t\t} else {\n\t\t\tda_append(&s, c);\n\t\t}\n\t}\n}\n\ncommand* bhshell_parse(char* line) {\n\tsize_t length = strlen(line);\n\targ_list args = { DA_NULL };\n\targ_list pipe_args = { DA_NULL };\n\tstr s = { DA_NULL };\n\tchar* redirect = NULL;\n\tenum ARG_TYPE current = ARG;\n\tcommand* cmd = new_command();\n\n\tfor (size_t i = 0; i < length; i++) {\n\t\tif (line[i] == '\\n' || line[i] == '\\t' || line[i] == ' ') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t} else if (current == PIPE_ARG) {\n\t\t\t\t\tda_append(&pipe_args, string);\n\t\t\t\t} else {\n\t\t\t\t\tredirect = string;\t\n\t\t\t\t}\n\t\t\t} \n\t\t\tcontinue;\n\t\t} else if (line[i] == '|') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t\tda_append(&args, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i + 1 < length && line[i] == '>') {\n\t\t\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcurrent = PIPE_ARG;\n\t\t} else if (line[i] == '>') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t\tda_append(&args, NULL);\n\t\t\t\t} else if (current == PIPE_ARG) {\n\t\t\t\t\tda_append(&pipe_args, string);\n\t\t\t\t\tda_append(&pipe_args, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = REDIRECT;\n\t\t} else {\n\t\t\tda_append(&s, line[i]);\n\t\t}\n\t}\n\tif (s.position == 0) {\n\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\treturn NULL;\n\t}\n\tif (s.position > 0) {\n\t\tchar* string = get_string(&s);\n\t\tif (current == ARG) {\n\t\t\tda_append(&args, string);\n\t\t\tda_append(&args, NULL);\n\t\t} else if (current == PIPE_ARG) {\n\t\t\tda_append(&pipe_args, string);\n\t\t\tda_append(&pipe_args, NULL);\n\t\t} else {\n\t\t\tredirect = string;\n\t\t}\n\t} \n\tif (args.position == 0) {\n\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\treturn NULL;\n\t}\n\tcmd->args = args.items;\n\tif (pipe_args.position > 0) {\n\t\tcmd->pipe_args = pipe_args.items;\n\t}\n\tif (redirect != NULL) {\n\t\tcmd->redirect_file_name = redirect;\n\t}\n\treturn cmd;\n}\n\ncommand* new_command() {\n\tcommand* cmd = xmalloc(sizeof(command));\n\t\n\tcmd->args = NULL;\n\tcmd->pipe_args = NULL;\n\tcmd->redirect_file_name = NULL;\n\treturn cmd;\n}\n\nvoid destroy_command(command* cmd) {\n\tdestroy_args(cmd->args);\n\tdestroy_args(cmd->pipe_args);\n\tfree(cmd->redirect_file_name);\n\tfree(cmd);\n}\n",
    "input.h": "#include <stdlib.h>\n\n#ifndef INPUT_H\n#define INPUT_H\n\n#define FREE_ON_INVALID(ARGS, PIPE_ARGS, REDIRECT) \\\n\tdo {\\\n\t\tif ((ARGS).position > 0) destroy_args(args.items);\\\n\t\tif ((PIPE_ARGS).position > 0) destroy_args(pipe_args.items);\\\n\t\tif ((REDIRECT)!= NULL) free(redirect);\\\n\t} while(0)\n\ntypedef struct command {\n\tchar** args;\n\tchar** pipe_args;\n\tchar* redirect_file_name;\n} command;\n\nchar* bhshell_read_line();\ncommand* bhshell_parse(char* line);\nvoid destroy_command(command* cmd);\ncommand* new_command();\n#endif\n",
    "main.c": "#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdbool.h>\n\n#include \"include/bhshell.h\"\n#include \"include/input.h\"\n\nint main(void) {\n\tbhshell_loop();\t\n\treturn EXIT_SUCCESS;\n}\n",
    "xalloc.c": "#include <stdlib.h>\n#include <stdio.h>\n\n#include \"include/xalloc.h\"\n\nvoid* xmalloc(size_t size) {\n\tvoid* ptr = malloc(size);\n\tif (!ptr) {\n\t\tfprintf(stderr, \"bhshell: allocation error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn ptr;\n}\n\nvoid* xrealloc(void* ptr, size_t size) {\n\tptr = realloc(ptr, size);\n\tif (!ptr) {\n\t\tfprintf(stderr, \"bhshell: allocation error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn ptr;\n}\n",
    "xalloc.h": "#include <stdlib.h>\n\nvoid* xmalloc(size_t size);\nvoid* xrealloc(void* ptr, size_t size);\n",
    "c_rust": "",
    "c_rust_pre_post_conditions": "// Preconditions and postconditions for Rust interface functions\n// based on the provided C implementations.\n\nFunction: bhshell_loop\nPreconditions:\n- None (global state assumed initialized by runtime).\nPostconditions:\n- Enters a read\u2013eval\u2013print loop that:\n//   \u2022 Prompts the user with the current working directory.\n//   \u2022 Reads lines, parses into Command, executes them.\n//   \u2022 Continues looping while return status is nonzero.\n// - On internal failure (e.g. getcwd or pipe or fork failure) calls process exit.\n// - Does not return under normal interactive use; on EOF or exit command the process terminates.\n\nFunction: bhshell_execute\nPreconditions:\n- `cmd.args` is non\u2010empty (at least one argument).\nPostconditions:\n- If `cmd.args[0]` is empty string, returns 1 (continue loop).\n- If `cmd.args[0]` matches one of the built-in names, invokes the corresponding built-in and returns its integer status.\n- Otherwise calls `bhshell_launch(cmd)` and returns its integer status.\n\nFunction: bhshell_launch\nPreconditions:\n- `cmd.args` is non\u2010empty (first element is the program to run).\n- File\u2010descriptor arrays and `cmd.pipe_args` / `cmd.redirect_file_name` reflect any requested redirection or piping.\nPostconditions:\n- Spawns one or two child processes (depending on `cmd.pipe_args`).\n- Sets up pipes and/or redirect FD, duplicating ends onto STDIN/STDOUT in the children.\n- In child processes, `execvp` is invoked; on failure child calls `exit(EXIT_FAILURE)`.\n- In parent process:\n//   \u2022 Closes unused sides of any pipes.\n//   \u2022 If redirection was requested, calls `write_to_redirect`.\n//   \u2022 Waits for child processes to terminate.\n//   \u2022 Returns 1 (always continues shell loop).\n\nFunction: bhshell_cd\nPreconditions:\n- `_args` slice has at least one element (the \"cd\" command).\nPostconditions:\n- If `_args.len() < 2`, prints an error to stderr and does not change directory.\n//   Otherwise attempts `chdir(_args[1])`:\n//     \u2022 On success, current working directory is changed.\n//     \u2022 On failure, prints perror message.\n// - Returns 1 (continue loop).\n\nFunction: bhshell_help\nPreconditions:\n- None (the `_args` slice may be empty or ignored).\nPostconditions:\n- Prints help message and lists built-in commands to stdout.\n- Returns 1 (continue loop).\n\nFunction: bhshell_exit\nPreconditions:\n- None.\nPostconditions:\n- Returns 0 (shell loop should exit).\n\nFunction: bhshell_num_builtins\nPreconditions:\n- None.\nPostconditions:\n- Returns the number of built-in commands (3).\n\nFunction: write_to_redirect\nPreconditions:\n- `redirect_fd` is a two\u2010element array of valid file descriptors from a pipe() call.\n- `cmd.redirect_file_name` is `Some(path)`.\nPostconditions:\n- Closes the write end of the pipe (`redirect_fd[1]`).\n- Reads all bytes from the read end (`redirect_fd[0]`) into a buffer.\n// - Builds a string and writes it into the file at `path`, opening it for writing (truncating or creating).\n- Closes the read end and the file.\n// - Frees any intermediate buffers.\n// - On any I/O or allocation error calls process exit.\n\nFunction: get_args\nPreconditions:\n- `l` is a valid `ArgList` containing zero or more strings.\nPostconditions:\n- Returns a `Vec<String>` containing clones of each string in `l.items`.\n- If `l.position == 0`, returns an empty `Vec<String>`.\n\nFunction: get_string\nPreconditions:\n- `s` is a valid `Str` holding some characters in `s.items`.\nPostconditions:\n- Returns a new `String` equal to the concatenation of `s.items`.\n// - After return, `s` may be considered consumed or reset to empty.\n\nFunction: destroy_args\nPreconditions:\n- `_args` is a `Vec<String>` containing zero or more strings.\nPostconditions:\n- Drops the vector and all its strings (frees memory).\n\nFunction: bhshell_read_line\nPreconditions:\n- Standard input is readable (stdin not closed).\nPostconditions:\n- Reads bytes until a newline or EOF.\n// - Returns a `String` containing all read characters (excluding the newline).\n// - On EOF before any characters, returns an empty string.\n\nFunction: bhshell_parse\nPreconditions:\n- `_line` is a non\u2010null string slice.\nPostconditions:\n- Returns a `Command` struct whose fields are:\n//   \u2022 `args`: Vec of whitespace\u2010separated tokens from `_line`, terminated by end.\n//   \u2022 `pipe_args`: Vec of tokens after a '|' if present.\n//   \u2022 `redirect_file_name`: Some(path) if a '>' redirection token was present.\n// - If `_line` is invalid or empty, returns a `Command` with empty `args` (signals parse failure).\n\nFunction: destroy_command\nPreconditions:\n- `_cmd` is any `Command` value.\nPostconditions:\n- Drops `_cmd`, freeing all heap\u2010allocated strings and vectors.\n\nFunction: new_command\nPreconditions:\n- None.\nPostconditions:\n- Returns an empty `Command` with:\n//   \u2022 `args` = empty Vec,\n//   \u2022 `pipe_args` = empty Vec,\n//   \u2022 `redirect_file_name` = None.\n\nFunction: main\nPreconditions:\n- None.\nPostconditions:\n- Calls `bhshell_loop()`.\n// - Upon `bhshell_loop` returning or process exit, the program ends with success.\n\nFunction: xrealloc\nPreconditions:\n- `_data` is a `Vec<u8>` containing existing bytes.\n// - `_new_size` is the desired new length (may be smaller or larger).\nPostconditions:\n- Returns a `Vec<u8>` of length `_new_size`.\n//   \u2022 If `_new_size` \u2265 old length, the returned buffer contains the old bytes in the first positions; additional bytes may be uninitialized or zero-filled (implementation\u2010defined).\n//   \u2022 If `_new_size` < old length, the returned buffer is truncated.\n\nFunction: xmalloc\nPreconditions:\n- `_size` is the desired number of bytes to allocate (\u2265 0).\nPostconditions:\n- Returns a `Vec<u8>` of length `_size`.\n//   \u2022 The contents of the vector may be uninitialized or zero\u2014but conceptually represent freshly allocated memory.\n//   \u2022 On allocation failure, the process calls exit.",
    "rri_prompt": ""
}