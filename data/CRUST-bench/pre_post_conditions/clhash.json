{
    "name": "clhash",
    "manual_invs_pre_post": "```rust\nuse std::mem;\n\npub fn check_invariants(random: &[u8], stringbyte: &[u8]) {\n    // Precondition: random key buffer must be large enough\n    assert!(\n        random.len() >= RANDOM_BYTES_NEEDED_FOR_CLHASH,\n        \"random.len() too small: got {}, want >= {}\",\n        random.len(),\n        RANDOM_BYTES_NEEDED_FOR_CLHASH\n    );\n\n    // Precondition: random pointer must be 16-byte aligned\n    let addr = random.as_ptr() as usize;\n    assert_eq!(\n        addr % 16,\n        0,\n        \"random buffer not 16-byte aligned: address = {:p}\",\n        random.as_ptr()\n    );\n\n    // Compute the same lengths as in the C code\n    let lengthbyte = stringbyte.len();\n    let w = mem::size_of::<u64>();\n    let length = lengthbyte / w;\n    let lengthinc = (lengthbyte + w - 1) / w;\n\n    // Invariant: lengthinc is either length or length+1\n    assert!(\n        lengthinc == length || lengthinc == length + 1,\n        \"lengthinc ({}) not in {{length ({}) , length+1 ({})}}\",\n        lengthinc,\n        length,\n        length + 1\n    );\n\n    // Postcondition: clhash is deterministic on the same inputs\n    let h1 = clhash(random, stringbyte);\n    let h2 = clhash(random, stringbyte);\n    assert_eq!(\n        h1, h2,\n        \"clhash returned non-deterministic results: {} vs {}\",\n        h1, h2\n    );\n}\n```\n\nInvariants enforced\n- random.len() \u2265 RANDOM_BYTES_NEEDED_FOR_CLHASH  \n- random.as_ptr() is 16-byte aligned  \n- lengthinc == length or lengthinc == length + 1 (no more than one partial 64-bit word)  \n- `clhash(random, stringbyte)` yields the same u64 on repeated calls (determinism)",
    "rri_prompt": "Task: Extract invariants from C  code and emit a Rust function called `check_invariants`\nRole: You are a rigorous program analyst. You will study a C program and its Rust interface files. Your job is to derive pre and post conditions of the program. \nDo any reasoning internally; only output the requested sections and code.\n\nInputs\n\n1. C function under analysis.\n2. C test case that is currently failing.\n3. Rust interface relevant to the C function.\n\nYou must implement a single Rust function named `check_invariants`:\n1. Perform non-trivial pre and post condition checks derived from the C program\u2019s behavior.\n2. Use `assert!` / `assert_eq!` with clear failure messages that include key values.\n3. You should not add unit tests but rather infer general invariants that hold for all valid states of the program.\n4. A brief bullet list titled \u201cInvariants enforced\u201d summarizing each invariant in plain language (no derivations or chain-of-thought; just the final invariants).\n\nConstraints & style\n\n1. Use only items available in the Rust interface (no new public types or deps).\n2. Prefer safe Rust; do not use unsafe unless the interface explicitly requires it.\n3. No logging/printing. No randomness. No external crates.\n4. If the interface already includes a validator that returns Result, you may call it and assert on Ok/Err instead of re-implementing internals.\n\nImplementation checklist\n1. Read the Rust interface to understand how to construct states.\n2. From the C code, enumerate and infer candidate invariants. Keep only those that must hold for all reachable states.\n3. Valid cases: assert the invariant holds.\n\nNow you will be provided with the C source code and Rust interface definitions.\n\nC source (program under analysis):\n```c\nuint64_t clhash(const void* random, const char * stringbyte,\n                const size_t lengthbyte) {\n    assert(sizeof(size_t)<=sizeof(uint64_t));// otherwise, we need to worry\n    assert(((uintptr_t) random & 15) == 0);// we expect cache line alignment for the keys\n    const unsigned int  m = 128;// we process the data in chunks of 16 cache lines\n    if(CLHASH_DEBUG) assert((m  & 3) == 0); //m should be divisible by 4\n    const int m128neededperblock = m / 2;// that is how many 128-bit words of random bits we use per block\n    const __m128i * rs64 = (__m128i *) random;\n    __m128i polyvalue =  _mm_load_si128(rs64 + m128neededperblock); // to preserve alignment on cache lines for main loop, we pick random bits at the end\n    polyvalue = _mm_and_si128(polyvalue,_mm_setr_epi32(0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0x3fffffff));// setting two highest bits to zero\n    // we should check that polyvalue is non-zero, though this is best done outside the function and highly unlikely\n    const size_t length = lengthbyte / sizeof(uint64_t); // # of complete words\n    const size_t lengthinc = (lengthbyte + sizeof(uint64_t) - 1) / sizeof(uint64_t); // # of words, including partial ones\n\n    const uint64_t * string = (const uint64_t *)  stringbyte;\n    if (m < lengthinc) { // long strings // modified from length to lengthinc to address issue #3 raised by Eik List\n        __m128i  acc =  __clmulhalfscalarproductwithoutreduction(rs64, string,m);\n        size_t t = m;\n        for (; t +  m <= length; t +=  m) {\n            // we compute something like\n            // acc+= polyvalue * acc + h1\n            acc =  mul128by128to128_lazymod127(polyvalue,acc);\n            const __m128i h1 =  __clmulhalfscalarproductwithoutreduction(rs64, string+t,m);\n            acc = _mm_xor_si128(acc,h1);\n        }\n        const int remain = length - t;  // number of completely filled words\n\n        if (remain != 0) {\n            // we compute something like\n            // acc+= polyvalue * acc + h1\n            acc = mul128by128to128_lazymod127(polyvalue, acc);\n            if (lengthbyte % sizeof(uint64_t) == 0) {\n                const __m128i h1 =\n                    __clmulhalfscalarproductwithtailwithoutreduction(rs64,\n                            string + t, remain);\n                acc = _mm_xor_si128(acc, h1);\n            } else {\n                const uint64_t lastword = createLastWord(lengthbyte,\n                                          (string + length));\n                const __m128i h1 =\n                    __clmulhalfscalarproductwithtailwithoutreductionWithExtraWord(\n                        rs64, string + t, remain, lastword);\n                acc = _mm_xor_si128(acc, h1);\n            }\n        } else if (lengthbyte % sizeof(uint64_t) != 0) {// added to address issue #2 raised by Eik List\n            // there are no completely filled words left, but there is one partial word.\n            acc = mul128by128to128_lazymod127(polyvalue, acc);\n            const uint64_t lastword = createLastWord(lengthbyte, (string + length));\n            const __m128i h1 = __clmulhalfscalarproductOnlyExtraWord( rs64, lastword);\n            acc = _mm_xor_si128(acc, h1);\n        }\n\n        const __m128i finalkey = _mm_load_si128(rs64 + m128neededperblock + 1);\n        const uint64_t keylength = *(const uint64_t *)(rs64 + m128neededperblock + 2);\n        return simple128to64hashwithlength(acc,finalkey,keylength, (uint64_t)lengthbyte);\n    } else { // short strings\n        if(lengthbyte % sizeof(uint64_t) == 0) {\n            __m128i  acc = __clmulhalfscalarproductwithtailwithoutreduction(rs64, string, length);\n            const uint64_t keylength = *(const uint64_t *)(rs64 + m128neededperblock + 2);\n            acc = _mm_xor_si128(acc,lazyLengthHash(keylength, (uint64_t)lengthbyte));\n#ifdef BITMIX\n            return fmix64(precompReduction64(acc)) ;\n#else\n            return precompReduction64(acc) ;\n#endif\n        }\n        const uint64_t lastword = createLastWord(lengthbyte, (string + length));\n        __m128i acc = __clmulhalfscalarproductwithtailwithoutreductionWithExtraWord(\n                          rs64, string, length, lastword);\n        const uint64_t keylength =  *(const uint64_t *)(rs64 + m128neededperblock + 2);\n        acc = _mm_xor_si128(acc,lazyLengthHash(keylength, (uint64_t)lengthbyte));\n#ifdef BITMIX\n        return fmix64(precompReduction64(acc)) ;\n#else\n        return precompReduction64(acc) ;\n#endif\n    }\n}\n```\n\nC Tests (the test cases that are failing):\n\n```c\nstatic void clhashavalanchetest() {\n    const int N = 1024;\n    char * array  = (char*)malloc(N);\n    char * array1  = (char*)malloc(N);\n\n    char *  rs = (char*)malloc(RANDOM_BYTES_NEEDED_FOR_CLHASH);\n    for(int k = 0; k<N; ++k) {\n        array[k] = 0;\n        array1[k] = 0;\n    }\n    for(int k = 0; k<RANDOM_BYTES_NEEDED_FOR_CLHASH; ++k) {\n        rs[k] = k+1-k*k;\n    }\n    int K = 16;\n    printf(\"[clhashavalanchetest] Testing CLHASH avalanche effect.\\n\");\n\n    for(int bytelength = 1; bytelength < K; ++bytelength ) {\n\n        for(int whichcase = 0; whichcase < 256; ++whichcase) {\n\n            for(int k = 0; k<bytelength; ++k) {\n                array[k] = whichcase;\n                array1[k] = whichcase + 35;\n            }\n            uint64_t orighash = clhash(rs, array, bytelength);\n            uint64_t orighash1 = clhash(rs, array1, bytelength);\n\n            for(int z = 0; z < 8*bytelength; ++z) {\n                flipbit(array,bytelength,z);\n                uint64_t newhash = clhash(rs, array, bytelength);\n                flipbit(array,bytelength,z);\n                assert(orighash != newhash);\n\n                flipbit(array1,bytelength,z);\n                uint64_t newhash1 = clhash(rs, array1, bytelength);\n                flipbit(array1,bytelength,z);\n                assert(orighash1 != newhash1);\n\n                if((unsigned int) bytelength <= sizeof(uint64_t))\n                    assert((orighash ^ newhash) == (orighash1 ^ newhash1));\n\n            }\n        }\n    }\n    free(array);\n    free(array1);\n    free(rs);\n    printf(\"Test passed! \\n\");\n}\n\nstatic void clhashtest() {\n    const int N = 1024;\n    char * array  = (char*)malloc(N);\n    char *  rs = (char*)malloc(RANDOM_BYTES_NEEDED_FOR_CLHASH);\n    for(int k = 0; k<N; ++k) {\n        array[k] = 0;\n    }\n    for(int k = 0; k < RANDOM_BYTES_NEEDED_FOR_CLHASH ; ++k) {\n        rs[k] = (char) (1-k);\n    }\n\n    printf(\"[clhashtest] checking that flipping a bit changes hash value with clhash \\n\");\n    for(int bit = 0; bit < 64; ++bit ) {\n        for(int length = (bit+8)/8; length <= (int)sizeof(uint64_t); ++length) {\n            uint64_t x = 0;\n            uint64_t orig = clhash(rs, (const char *)&x, length);\n            x ^= ((uint64_t)1) << bit;\n            uint64_t flip = clhash(rs, (const char *)&x, length);\n            assert(flip != orig);\n            x ^= ((uint64_t)1) << bit;\n            uint64_t back = clhash(rs, (const char *)&x, length);\n            assert(back == orig);\n        }\n    }\n\n    free(array);\n    free(rs);\n    printf(\"Test passed! \\n\");\n}\n\nstatic void clhashcollisiontest() {\n    printf(\"[clhashcollisiontest] Testing whether we can induce collisions by hacking the right bytes (Eik List's test).\\n\");\n    const size_t NUM_TRIALS = 10;\n    const size_t CLNH_NUM_BYTES_PER_BLOCK = 1024;\n    const uint8_t KEY_OFFSET = 0x63; // Anything to prevent that K = M\n\n    uint8_t* k = (uint8_t*)malloc(RANDOM_BYTES_NEEDED_FOR_CLHASH);\n    size_t j2;\n\n    // Fill key with some deterministic information\n    for (j2 = 0; j2 < RANDOM_BYTES_NEEDED_FOR_CLHASH; ++j2) {\n        k[j2] = (j2 + KEY_OFFSET) & 0xFF;\n    }\n\n    for (size_t i = 1; i < NUM_TRIALS; ++i) {\n        for (size_t j = 1; j <= sizeof(uint64_t); ++j) {\n            // #Bytes / block + x, with 1 <= x < 8\n            const uint64_t mlen = i * CLNH_NUM_BYTES_PER_BLOCK + j;\n            uint8_t* m = (uint8_t*)malloc(mlen);\n\n            for (j2 = 0; j2 < mlen; ++j2) {\n                m[j2] = j2 & 0xFF;\n            }\n\n            const uint64_t actual1 = clhash(k, (const char*)m, mlen);\n\n            // Change final byte\n            m[mlen-1] = (m[mlen-1] + 1) & 0xFF;\n\n            const uint64_t actual2 = clhash(k, (const char*)m, mlen);\n            const int are_equal = !memcmp(&actual1, &actual2, sizeof(uint64_t));\n\n            if(are_equal) printf(\"Testing %\" PRIu64 \" bytes, H1: %\" PRIX64 \", H2: %\" PRIX64 \", equal: %d \\n\", mlen, actual1, actual2, are_equal);\n            free(m);\n            assert(!are_equal); // strictly speaking this would not be a bug, but if it happens, it is very likely to be a bug!\n        }\n    }\n\n    free(k);\n    printf(\"Test passed! \\n\");\n}\n```\n\nRust test that fails (the test case that currently fails):\n```rust\nfn clhash_avalanche_test() {\nconst N: usize = 1024;\nlet mut array = vec![0u8; N];\nlet mut array1 = vec![0u8; N];\nlet mut rs = vec![0u64; RANDOM_BYTES_NEEDED_FOR_CLHASH];\nfor k in 0..RANDOM_BYTES_NEEDED_FOR_CLHASH {\nrs[k] = (k + 1 - k * k) as u64;\n}\nlet rs = [rs[0], rs[1]];\nlet rs_bytes: &[u8] = bytemuck::bytes_of(&rs);\nconst K: usize = 16;\nprintln!(\"[clhashavalanchetest] Testing CLHASH avalanche effect.\");\nfor bytelength in 1..K {\nfor whichcase in 0..256 {\nfor k in 0..bytelength {\narray[k] = whichcase as u8;\narray1[k] = (whichcase + 35) as u8;\n}\nlet orighash = clhash(rs_bytes, &array[..bytelength]);\nlet orighash1 = clhash(rs_bytes, &array1[..bytelength]);\nfor z in 0..8 * bytelength {\nflipbit(&mut array, z as u32);\nlet newhash = clhash(rs_bytes, &array[..bytelength]);\nflipbit(&mut array, z as u32);\nassert_ne!(orighash, newhash);\nflipbit(&mut array1, z as u32);\nlet newhash1 = clhash(rs_bytes, &array1[..bytelength]);\nflipbit(&mut array1, z as u32);\nassert_ne!(orighash1, newhash1);\nif bytelength <= std::mem::size_of::<u64>() {\nassert_eq!(orighash ^ newhash, orighash1 ^ newhash1);\n}\n}\n}\n}\nprintln!(\"Test passed!\");\n}\n\n#[test]\nfn clhash_test() {\nconst N: usize = 1024;\nlet mut array = vec![0u8; N];\nlet mut rs = vec![0u64; RANDOM_BYTES_NEEDED_FOR_CLHASH];\nfor k in 0..RANDOM_BYTES_NEEDED_FOR_CLHASH {\nrs[k] = (1 - k) as u64;\n}\n// convert the vec into a tuple of (&[u8], &[u8])\nlet rs = [rs[0], rs[1]];\nlet rs_bytes: &[u8] = bytemuck::bytes_of(&rs);\nprintln!(\"[clhashtest] checking that flipping a bit changes hash value with clhash\");\nfor bit in 0..64 {\nfor length in ((bit + 8) / 8)..=std::mem::size_of::<u64>() {\nlet mut x: u64 = 0;\nlet orig = clhash(rs_bytes, &x.to_le_bytes()[..length]);\nx ^= 1 << bit;\nlet flip = clhash(rs_bytes, &x.to_le_bytes()[..length]);\nassert_ne!(flip, orig);\nx ^= 1 << bit;\nlet back = clhash(rs_bytes, &x.to_le_bytes()[..length]);\nassert_eq!(back, orig);\n}\n}\nprintln!(\"Test passed!\");\n}\n#[test]\nfn clhash_collision_test() {\nprintln!(\"[clhashcollisiontest] Testing whether we can induce collisions by hacking the right bytes (Eik List's test).\");\nconst NUM_TRIALS: usize = 10;\nconst CLNH_NUM_BYTES_PER_BLOCK: usize = 1024;\nconst KEY_OFFSET: u8 = 0x63;\nlet mut k = vec![0u64; RANDOM_BYTES_NEEDED_FOR_CLHASH];\nfor j2 in 0..RANDOM_BYTES_NEEDED_FOR_CLHASH {\nk[j2] = (j2 + KEY_OFFSET as usize) as u64 & 0xFF;\n}\nlet k = (k[0], k[1]);\nfor i in 1..NUM_TRIALS {\nfor j in 1..=std::mem::size_of::<u64>() {\nlet mlen = i * CLNH_NUM_BYTES_PER_BLOCK + j;\nlet mut m = vec![0u8; mlen];\nfor j2 in 0..mlen {\nm[j2] = (j2 & 0xFF) as u8;\n}\nlet k = [k.0, k.1];\nlet actual1 = clhash(bytemuck::bytes_of(&k), &m);\nm[mlen - 1] = (m[mlen - 1] + 1) & 0xFF;\nlet actual2 = clhash(bytemuck::bytes_of(&k), &m);\nlet are_equal = actual1 == actual2;\nif are_equal {\nprintln!(\"Testing {} bytes, H1: {:X}, H2: {:X}, equal: {}\", mlen, actual1, actual2, are_equal);\n}\nassert!(!are_equal);\n}\n}\nprintln!(\"Test passed!\");\n}\n```\n\n\nRust interface files (types, functions, signatures you MUST use to build test fixtures):\n```rust\npub fn clhash(random: &[u8], stringbyte: &[u8]) -> u64 {\nunimplemented!();\n}\n```\n\nPlease provide the final code in ```rust ``` tags"
}