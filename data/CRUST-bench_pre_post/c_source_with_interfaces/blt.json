{
    "name": "blt",
    "blt.c": "// See http://www.imperialviolet.org/binary/critbit.pdf\n//\n// Differences:\n//   - We only have one child pointer. We allocate sibling nodes at the same\n//     time; they lie in adjacent blocks of memory. The child pointer points\n//     to the left child. There is no waste because every node is either\n//     external or has two children.\n//   - We fold strcmp into the crit-bit finder. If there is no crit-bit\n//     then we have a match.\n//   - During lookup, if the key is shorter than the position of the\n//     crit bit in the current node, the path we take is irrelevant.\n//     Ideally, we'd take one of the shortest paths to a leaf (the only\n//     purpose is to get at a string so we can find the true crit bit),\n//     but for simplicity we always follow the left child.\n//     Our code skips a tiny bit of computation by assigning\n//     direction = 0 rather than c = 0 plus some bit twiddling.\n//   - Insertion: while walking down the tree (after we've figured out the crit\n//     bit), we're guaranteed that the byte number of the current node is less\n//     than the key length, so there's no need for special-case code to handle\n//     keys shorter than the crit bit.\n//   - We combine a couple of comparisons. Instead of byte0 < byte1 and then\n//     mask0 < mask1 if they are equal, we simplify to:\n//       (byte0 << 8) + mask0 < (byte1 << 8) + mask1\n//   - Deletion: we can return early if the key length is shorter than\n//     the current node's critical bit, as this implies the key is absent.\n//   - When following child pointers, rather than p->kid + predicate(),\n//     we prefer predicate() ? p->kid + 1 : p->kid, as this is faster on my\n//     system. We can thus relax predicate(): instead of returning 0 or 1,\n//     it's fine if it simply returns 0 or nonzero. This means we can store\n//     the plain bitmask instead of its inversion, and check the bit with\n//     a single AND.\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"blt.h\"\n\n// Returns the byte where each bit is 1 except for the bit corresponding to\n// the leading bit of x.\nstatic inline uint8_t to_mask(uint8_t x) {\n  // SWAR trick that sets every bit after the leading bit to 1.\n  x |= x >> 1;\n  x |= x >> 2;\n  x |= x >> 4;\n  // Zero all the bits after the leading bit then invert.\n  return x & ~(x >> 1);\n  if (0) {\n    // Alternative that performs better when there are few set bits.\n    // Zero all bits except leading bit with a bit-twiddling trick.\n    while (x&(x-1)) x &= x-1;\n    // Invert.\n    return 255 - x;\n  }\n}\n\n// An internal node. Leaf nodes are described by BLT_IT.\nstruct blt_node_s {\n  unsigned int byte:32;     // Byte # of difference.\n  unsigned int mask:8;      // ~mask = the crit bit within the byte.\n  unsigned int padding:23;\n  // The following bit corresponds to the last bit of the pointer to the key\n  // in the external node, which is always zero due to malloc alignment.\n  unsigned int is_internal:1;\n  struct blt_node_s *kid;\n};\ntypedef struct blt_node_s *blt_node_ptr;\n\nstatic inline blt_node_ptr follow(blt_node_ptr p, char *key) {\n  return key[p->byte] & p->mask ? p->kid + 1 : p->kid;\n}\n\nstruct BLT {\n  struct blt_node_s root[1];\n  int empty;\n};\n\nBLT *blt_new() {\n  BLT *blt = malloc(sizeof(*blt));\n  blt->empty = 1;\n  return blt;\n}\n\nvoid blt_clear(BLT *blt) {\n  void free_node(blt_node_ptr p) {\n    if (!p->is_internal) {\n      free(((BLT_IT *) p)->key);\n      return;\n    }\n    blt_node_ptr q = p->kid;\n    free_node(q);\n    free_node(q + 1);\n    free(q);\n  }\n  if (!blt->empty) free_node(blt->root);\n  free(blt);\n}\n\nsize_t blt_overhead(BLT *blt) {\n  size_t n = sizeof(BLT);\n  if (blt->empty) return n;\n  void add(blt_node_ptr p) {\n    if (p->is_internal) {\n      n += 2 * sizeof(struct blt_node_s);\n      add(p->kid);\n      add(p->kid + 1);\n    }\n  }\n  add(blt->root);\n  return n;\n}\n\nvoid blt_dump(BLT* blt, blt_node_ptr p) {\n  if (blt->empty) return;\n  if (p->is_internal) {\n    blt_dump(blt, p->kid);\n    blt_dump(blt, p->kid + 1);\n    return;\n  }\n  printf(\"  %s\\n\", (char *) ((BLT_IT *) p)->key);\n}\n\nstatic BLT_IT *blt_firstlast(blt_node_ptr p, int dir) {\n  if (!p) return 0;\n  while (p->is_internal) p = ((blt_node_ptr)p->kid) + dir;\n  return (BLT_IT *)p;\n}\n\nBLT_IT *blt_first(BLT *blt) {\n  return blt->empty ? 0 : blt_firstlast(blt->root, 0);\n}\n\nBLT_IT *blt_last (BLT *blt) {\n  return blt->empty ? 0 : blt_firstlast(blt->root, 1);\n}\n\nBLT_IT *blt_next(BLT *blt, BLT_IT *it) {\n  blt_node_ptr p = blt->root, other = 0;\n  while (p->is_internal) {\n    if (!(it->key[p->byte] & p->mask)) {\n      other = p->kid + 1;\n      p = p->kid;\n    } else {\n      p = p->kid + 1;\n    }\n  }\n  assert(!strcmp(((BLT_IT *)p)->key, it->key));\n  return blt_firstlast(other, 0);\n}\n\nBLT_IT *blt_prev(BLT *blt, BLT_IT *it) {\n  blt_node_ptr p = blt->root, other = 0;\n  while (p->is_internal) {\n    if (it->key[p->byte] & p->mask) {\n      other = p->kid;\n      p = p->kid + 1;\n    } else {\n      p = p->kid;\n    }\n  }\n  assert(!strcmp(((BLT_IT *)p)->key, it->key));\n  return blt_firstlast(other, 1);\n}\n\n// Walk down the tree as if the key is there.\nstatic inline BLT_IT *confident_get(BLT *blt, char *key) {\n  if (blt->empty) return 0;\n  blt_node_ptr p = blt->root;\n  int keylen = strlen(key);\n  while (p->is_internal) {\n    // When p->byte >= keylen, key is absent, but we must return something.\n    // Either kid works; we pick 0 each time.\n    p = p->byte < keylen && (key[p->byte] & p->mask) ? p->kid + 1 : p->kid;\n  }\n  return (void *)p;\n}\n\nBLT_IT *blt_ceilfloor(BLT *blt, char *key, int way) {\n  BLT_IT *p = confident_get(blt, key);\n  if (!p) return 0;\n  // Compare keys.\n  for(char *c = key, *pc = p->key;; c++, pc++) {\n    // XOR the current bytes being compared.\n    uint8_t x = *c ^ *pc;\n    if (x) {\n      int byte = c - key;\n      x = to_mask(x);\n      // Walk down the tree until we hit an external node or a node\n      // whose crit bit is higher.\n      blt_node_ptr p = blt->root, other = 0;\n      while (p->is_internal) {\n        if ((byte << 8) + p->mask < (p->byte << 8) + x) break;\n        int dir = !!(p->mask & key[p->byte]);\n        blt_node_ptr q = p->kid;\n        if (dir == way) other = q + 1 - way;\n        p = q + dir;\n      }\n      int ndir = !!(x & key[byte]);\n      if (ndir == way) other = p;\n      return blt_firstlast(other, way);\n    }\n    if (!*c) return (BLT_IT *)p;\n  }\n}\n\nBLT_IT *blt_ceil (BLT *blt, char *key) { return blt_ceilfloor(blt, key, 0); }\nBLT_IT *blt_floor(BLT *blt, char *key) { return blt_ceilfloor(blt, key, 1); }\n\nBLT_IT *blt_setp(BLT *blt, char *key, int *is_new) {\n  BLT_IT *p = confident_get(blt, key);\n  if (!p) {  // Empty tree case.\n    blt->empty = 0;\n    BLT_IT *leaf = (BLT_IT *) blt->root;\n    leaf->key = strdup(key);\n    leaf->data = 0;\n    if (is_new) *is_new = 1;\n    return leaf;\n  }\n  // Compare keys.\n  for(char *c = key, *pc = p->key;; c++, pc++) {\n    // XOR the current bytes being compared.\n    uint8_t x = *c ^ *pc;\n    if (x) {\n      // Allocate 2 adjacent nodes and copy the leaf into the appropriate side.\n      blt_node_ptr n = malloc(2 * sizeof(*n));\n      x = to_mask(x);\n      BLT_IT *leaf = (BLT_IT *)n;\n      blt_node_ptr other = n;\n      if (*c & x) leaf++; else other++;\n\n      leaf->key = strdup(key);\n      leaf->data = 0;\n\n      // Find the first node in the path whose critbit is higher than ours,\n      // or the external node.\n      int byte = c - key;\n      blt_node_ptr p = (blt_node_ptr) blt->root;\n      while(p->is_internal) {\n        if ((byte << 8) + p->mask < (p->byte << 8) + x) break;\n        p = follow(p, key);\n      }\n\n      // Copy the node's contents to the other side of our 2 new adjacent nodes,\n      // then replace it with our critbit and pointer to the new nodes.\n      *other = *p;\n      p->byte = byte;\n      p->mask = x;\n      p->kid = n;\n      p->is_internal = 1;\n      if (is_new) *is_new = 1;\n      return leaf;\n    }\n    if (!*c) {\n      if (is_new) *is_new = 0;\n      return p;\n    }\n  }\n}\n\nBLT_IT *blt_set(BLT *blt, char *key) { return blt_setp(blt, key, 0); }\n\nBLT_IT *blt_put(BLT *blt, char *key, void *data) {\n  BLT_IT *it = blt_set(blt, key);\n  it->data = data;\n  return it;\n}\n\nint blt_put_if_absent(BLT *blt, char *key, void *data) {\n  int is_new;\n  BLT_IT *it = blt_setp(blt, key, &is_new);\n  if (is_new) it->data = data;\n  return !is_new;\n}\n\nint blt_delete(BLT *blt, char *key) {\n  if (blt->empty) return 0;\n  int keylen = strlen(key);\n  blt_node_ptr p = blt->root, p0 = 0;\n  while (p->is_internal) {\n    if (p->byte > keylen) return 0;\n    p0 = p;\n    p = follow(p, key);\n  }\n  BLT_IT *leaf = (BLT_IT *)p;\n  if (strcmp(key, leaf->key)) return 0;\n  free(leaf->key);\n  if (!p0) {\n    blt->empty = 1;\n    return 1;\n  }\n  blt_node_ptr q = p0->kid;\n  *p0 = *(p == q ? q + 1 : q);\n  free(q);\n  return 1;\n}\n\nint blt_allprefixed(BLT *blt, char *key, int (*fun)(BLT_IT *)) {\n  if (blt->empty) return 1;\n  blt_node_ptr p = blt->root, top = p;\n  int keylen = strlen(key);\n  while (p->is_internal) {\n    if (p->byte >= keylen) {\n      p = p->kid;\n    } else {\n      p = follow(p, key);\n      top = p;\n    }\n  }\n  if (strncmp(key, ((BLT_IT *)p)->key, keylen)) return 1;\n  int traverse(blt_node_ptr p) {\n    if (p->is_internal) {\n      int status = traverse(p->kid);\n      if (status != 1) return status;\n      status = traverse(p->kid + 1);\n      if (status != 1) return status;\n      return 1;\n    }\n    return fun((BLT_IT *)p);\n  }\n  return traverse(top);\n}\n\nBLT_IT *blt_get(BLT *blt, char *key) {\n  if (blt->empty) return 0;\n  blt_node_ptr p = blt->root;\n  int keylen = strlen(key);\n  while (p->is_internal) {\n    // We could shave off a few percent by skipping checks like the\n    // following, but buffer overreads are bad form.\n    if (p->byte > keylen) return 0;\n    p = follow(p, key);\n  }\n  BLT_IT *r = (BLT_IT *)p;\n  return strcmp(key, r->key) ? 0 : r;\n}\n\nint blt_empty(BLT *blt) {\n  return blt->empty;\n}\n\nint blt_size(BLT *blt) {\n  int r = 0;\n  void f(BLT_IT *it) { r++; }\n  blt_forall(blt, f);\n  return r;\n}\n",
    "blt.h": "// = Crit-bit trees =\n//\n// Usage:\n//\n//   // Create a new tree.\n//   BLT* blt = blt_new();\n//\n//   // Insert a couple of keys.\n//   blt_put(blt, \"hello\", pointer1);\n//   blt_put(blt, \"world\", pointer2);\n//\n//   // Check they have the values we expect.\n//   if (blt_get(blt, \"hello\")->data != pointer1 ||\n//       blt_get(blt, \"hello\")->data != pointer2) exit(1);\n//\n//   // Delete the tree.\n//   blt_clear(blt);\n\nstruct BLT;\ntypedef struct BLT BLT;\nstruct BLT_IT {\n  char *key;\n  void *data;\n};\ntypedef struct BLT_IT BLT_IT;\n\n// Creates a new tree.\nBLT *blt_new();\n\n// Destroys a tree.\nvoid blt_clear(BLT *blt);\n\n// Retrieves the leaf node at a given key.\n// Returns NULL if there is no such key.\nBLT_IT *blt_get(BLT *blt, char *key);\n\n// Creates or retrieves the leaf node at a given key.\nBLT_IT *blt_set(BLT *blt, char *key);\n\n// Creates or retrieves the leaf node at a given key.\n// If is_new is not NULL, sets *is_new to 1 if a new node was created,\n// and 0 otherwise.\nBLT_IT *blt_setp(BLT *blt, char *key, int *is_new);\n\n// Inserts a given key and data pair.\n// Returns the leaf node containing them.\nBLT_IT *blt_put(BLT *blt, char *key, void *data);\n\n// Inserts a given key and data pair if key is absent.\n// Returns 0 on success. Returns 1 if key is already present.\nint blt_put_if_absent(BLT *blt, char *key, void *data);\n\n// Deletes a given key from the tree.\n// Returns 1 if a key was deleted, and 0 otherwise.\nint blt_delete(BLT *blt, char *key);\n\n// Iterates through all leaf nodes with a given prefix in order and runs the\n// given callback on each one.\n// If the callback returns 1, continues iteration, otherwise halts and returns\n// the value returned by the callback.\nint blt_allprefixed(BLT *blt, char *key, int (*fun)(BLT_IT *));\n\n// Iterates through all leaf nodes in order and runs the given callback.\nstatic inline void blt_forall(BLT *blt, void (*fun)(BLT_IT *)) {\n  int f(BLT_IT *it) { return fun(it), 1; }\n  blt_allprefixed(blt, \"\", f);\n}\n\n// Returns the leaf node with the smallest key.\nBLT_IT *blt_first(BLT *blt);\n\n// Returns the leaf node with the largest key.\nBLT_IT *blt_last (BLT *blt);\n\n// Returns the leaf node with the next largest key.\nBLT_IT *blt_next(BLT *blt, BLT_IT *it);\n\n// Returns the leaf node with the next smallest key.\nBLT_IT *blt_prev(BLT *blt, BLT_IT *it);\n\n// If the given key is present, returns its leaf node.\n// Otherwise returns the leaf node with the next largest key if it exists,\n// and NULL otherwise.\nBLT_IT *blt_ceil (BLT *blt, char *key);\n\n// If the given key is present, returns its leaf node.\n// Otherwise returns the leaf node with the next smallest key if it exists,\n// and NULL otherwise.\nBLT_IT *blt_floor(BLT *blt, char *key);\n\n// Returns the number of bytes used by the tree, excluding memory taken by\n// the bytes of the keys.\nsize_t blt_overhead(BLT *blt);\n\n// Returns 1 if tree is empty, 0 otherwise.\nint blt_empty(BLT *blt);\n\n// Returns number of keys.\nint blt_size(BLT *blt);\n",
    "bm.c": "// Simple benchmark library.\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\nstatic struct timespec bm_tp[2];\n\nvoid bm_init() {\n  clock_gettime(CLOCK_MONOTONIC, bm_tp);\n}\n\nvoid bm_report(char *msg) {\n  clock_gettime(CLOCK_MONOTONIC, bm_tp + 1);\n  printf(\"%s: %ld.%09lds\\n\", msg,\n      bm_tp[1].tv_sec - bm_tp[0].tv_sec - (bm_tp[1].tv_nsec < bm_tp[0].tv_nsec),\n      bm_tp[1].tv_nsec - bm_tp[0].tv_nsec\n          + (bm_tp[1].tv_nsec < bm_tp[0].tv_nsec) * 1000000000L);\n  clock_gettime(CLOCK_MONOTONIC, bm_tp);\n}\n\nvoid bm_read_keys(void (*cb)(char **key, int m)) {\n  char **key;\n  int max = 8, m = 0;\n  key = malloc(sizeof(*key) * max);\n  for (;;) {\n    char *s = 0;\n    size_t n;\n    ssize_t len = getline(&s, &n, stdin);\n    if (feof(stdin)) break;\n    if (len == -1) perror(\"getline\"), exit(1);\n    if (s[len - 1] == '\\n') s[len - 1] = 0;\n    key[m++] = s;\n    if (m == max) max *= 2, key = realloc(key, sizeof(*key) * max);\n  }\n  // Randomize order of array.\n  for (int i = m-1; i>1; i--) {\n    int j = random() % i;\n    char *tmp = key[i];\n    key[i] = key[j];\n    key[j] = tmp;\n  }\n  cb(key, m);\n}\n",
    "bm.h": "void bm_init();\nvoid bm_report(char *msg);\nvoid bm_read_keys(void (*cb)(char **key, int m));\n",
    "cbt.c": "#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"cbt.h\"\n\n#define NDEBUG\n#include <assert.h>\n\nstruct cbt_node_s {\n  short crit;\n  struct cbt_node_s *left, *right;\n};\ntypedef struct cbt_node_s cbt_node_t[1];\ntypedef struct cbt_node_s *cbt_node_ptr;\n\nstruct cbt_leaf_s {\n  short crit;\n  void *data;\n  char *key;\n  struct cbt_leaf_s *prev, *next;\n};\ntypedef struct cbt_leaf_s cbt_leaf_t[1];\ntypedef struct cbt_leaf_s *cbt_leaf_ptr;\n\nstruct cbt_s {\n  int count;\n  cbt_node_ptr root;\n  struct cbt_leaf_s *first, *last;\n  void *(*dup)(cbt_t, const void *);\n  int (*getlen)(cbt_t, const void *);\n  int (*cmp)(cbt_t, const void *, const void *);\n  int (*getcrit)(cbt_t, const void *, const void *);\n  int len;\n};\n\nenum { EXT = -1 };\n\nvoid cbt_node_free(cbt_node_ptr t) {\n  if (!t) return;\n  if (EXT == t->crit) {\n    free(((cbt_leaf_ptr) t)->key);\n  } else {\n    cbt_node_free(t->left), cbt_node_free(t->right);\n  }\n  free(t);\n}\n\nstatic void cbt_init(cbt_t cbt) {\n  cbt->count = 0;\n  cbt->root = 0;\n  cbt->first = cbt->last = 0;\n}\n\nstatic int getcrit(cbt_t unused, const void *key0, const void *key1) {\n  const char *c0 = key0, *c1 = key1;\n  int bit;\n\n  while(*c0 == *c1) {\n    if (!*c0) return 0;\n    c0++, c1++;\n  }\n\n  char c = *c0 ^ *c1;\n  for (bit = 7; !(c >> bit); bit--);\n  // Subtract bit from 7 because we number them the other way.\n  // Add 1 because we want to use the sign as an extra bit of information.\n  // We'll subtract 1 from it later.\n  int crit = ((c0 - (const char *) key0) << 3) + 7 - bit + 1;\n  if ((*c0 >> bit) & 1) return crit;\n  return -crit;\n}\n\nstatic int cmp(cbt_t unused, const void *key0, const void *key1) {\n  return strcmp(key0, key1);\n}\n\nstatic int getlen(cbt_t unused, const void *key) {\n  // The terminating NUL counts as part of the key, though when in doubt we\n  // take the left branch so it works without the \"+ 1\".\n  return strlen(key) + 1;\n}\n\nstatic void *dup(cbt_t unused, const void *key) { return strdup(key); }\n\ncbt_t cbt_new(void) {\n  cbt_t res = malloc(sizeof(*res));\n  cbt_init(res);\n  res->len = 0;\n  res->cmp = cmp;\n  res->dup = dup;\n  res->getlen = getlen;\n  res->getcrit = getcrit;\n  return res;\n}\n\nstatic int getcrit_u(cbt_t cbt, const void *key0, const void *key1) {\n  const char *cp0 = key0, *limit = key0 + cbt->len, *cp1 = key1;\n\n  for(;;) {\n    if (cp0 == limit) return 0;\n    if (*cp0 != *cp1) break;\n    cp0++, cp1++;\n  }\n\n  int bit;\n  char c = *cp0 ^ *cp1;\n  for (bit = 7; !(c >> bit); bit--);\n  // Subtract bit from 7 because we number them the other way.\n  // Add 1 because we want to use the sign as an extra bit of information.\n  // We'll subtract 1 from it later.\n  int crit = ((cp0 - (const char *) key0) << 3) + 7 - bit + 1;\n  if ((*cp0 >> bit) & 1) return crit;\n  return -crit;\n}\n\nstatic int cmp_u(cbt_t cbt, const void *key0, const void *key1) {\n  return memcmp(key0, key1, cbt->len);\n}\n\nstatic void *dup_u(cbt_t cbt, const void *key) {\n  void *res = malloc(cbt->len);\n  memcpy(res, key, cbt->len);\n  return res;\n}\n\nstatic int getlen_u(cbt_t cbt, const void *unused) { return cbt->len; }\n\ncbt_t cbt_new_u(int len) {\n  cbt_t res = malloc(sizeof(*res));\n  cbt_init(res);\n  res->len = len;\n  res->cmp = cmp_u;\n  res->getlen = getlen_u;\n  res->dup = dup_u;\n  res->getcrit = getcrit_u;\n  return res;\n}\n\nstatic int getlen_enc(cbt_t unused, const void *key) {\n  const uint8_t *u = (const uint8_t *) key;\n  return *u + (u[1] << 8);\n}\n\nstatic int cmp_enc(cbt_t cbt, const void *key0, const void *key1) {\n  int len = getlen_enc(0, key0);\n  return getlen_enc(0, key1) != len ? 1 : memcmp(key0, key1, len + 2);\n}\n\nstatic void *dup_enc(cbt_t cbt, const void *key) {\n  int len = getlen_enc(0, key) + 2;\n  void *res = malloc(len);\n  memcpy(res, key, len);\n  return res;\n}\n\nstatic int getcrit_enc(cbt_t cbt, const void *key0, const void *key1) {\n  int n = getlen_enc(0, key0), n1 = getlen_enc(0, key1);\n  if (n > n1) n = n1;\n  const char *cp0 = key0, *limit = key0 + n + 2, *cp1 = key1;\n\n  for(;;) {\n    if (cp0 == limit) return 0;\n    if (*cp0 != *cp1) break;\n    cp0++, cp1++;\n  }\n\n  int bit;\n  char c = *cp0 ^ *cp1;\n  for (bit = 7; !(c >> bit); bit--);\n  // Subtract bit from 7 because we number them the other way.\n  // Add 1 because we want to use the sign as an extra bit of information.\n  // We'll subtract 1 from it later.\n  int crit = ((cp0 - (const char *) key0) << 3) + 7 - bit + 1;\n  return (*cp0 >> bit) & 1 ? crit : -crit;\n}\n\ncbt_t cbt_new_enc() {\n  cbt_t res = malloc(sizeof(*res));\n  cbt_init(res);\n  res->len = 0;\n  res->cmp = cmp_enc;\n  res->getlen = getlen_enc;\n  res->dup = dup_enc;\n  res->getcrit = getcrit_enc;\n  return res;\n}\n\nstatic void cbt_clear(cbt_t cbt) { cbt_node_free(cbt->root); }\n\nvoid cbt_delete(cbt_t cbt) {\n  cbt_clear(cbt);\n  free(cbt);\n}\n\nint cbt_size(cbt_t cbt) { return cbt->count; }\ncbt_it cbt_first(cbt_t cbt) { return cbt->first; }\ncbt_it cbt_last(cbt_t cbt) { return cbt->last; }\ncbt_it cbt_next(cbt_it it) { return it->next; }\nvoid cbt_put(cbt_it it, void *data) { it->data = data; }\nvoid *cbt_get(cbt_it it) { return it->data; }\nchar *cbt_key(cbt_it it) { return it->key; }\n\nstatic int testbit(const void *key, int bit) {\n  // The most significant bit is 0, and the least 7.\n  return (1 << (7 - (bit & 7))) & ((const char *) key)[bit >> 3];\n}\n\ncbt_it cbt_at(cbt_t cbt, const void *key) {\n  if (!cbt->root) return 0;\n  int len = (cbt->getlen(cbt, key) << 3) - 1;\n  cbt_node_ptr p = cbt->root;\n  for (;;) {\n    if (EXT == p->crit) break;\n    if (len < p->crit) {\n      do p = p->left; while (EXT != p->crit);\n      break;\n    }\n    p = testbit(key, p->crit) ? p->right : p->left;\n  }\n  if (!cbt->cmp(cbt, ((cbt_leaf_ptr) p)->key, key)) return (cbt_leaf_ptr) p;\n  return 0;\n}\n\nint cbt_has(cbt_t cbt, const void *key) { return cbt_at(cbt, key) != 0; }\n\nvoid *cbt_get_at(cbt_t cbt, const void *key) {\n  cbt_leaf_ptr p = cbt_at(cbt, key);\n  if (!p) return 0;\n  return p->data;\n}\n\nint cbt_insert_with(cbt_it *it, cbt_t cbt, void *(*fn)(void *), const void *key) {\n  if (!cbt->root) {\n    cbt_leaf_ptr leaf = malloc(sizeof(cbt_leaf_t));\n    leaf->crit = EXT, leaf->data = fn(0), leaf->key = cbt->dup(cbt, key);\n    cbt->root = (cbt_node_ptr) leaf;\n    cbt->first = cbt->last = leaf;\n    leaf->next = leaf->prev = 0;\n    cbt->count++;\n    return *it = leaf, 1;\n  }\n\n  cbt_node_ptr t = cbt->root;\n  int keylen = (cbt->getlen(cbt, key) << 3) - 1;\n\n  while (EXT != t->crit) {\n    // If the key is shorter than the remaining keys on this subtree, we can\n    // compare it against any of them (and are guaranteed the new node must be\n    // inserted above this node). We simply let it follow the rightmost path.\n    t = keylen < t->crit || testbit(key, t->crit) ? t->right : t->left;\n  }\n\n  cbt_leaf_ptr leaf = (cbt_leaf_ptr) t;\n  int res = cbt->getcrit(cbt, key, leaf->key);\n  if (!res) {\n    leaf->data = fn(leaf->data);\n    return *it = leaf, 0;\n  }\n\n  cbt->count++;\n  cbt_leaf_ptr pleaf = malloc(sizeof(cbt_leaf_t));\n  cbt_node_ptr pnode = malloc(sizeof(cbt_node_t));\n  pleaf->crit = EXT, pleaf->data = fn(0), pleaf->key = cbt->dup(cbt, key);\n  pnode->crit = abs(res) - 1;\n\n  cbt_node_ptr t0 = 0, t1 = cbt->root;\n  while(EXT != t1->crit && pnode->crit > t1->crit) {\n    t0 = t1, t1 = testbit(key, t1->crit) ? t1->right : t1->left;\n  }\n\n  if (res > 0) {\n    // Key is bigger, therefore it goes on the right.\n    pnode->left = t1;\n    pnode->right = (cbt_node_ptr) pleaf;\n    // The rightmost child of the left subtree must be the predecessor.\n    for (t = pnode->left; t->crit != EXT; t = t->right);\n    cbt_leaf_ptr leaf = (cbt_leaf_ptr) t;\n    pleaf->next = leaf->next;\n    pleaf->prev = leaf;\n    if (leaf->next) leaf->next->prev = pleaf;\n    else cbt->last = pleaf;\n    leaf->next = pleaf;\n  } else {\n    // Key is smaller, therefore it goes on the left.\n    pnode->left = (cbt_node_ptr) pleaf;\n    pnode->right = t1;\n    // The leftmost child of the right subtree must be the successor.\n    for (t = pnode->right; t->crit != EXT; t = t->left);\n    cbt_leaf_ptr leaf = (cbt_leaf_ptr) t;\n    pleaf->prev = leaf->prev;\n    pleaf->next = leaf;\n    if (leaf->prev) leaf->prev->next = pleaf;\n    else cbt->first = pleaf;\n    leaf->prev = pleaf;\n  }\n\n  if (!t0) {\n    cbt->root = pnode;\n  } else if (t0->left == t1) {\n    t0->left = pnode;\n  } else {\n    t0->right = pnode;\n  }\n  return *it = pleaf, 1;\n}\n\ncbt_it cbt_put_with(cbt_t cbt, void *(*fn)(void *), const void *key) {\n  cbt_it it;\n  cbt_insert_with(&it, cbt, fn, key);\n  return it;\n}\n\ncbt_it cbt_put_at(cbt_t cbt, void *data, const void *key) {\n  void *returndata(void *p) { return data; }\n  return cbt_put_with(cbt, returndata, key);\n}\n\nvoid *cbt_remove(cbt_t cbt, const void *key) {\n  assert(cbt->root);\n  assert(cbt_has(cbt, key));\n  cbt_node_ptr t0 = 0, t00 = 0, t = cbt->root;\n  while (EXT != t->crit) {\n    assert((cbt->getlen(cbt, key) << 3) - 1 >= t->crit);\n    t00 = t0, t0 = t, t = testbit(key, t->crit) ? t->right : t->left;\n  }\n  cbt->count--;\n  cbt_leaf_ptr p = (cbt_leaf_ptr) t;\n  if (!t0) {\n    cbt->root = 0;\n  } else {\n    cbt_node_ptr sibling = t0->left == t ? t0->right : t0->left;\n    if (!t00) {  // One-level down: reassign root.\n      cbt->root = sibling;\n    } else {  // Reassign grandparent.\n      if (t00->left == t0) {\n        t00->left = sibling;\n      } else {\n        t00->right = sibling;\n      }\n    }\n    free(t0);\n  }\n  if (p->next) p->next->prev = p->prev;\n  else cbt->last = p->prev;\n  if (p->prev) p->prev->next = p->next;\n  else cbt->first = p->next;\n  free(p->key);\n  void *data = p->data;\n  free(p);\n  return data;\n}\n\nstatic void clear_recurse(cbt_node_ptr t, void (*fn)(void *, const void *)) {\n  if (EXT == t->crit) {\n    cbt_leaf_ptr p = (cbt_leaf_ptr) t;\n    if (fn) fn(p->data, p->key);\n    free(p->key);\n    free(p);\n    return;\n  }\n  clear_recurse(t->left, fn);\n  clear_recurse(t->right, fn);\n  free(t);\n}\n\nvoid cbt_remove_all_with(cbt_t cbt, void (*fn)(void *data, const void *key)) {\n  if (cbt->root) {\n    clear_recurse(cbt->root, fn);\n    cbt->root = 0;\n    cbt->count = 0;\n    cbt->first = cbt->last = 0;\n  }\n}\n\nvoid cbt_remove_all(cbt_t cbt) {\n  if (cbt->root) cbt_remove_all_with(cbt, 0);\n}\n\nvoid cbt_forall(cbt_t cbt, void (*fn)(cbt_it)) {\n  cbt_leaf_ptr p;\n  for (p = cbt->first; p; p = p->next) fn(p);\n}\n\nvoid cbt_forall_at(cbt_t cbt, void (*fn)(void *data, const void *key)) {\n  cbt_leaf_ptr p;\n  for (p = cbt->first; p; p = p->next) fn(p->data, p->key);\n}\n\nsize_t cbt_overhead(cbt_t cbt) {\n  size_t n = sizeof(struct cbt_s);\n  if (!cbt->root) return n;\n  void add(cbt_node_ptr p) {\n    if (p->crit == EXT) {\n      n += sizeof(struct cbt_leaf_s);\n    } else {\n      n += sizeof(struct cbt_node_s);\n      add(p->left);\n      add(p->right);\n    }\n  }\n  add(cbt->root);\n  return n;\n}\n",
    "cbt.h": "// Crit-bit trees and linked list.\n// No parent pointers.\n//\n// Uses pointer casting and different structs instead of unions.\n// In a trie, internal nodes never become external nodes, and vice versa.\n//\n// Removing linked list code and data saves a little.\n\n#define __CBT_H__\n\nstruct cbt_s;\ntypedef struct cbt_s *cbt_t;\n\nstruct cbt_leaf_s;\n// Iterator.\ntypedef struct cbt_leaf_s *cbt_it;\n\n// Never mix keys from different types of trees.\n\n// Default: ASCIIZ keys.\ncbt_t cbt_new(void);\n\n// \"u\" mode: all keys are the same length but can contain any data.\n// e.g. SHA1 hashes.\ncbt_t cbt_new_u(int len);\n\n// \"enc\" mode: First 2 bytes encode length of remaining data. First byte\n// is the least significant.\ncbt_t cbt_new_enc();\n\nvoid cbt_delete(cbt_t cbt);\n\nvoid *cbt_get_at(cbt_t cbt, const void *key);\ncbt_it cbt_put_at(cbt_t cbt, void *data, const void *key);\n\nint cbt_size(cbt_t cbt);\n\nstatic inline int cbt_is_off(cbt_it it) { return !it; }\n\ncbt_it cbt_first(cbt_t cbt);\ncbt_it cbt_last(cbt_t cbt);\ncbt_it cbt_next(cbt_it it);\nvoid cbt_put(cbt_it it, void *data);\nvoid *cbt_get(cbt_it it);\nchar *cbt_key(cbt_it it);\n\ncbt_it cbt_at(cbt_t cbt, const void *key);\nint cbt_has(cbt_t cbt, const void *key);\n\nvoid cbt_forall(cbt_t cbt, void (*fn)(cbt_it));\nvoid cbt_forall_at(cbt_t cbt, void (*fn)(void *data, const void *key));\n\nvoid *cbt_remove(cbt_t cbt, const void *key);\nvoid cbt_remove_all(cbt_t cbt);\nvoid cbt_remove_all_with(cbt_t cbt, void (*fn)(void *data, const void *key));\n\nstatic inline void cbt_clear_with(cbt_t cbt,\n    void (*fn)(void *data, const void *key)) {\n  cbt_remove_all_with(cbt, fn);\n}\n\ncbt_it cbt_put_with(cbt_t cbt, void *(*fn)(void *), const void *key);\n\n// Finds or creates an entry with the given key and writes it to *it.\n// Returns 1 if a new cbt_it was created.\nint cbt_insert(cbt_it *it, cbt_t cbt, const void *key);\n\nsize_t cbt_overhead(cbt_t cbt);\n",
    "c_rust": "",
    "c_rust_pre_post_conditions": "// Preconditions and Postconditions for blt.rs\n\nFunction: blt_new  \nPreconditions:\n- none  \nPostconditions:\n- returns a fresh Blt  \n- Blt.empty == 1 (tree is empty)  \n- no leaf nodes exist  \n\nFunction: blt_clear(&mut self)  \nPreconditions:\n- self was obtained from blt_new() or still lives from previous operations  \nPostconditions:\n- all internal and external nodes have been freed  \n- any memory allocated for keys and data has been freed  \n- self must not be used for further operations (in C it is freed)  \n\nFunction: blt_get(&self, key: &str) -> Option<BltIt>  \nPreconditions:\n- self is a valid Blt  \n- key is any valid UTF-8 string slice  \nPostconditions:\n- if the tree contains exactly that key, returns Some(it) where it.key == key and it.data is unchanged  \n- otherwise returns None  \n- the tree is not modified  \n\nFunction: blt_set(&mut self, key: &str) -> BltIt  \nPreconditions:\n- self is a valid Blt  \n- key is any valid UTF-8 string slice  \nPostconditions:\n- if key was not already in the tree, a new leaf is allocated, key duplicated, data set to None  \n- if key was already present, no new allocation for tree structure (except possible duplicate of key in C code)  \n- returns the leaf node holding that key  \n\nFunction: blt_setp(&mut self, key: &str) -> (BltIt, bool)  \nPreconditions:\n- same as blt_set  \nPostconditions:\n- same as blt_set  \n- second return value is true if a new leaf was created, false if key was already present  \n\nFunction: blt_put(&mut self, key: &str, data: Box<dyn Any>) -> BltIt  \nPreconditions:\n- self is a valid Blt  \n- key is any valid UTF-8 string slice  \n- data is any boxed payload  \nPostconditions:\n- ensures a leaf for key exists (inserting if necessary)  \n- sets the leaf\u2019s data to the provided data (overwriting if key existed)  \n- returns the leaf node  \n\nFunction: blt_put_if_absent(&mut self, key: &str, data: Box<dyn Any>) -> i32  \nPreconditions:\n- self is a valid Blt  \nPostconditions:\n- if key was absent: inserts a new leaf with that key and data, returns 0  \n- if key was present: does not overwrite existing data, returns 1  \n\nFunction: blt_delete(&mut self, key: &str) -> i32  \nPreconditions:\n- self is a valid Blt  \nPostconditions:\n- if key was present: removes its leaf, frees its memory (key & data), returns 1  \n- if key was not present or tree empty: does nothing, returns 0  \n\nFunction: blt_allprefixed<F>(&self, prefix: &str, mut fun: F) -> i32 \n    where F: FnMut(&BltIt) -> i32  \nPreconditions:\n- self is a valid Blt  \n- prefix is any &str  \n- fun is a callback returning an i32  \nPostconditions:\n- visits in-order all leaves whose key starts with prefix  \n- for each visited leaf calls fun(it)  \n- if fun returns 1, iteration continues  \n- if fun returns v != 1, iteration stops and blt_allprefixed returns v  \n- if iteration completes with all fun(it)==1, returns 1  \n- tree is not modified  \n\nFunction: blt_forall<F>(&self, mut fun: F)  \n    where F: FnMut(&BltIt)  \nPreconditions:\n- self is a valid Blt  \nPostconditions:\n- calls fun(it) on every leaf in ascending key order  \n- does not modify the tree  \n\nFunction: blt_first(&self) -> Option<BltIt>  \nPreconditions:\n- self is a valid Blt  \nPostconditions:\n- if tree is empty returns None  \n- otherwise returns Some(it) where it.key is the lexicographically smallest key  \n\nFunction: blt_last(&self) -> Option<BltIt>  \nPreconditions:\n- self is a valid Blt  \nPostconditions:\n- if tree is empty returns None  \n- otherwise returns Some(it) where it.key is the lexicographically largest key  \n\nFunction: blt_next(&self, it: &BltIt) -> Option<BltIt>  \nPreconditions:\n- self is a valid Blt  \n- it was obtained from this tree (e.g. via blt_first, blt_get, blt_set, etc.)  \nPostconditions:\n- returns the in-order successor of it if one exists, else None  \n- does not modify the tree  \n\nFunction: blt_prev(&self, it: &BltIt) -> Option<BltIt>  \nPreconditions:\n- same as blt_next  \nPostconditions:\n- returns the in-order predecessor of it if one exists, else None  \n\nFunction: blt_ceil(&self, key: &str) -> Option<BltIt>  \nPreconditions:\n- self is a valid Blt  \n- key is any &str  \nPostconditions:\n- if tree contains key, returns that leaf  \n- else returns the smallest leaf with leaf.key > key, or None if none exists  \n\nFunction: blt_floor(&self, key: &str) -> Option<BltIt>  \nPreconditions:\n- same as blt_ceil  \nPostconditions:\n- if tree contains key, returns that leaf  \n- else returns the largest leaf with leaf.key < key, or None if none exists  \n\nFunction: blt_overhead(&self) -> usize  \nPreconditions:\n- self is a valid Blt  \nPostconditions:\n- returns the number of bytes used by internal nodes (excluding key & data storage)  \n\nFunction: blt_empty(&self) -> bool  \nPreconditions:\n- self is a valid Blt  \nPostconditions:\n- returns true if tree has no keys, false otherwise  \n\nFunction: blt_size(&self) -> i32  \nPreconditions:\n- self is a valid Blt  \nPostconditions:\n- returns the number of keys (leaf nodes) in the tree  \n\n// Preconditions and Postconditions for bm.rs\n\nFunction: bm_init()  \nPreconditions:\n- none  \nPostconditions:\n- records the current time as the start of a timing interval  \n\nFunction: bm_report(msg: &str)  \nPreconditions:\n- must have called bm_init() at least once  \n- msg is any &str label  \nPostconditions:\n- measures elapsed time since last bm_init or bm_report  \n- prints \u201cmsg: seconds.nanoseconds\u201d to stdout  \n- resets the start time to now  \n\nFunction: bm_read_keys<F>(mut cb: F) where F: FnMut(&[&str], i32)  \nPreconditions:\n- cb is a callable that accepts a slice of &str and an i32  \nPostconditions:\n- reads all lines from stdin until EOF  \n- strips trailing newline from each line  \n- collects them in a dynamically grown array  \n- randomly shuffles the array in place  \n- calls cb(&keys, count) exactly once with the slice and number of keys  \n\n// Preconditions and Postconditions for cbt.rs\n\nFunction: cbt_new() -> Cbt  \nPreconditions:\n- none  \nPostconditions:\n- returns an empty crit-bit tree  \n- Cbt.count == 0, root == None, first == None, last == None  \n- Cbt.len == 0  \n- Cbt.cmp/getlen/dup/getcrit set to the ASCIIZ defaults  \n\nFunction: cbt_new_u(len: i32) -> Cbt  \nPreconditions:\n- len > 0 (fixed key length)  \nPostconditions:\n- returns an empty tree in \u201cu\u201d mode  \n- Cbt.count == 0, root == None, first == None, last == None  \n- Cbt.len == len  \n- Cbt.cmp/getlen/dup/getcrit set to the fixed-length variants  \n\nFunction: cbt_new_enc() -> Cbt  \nPreconditions:\n- none  \nPostconditions:\n- returns an empty tree in \u201cenc\u201d mode  \n- Cbt.count == 0, root == None, first == None, last == None  \n- Cbt.len == 0  \n- Cbt.cmp/getlen/dup/getcrit set to the encoded-length variants  \n\nFunction: cbt_delete(self)  \nPreconditions:\n- self is a Cbt previously returned by one of the constructors  \nPostconditions:\n- all nodes and allocated keys freed  \n- self is consumed and must not be used thereafter  \n\nFunction: cbt_get_at(&self, key: &str) -> Option<Box<dyn Any>>  \nPreconditions:\n- self is a valid Cbt  \n- key conforms to the mode of the tree (length, encoding)  \nPostconditions:\n- returns Some(data) if a leaf with exactly that key exists  \n- otherwise returns None  \n- tree unchanged  \n\nFunction: cbt_put_at(&mut self, data: Box<dyn Any>, key: &str) -> CbtLeaf  \nPreconditions:\n- self is a valid Cbt  \n- key conforms to tree mode  \nPostconditions:\n- ensures a leaf for key exists (inserting if necessary)  \n- increments Cbt.count if new leaf  \n- sets leaf.data = data  \n- updates first/last pointers and linked-list of leaves  \n- returns the new or existing leaf  \n\nFunction: cbt_size(&self) -> i32  \nPreconditions:\n- self is a valid Cbt  \nPostconditions:\n- returns Cbt.count (number of keys)  \n\nFunction: cbt_first(&self) -> Option<CbtLeaf>  \nPreconditions:\n- self is a valid Cbt  \nPostconditions:\n- returns Some(first leaf) if count>0, else None  \n\nFunction: cbt_last(&self) -> Option<CbtLeaf>  \nPreconditions:\n- self is a valid Cbt  \nPostconditions:\n- returns Some(last leaf) if count>0, else None  \n\nFunction: cbt_next(_leaf: &CbtLeaf) -> Option<CbtLeaf>  \nPreconditions:\n- leaf belongs to a valid Cbt and is still in its linked list  \nPostconditions:\n- returns the successor in the in-order linked list, or None if at end  \n\nFunction: cbt_put(&mut self, _leaf: &mut CbtLeaf, _data: Box<dyn Any>)  \nPreconditions:\n- _leaf was obtained from this tree and is not removed  \nPostconditions:\n- replaces that leaf\u2019s data with _data  \n\nFunction: cbt_get(&self, _leaf: &CbtLeaf) -> Option<Box<dyn Any>>  \nPreconditions:\n- _leaf was obtained from this tree and is not removed  \nPostconditions:\n- returns Some(data) stored in that leaf  \n\nFunction: cbt_key(&self, _leaf: &CbtLeaf) -> &str  \nPreconditions:\n- _leaf was obtained from this tree and is not removed  \nPostconditions:\n- returns the key string associated with that leaf  \n\nFunction: cbt_at(&self, key: &str) -> Option<CbtLeaf>  \nPreconditions:\n- self is a valid Cbt  \n- key conforms to tree mode  \nPostconditions:\n- returns Some(leaf) if key present, else None  \n\nFunction: cbt_has(&self, key: &str) -> bool  \nPreconditions:\n- same as cbt_at  \nPostconditions:\n- returns true if key present, false otherwise  \n\nFunction: cbt_forall<F>(&self, _f: F) where F: FnMut(&CbtLeaf)  \nPreconditions:\n- self is a valid Cbt  \n- _f is a callback taking &CbtLeaf  \nPostconditions:\n- visits every leaf in ascending key order, calling _f on each  \n\nFunction: cbt_forall_at<F>(&self, _f: F) where F: FnMut(Box<dyn Any>, &str)  \nPreconditions:\n- self is a valid Cbt  \n- _f is a callback taking (data, key)  \nPostconditions:\n- visits every leaf in ascending key order, calling _f(leaf.data, leaf.key)  \n\nFunction: cbt_remove(&mut self, key: &str) -> Option<Box<dyn Any>>  \nPreconditions:\n- self is a valid Cbt  \n- key conforms to tree mode  \nPostconditions:\n- if key present: removes its leaf, decrements count, fixes pointers, returns Some(data)  \n- if key absent or tree empty: returns None, tree unchanged  \n\nFunction: cbt_remove_all(&mut self)  \nPreconditions:\n- self is a valid Cbt  \nPostconditions:\n- removes and frees all leaves (and their keys)  \n- sets count=0, root=None, first=None, last=None  \n\nFunction: cbt_remove_all_with<F>(&mut self, _f: F) where F: FnMut(Box<dyn Any>, &str)  \nPreconditions:\n- self is a valid Cbt  \n- _f is a callback taking (data, key)  \nPostconditions:\n- calls _f(data, key) for each leaf, then frees it  \n- sets count=0, root=None, first=None, last=None  \n\nFunction: cbt_put_with<F>(&mut self, _f: F, key: &str) -> CbtLeaf \n    where F: FnMut(Box<dyn Any>) -> Box<dyn Any>  \nPreconditions:\n- self is a valid Cbt  \n- key conforms to tree mode  \n- _f is a function that accepts an optional old data and returns new data  \nPostconditions:\n- if key absent: inserts a new leaf, data = _f(None), count++  \n- if key present: applies _f(Some(old_data)) and updates leaf.data  \n- returns the leaf  \n\nFunction: cbt_insert(&mut self, key: &str) -> (bool, CbtLeaf)  \nPreconditions:\n- self is a valid Cbt  \n- key conforms to tree mode  \nPostconditions:\n- similar to cbt_put_with but uses default duplication of data  \n- returns (true, leaf) if new leaf inserted, (false, leaf) if key already present  \n\nFunction: cbt_overhead(&self) -> usize  \nPreconditions:\n- self is a valid Cbt  \nPostconditions:\n- returns the total number of bytes used by internal nodes and leaf structures (excluding stored key & data payloads)",
    "rri_prompt": ""
}