{
    "name": "revampswesmith__junit.tnnvtml1",
    "with_rri": "/**\n * Implements the JUnit 4 standard test case class model, as defined by the\n * annotations in the org.junit package. Many users will never notice this\n * class: it is now the default test class runner, but it should have exactly\n * the same behavior as the old test class runner ({@code JUnit4ClassRunner}).\n *\n * BlockJUnit4ClassRunner has advantages for writers of custom JUnit runners\n * that are slight changes to the default behavior, however:\n *\n * <ul>\n * <li>It has a much simpler implementation based on {@link Statement}s,\n * allowing new operations to be inserted into the appropriate point in the\n * execution flow.\n *\n * <li>It is published, and extension and reuse are encouraged, whereas {@code\n * JUnit4ClassRunner} was in an internal package, and is now deprecated.\n * </ul>\n *\n * @since 4.5\n */\npublic class BlockJUnit4ClassRunnerNew  {\n    public Map<FrameworkMethod, Description> fMethodDescriptions;\n    public Set<Description> integrationDescs;\n\n    public BlockJUnit4ClassRunnerNew()  {\n        this.fMethodDescriptions = new Map<>();\n        this.integrationDescs = new Set<>();\n    }\n\n    public void VOLT_BlockJUnit4ClassRunnerNew(Map<FrameworkMethod, Description>  mtdDescs,\n                                               Set<Description> integDescs) {\n        this.fMethodDescriptions = mtdDescs;\n        this.integrationDescs = integDescs;\n    }\n\n    public BlockJUnit4ClassRunnerNew(Map<FrameworkMethod, Description>  v0,\n                                     Set<Description> v1) {\n        this.fMethodDescriptions = v0;\n        this.integrationDescs = v1;\n    }\n\n    public Description describeChild(FrameworkMethod method, boolean isIntegration) {\n        Description description = fMethodDescriptions.get(method);\n\n        if (description == null) {\n            description = Description.createTestDescription(\n                    method.getTestName(), method.getAnnotations(), isIntegration, method);\n            fMethodDescriptions.put(method, description);\n        }\n        if (description.isIntegration) {\n            integrationDescs.add(description);\n        }\n\n        return fMethodDescriptions.get(method);\n    }\n\n    public List<Description> getDescriptions() {\n        List<Description> descriptions = new List<>();\n        for (FrameworkMethod m : fMethodDescriptions) {\n            descriptions.add(fMethodDescriptions.get(m));\n        }\n        return descriptions;\n    }\n\n    public Description getDescription(FrameworkMethod method) {\n        // Match the old implementation: return the Description mapped to this method, or null\n        return fMethodDescriptions.get(method);\n    }\n\n    public Set<Description> getIntegrationDescs() {\n        return integrationDescs;\n    }\n\n    protected String testName(FrameworkMethod method) {\n        return method.getName();\n    }\n}",
    "without_rri": "public class BlockJUnit4ClassRunnerNew {\n    public Map<FrameworkMethod, Description> fMethodDescriptions;\n    public Set<Description> integrationDescs;\n\n    public BlockJUnit4ClassRunnerNew() {\n        this.fMethodDescriptions = new Map<>();\n        this.integrationDescs = new Set<>();\n    }\n\n    public void VOLT_BlockJUnit4ClassRunnerNew(Map<FrameworkMethod, Description> mtdDescs,\n                                              Set<Description> integDescs) {\n        this.fMethodDescriptions = mtdDescs;\n        this.integrationDescs = integDescs;\n    }\n\n    public BlockJUnit4ClassRunnerNew(Map<FrameworkMethod, Description> v0,\n                                     Set<Description> v1) {\n        this.fMethodDescriptions = v0;\n        this.integrationDescs = v1;\n    }\n\n    public Description describeChild(FrameworkMethod method, boolean isIntegration) {\n        Description description = fMethodDescriptions.get(method);\n        if (description == null) {\n            description = Description.createTestDescription(\n                method.getTestName(),\n                method.getAnnotations(),\n                isIntegration,\n                method\n            );\n            fMethodDescriptions.put(method, description);\n        }\n        return fMethodDescriptions.get(method);\n    }\n\n    public List<Description> getDescriptions() {\n        List<Description> descriptions = new List<>();\n        for (FrameworkMethod m : fMethodDescriptions) {\n            descriptions.add(fMethodDescriptions.get(m));\n        }\n        return descriptions;\n    }\n\n    public Description getDescription(FrameworkMethod method) {\n        // Return the Description associated with the given FrameworkMethod,\n        // or null if none exists\u2014mirroring the old implementation.\n        return fMethodDescriptions.get(method);\n    }\n\n    public Set<Description> getIntegrationDescs() {\n        // Recompute the integration set just like the old implementation did.\n        Set<Description> result = new Set<>();\n        for (FrameworkMethod m : fMethodDescriptions) {\n            Description d = fMethodDescriptions.get(m);\n            if (d.isIntegration) {\n                result.add(d);\n            }\n        }\n        return result;\n    }\n\n    protected String testName(FrameworkMethod method) {\n        return method.getName();\n    }\n}",
    "rri": "public static boolean check(BlockJUnit4ClassRunnerOrig o, BlockJUnit4ClassRunnerNew n) {\n        if (o.descriptions == null || n.fMethodDescriptions == null || n.integrationDescs == null)\n            return false;\n        if (o.descriptions.size() != n.fMethodDescriptions.size())\n            return false;\n        for(FrameworkMethod mtd : n.fMethodDescriptions) {\n            Description d = n.fMethodDescriptions.get(mtd);\n            if (!o.descriptions.contains(d) || !Utils.obj_equals(d.mtd, mtd))\n                return false;\n            if (d.isIntegration) {\n                if (!n.integrationDescs.contains(d))\n                    return false;}\n        }\n        for(Description d : n.integrationDescs) {\n            if (!d.isIntegration)\n                return false;\n            if (!Utils.obj_equals(d, n.fMethodDescriptions.get(d.mtd)))\n                return false;\n        }\n        return true;\n    }",
    "comments": "RRI does help. describeChild method is fixed to add integration descriptions to the set. getIntegrationDescs is also fixed to recompute the set like the old implementation did.",
    "reasoning with rri": ""
}