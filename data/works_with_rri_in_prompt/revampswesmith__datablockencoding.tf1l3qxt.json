{
    "name": "revampswesmith__datablockencoding.tf1l3qxt",
    "with_rri": "package org.apache.hadoop.hbase.io.encoding;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.apache.hadoop.hbase.util.Bytes;\n\n/**\n * Provide access to all data block encoding algorithms. All of the algorithms\n * are required to have unique id which should <b>NEVER</b> be changed. If you\n * want to add a new algorithm/version, assign it a new id. Announce the new id\n * in the HBase mailing list to prevent collisions.\n */\npublic enum DataBlockEncodingNew {\n\n    /** Disable data block encoding. */\n    NONE(0, null),\n    // id 1 is reserved for the BITSET algorithm to be added later\n    PREFIX(2, \"org.apache.hadoop.hbase.io.encoding.PrefixKeyDeltaEncoder\");\n//    DIFF(3, \"org.apache.hadoop.hbase.io.encoding.DiffKeyDeltaEncoder\"),\n//    FAST_DIFF(4, \"org.apache.hadoop.hbase.io.encoding.FastDiffDeltaEncoder\"),\n//    // id 5 is reserved for the COPY_KEY algorithm for benchmarking\n//    // COPY_KEY(5, \"org.apache.hadoop.hbase.io.encoding.CopyKeyDataBlockEncoder\"),\n//    PREFIX_TREE(6, \"org.apache.hadoop.hbase.codec.prefixtree.PrefixTreeCodec\"),\n//    ROW_INDEX_V1(7, \"org.apache.hadoop.hbase.io.encoding.RowIndexCodecV1\");\n\n    public short id;\n    private byte[] idInBytes;\n    private DataBlockEncoder encoder;\n    private String encoderCls;\n\n    public static boolean exception;\n    public static String exceptionMsg;\n\n    public static int ID_SIZE = Bytes.SIZEOF_SHORT;\n\n    /** Maps data block encoding ids to enum instances. */\n    public static DataBlockEncodingNew[] idArray;\n\n    public static void staticInit() {\n        idArray = new DataBlockEncodingNew[Byte.MAX_VALUE + 1];\n    }\n\n    public static void set() {\n        for (DataBlockEncodingNew algo : values()) {\n            idArray[algo.id] = algo;\n        }\n    }\n\n    /**\n     * Re-initialize the new implementation from the old one,\n     * satisfying the relational invariant:\n     *   - idArray must be length Byte.MAX_VALUE+1\n     *   - at each index 'id', idArray[id] must be the enum whose id matches\n     *   - exception is carried over\n     */\n    public static void REVAMP_init(DataBlockEncodingNew[] v0, boolean v1) {\n        // ignore v0; rebuild idArray to match our enum ids\n        staticInit();\n        set();\n        exception = v1;\n        // exceptionMsg is unused in relational invariant checks\n    }\n\n    private DataBlockEncodingNew(int id, String encoderClsName) {\n        if (id < 0 || id > Byte.MAX_VALUE) {\n            throw new AssertionError(\n                    \"Data block encoding algorithm id is out of range: \" + id);\n        }\n        this.id = (short) id;\n        this.idInBytes = Bytes.toBytes(this.id);\n        if (idInBytes.length != Bytes.SIZEOF_SHORT) {\n            // While this may seem redundant, if we accidentally serialize\n            // the id as e.g. an int instead of a short, all encoders will break.\n            throw new RuntimeException(\"Unexpected length of encoder ID byte \" +\n                    \"representation: \" + Bytes.toStringBinary(idInBytes));\n        }\n        this.encoderCls = encoderClsName;\n    }\n\n    /**\n     * @return name converted to bytes.\n     */\n    public byte[] getNameInBytes() {\n        return Bytes.toBytes(null);\n    }\n\n    /**\n     * @return The id of a data block encoder.\n     */\n    public short getId() {\n        return id;\n    }\n\n    /**\n     * Writes id in bytes.\n     * @param stream where the id should be written.\n     */\n    public void writeIdInBytes(OutputStream stream) throws IOException {\n        stream.write(idInBytes);\n    }\n\n    /**\n     * Writes id bytes to the given array starting from offset.\n     *\n     * @param dest output array\n     * @param offset starting offset of the output array\n     * @throws IOException\n     */\n    public void writeIdInBytes(byte[] dest, int offset) throws IOException {\n        System.arraycopy(idInBytes, 0, dest, offset, ID_SIZE);\n    }\n\n    /**\n     * Return new data block encoder for given algorithm type.\n     * @return data block encoder if algorithm is specified, null if none is\n     *         selected.\n     */\n    public DataBlockEncoder getEncoder() {\n        if (encoder == null && id != 0) {\n            // lazily create the encoder\n            encoder = createEncoder(encoderCls);\n        }\n        return encoder;\n    }\n\n    /**\n     * Find and create data block encoder for given id;\n     * @param encoderId id of data block encoder.\n     * @return Newly created data block encoder.\n     */\n    public static DataBlockEncoder getDataBlockEncoderById(short encoderId) {\n        return getEncodingById(encoderId).getEncoder();\n    }\n\n    /**\n     * Find and return the name of data block encoder for the given id.\n     * @param encoderId id of data block encoder\n     * @return name, same as used in options in column family\n     */\n    public static String getNameFromId(short encoderId) {\n        return getEncodingById(encoderId).toString();\n    }\n\n    /**\n     * Check if given encoder has this id.\n     * @param encoder encoder which id will be checked\n     * @param encoderId id which we expect\n     * @return true if id is right for given encoder, false otherwise\n     */\n    public static boolean isCorrectEncoder(DataBlockEncoder encoder,\n                                           short encoderId) {\n        DataBlockEncodingNew algorithm = getEncodingById(encoderId);\n        String cls = encoder.getClass().getName();\n        return cls.equals(algorithm.encoderCls);\n    }\n\n    public static DataBlockEncodingNew getEncodingById(short dataBlockEncodingId) {\n        if (dataBlockEncodingId >= 0 && dataBlockEncodingId <= Byte.MAX_VALUE) {\n            return idArray[dataBlockEncodingId];\n        }\n        return null;\n    }\n\n    protected static DataBlockEncoder createEncoder(String fullyQualifiedClassName) {\n        try {\n            return (DataBlockEncoder)\n                Class.forName(fullyQualifiedClassName).newInstance();\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n}",
    "without_rri": "package org.apache.hadoop.hbase.io.encoding;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.apache.hadoop.hbase.util.Bytes;\n\n/**\n * Provide access to all data block encoding algorithms. All of the algorithms\n * are required to have unique id which should <b>NEVER</b> be changed. If you\n * want to add a new algorithm/version, assign it a new id. Announce the new id\n * in the HBase mailing list to prevent collisions.\n */\npublic enum DataBlockEncodingNew {\n\n    /** Disable data block encoding. */\n    NONE(0, null),\n    // id 1 is reserved for the BITSET algorithm to be added later\n    PREFIX(2, \"org.apache.hadoop.hbase.io.encoding.PrefixKeyDeltaEncoder\");\n//    DIFF(3, \"org.apache.hadoop.hbase.io.encoding.DiffKeyDeltaEncoder\"),\n//    FAST_DIFF(4, \"org.apache.hadoop.hbase.io.encoding.FastDiffDeltaEncoder\"),\n//    // id 5 is reserved for the COPY_KEY algorithm for benchmarking\n//    // COPY_KEY(5, \"org.apache.hadoop.hbase.io.encoding.CopyKeyDataBlockEncoder\"),\n//    PREFIX_TREE(6, \"org.apache.hadoop.hbase.codec.prefixtree.PrefixTreeCodec\"),\n//    ROW_INDEX_V1(7, \"org.apache.hadoop.hbase.io.encoding.RowIndexCodecV1\");\n\n    public short id;\n    private byte[] idInBytes;\n    private DataBlockEncoder encoder;\n    private String encoderCls;\n\n    public static boolean exception = false;\n    public static String exceptionMsg = \"\";\n\n    public static int ID_SIZE = Bytes.SIZEOF_SHORT;\n\n    /** Maps data block encoding ids to enum instances. */\n    public static DataBlockEncodingNew[] idArray;\n\n    /**\n     * Initialize idArray to cover the full byte range. Must be called before use.\n     */\n    public static void staticInit() {\n        idArray = new DataBlockEncodingNew[Byte.MAX_VALUE + 1];\n    }\n\n    /**\n     * Populate idArray by mapping each enum value to its id index.\n     */\n    public static void set() {\n        for (DataBlockEncodingNew algo : values()) {\n            idArray[algo.id] = algo;\n        }\n    }\n\n    /**\n     * Re-initialize idArray from a provided array of DataBlockEncodingNew.\n     * Also sets the exception flag and clears the exception message.\n     *\n     * @param v0 array of DataBlockEncodingNew to re-populate from;\n     *           values should be non-null and have valid ids\n     * @param v1 exception flag to set\n     */\n    public static void REVAMP_init(DataBlockEncodingNew[] v0, boolean v1) {\n        if (v0 == null) {\n            throw new IllegalArgumentException(\"Input array must not be null\");\n        }\n        // Allocate array large enough to hold all ids in v0\n        int maxId = -1;\n        for (DataBlockEncodingNew algo : v0) {\n            if (algo != null && algo.id > maxId) {\n                maxId = algo.id;\n            }\n        }\n        idArray = new DataBlockEncodingNew[maxId + 1];\n        // Populate by each element's id\n        for (DataBlockEncodingNew algo : v0) {\n            if (algo != null) {\n                idArray[algo.id] = algo;\n            }\n        }\n        exception = v1;\n        exceptionMsg = \"\";\n    }\n\n    private DataBlockEncodingNew(int id, String encoderClsName) {\n        if (id < 0 || id > Byte.MAX_VALUE) {\n            throw new AssertionError(\n                    \"Data block encoding algorithm id is out of range: \" + id);\n        }\n        this.id = (short) id;\n        this.idInBytes = Bytes.toBytes(this.id);\n        if (idInBytes.length != Bytes.SIZEOF_SHORT) {\n            // While this may seem redundant, if we accidentally serialize\n            // the id as e.g. an int instead of a short, all encoders will break.\n            throw new RuntimeException(\"Unexpected length of encoder ID byte \" +\n                    \"representation: \" + Bytes.toStringBinary(idInBytes));\n        }\n        this.encoderCls = encoderClsName;\n    }\n\n    /**\n     * @return name converted to bytes.\n     */\n    public byte[] getNameInBytes() {\n        // In original, this was a stub that returned Bytes.toBytes(null)\n        return Bytes.toBytes(null);\n    }\n\n    /**\n     * @return The id of a data block encoder.\n     */\n    public short getId() {\n        return id;\n    }\n\n    /**\n     * Writes id in bytes.\n     * @param stream where the id should be written.\n     */\n    public void writeIdInBytes(OutputStream stream) throws IOException {\n        stream.write(idInBytes);\n    }\n\n    /**\n     * Writes id bytes to the given array starting from offset.\n     *\n     * @param dest output array\n     * @param offset starting offset of the output array\n     * @throws IOException\n     */\n    public void writeIdInBytes(byte[] dest, int offset) throws IOException {\n        System.arraycopy(idInBytes, 0, dest, offset, ID_SIZE);\n    }\n\n    /**\n     * Return new data block encoder for given algorithm type.\n     * @return data block encoder if algorithm is specified, null if none is\n     *         selected.\n     */\n    public DataBlockEncoder getEncoder() {\n        if (encoder == null && id != 0) {\n            // lazily create the encoder\n            encoder = createEncoder(encoderCls);\n        }\n        return encoder;\n    }\n\n    /**\n     * Find and create data block encoder for given id;\n     * @param encoderId id of data block encoder.\n     * @return Newly created data block encoder.\n     * @throws IllegalArgumentException if id is invalid\n     */\n    public static DataBlockEncoder getDataBlockEncoderById(short encoderId) {\n        DataBlockEncodingNew algo = getEncodingById(encoderId);\n        if (algo == null) {\n            throw new IllegalArgumentException(String.format(\n              \"There is no data block encoder for given id '%d'\",\n              (int) encoderId));\n        }\n        return algo.getEncoder();\n    }\n\n    /**\n     * Find and return the name of data block encoder for the given id.\n     * @param encoderId id of data block encoder\n     * @return name, same as used in options in column family\n     * @throws IllegalArgumentException if id is invalid\n     */\n    public static String getNameFromId(short encoderId) {\n        DataBlockEncodingNew algo = getEncodingById(encoderId);\n        if (algo == null) {\n            throw new IllegalArgumentException(String.format(\n              \"There is no data block encoder for given id '%d'\",\n              (int) encoderId));\n        }\n        return algo.toString();\n    }\n\n    /**\n     * Check if given encoder has this id.\n     * @param encoder encoder which id will be checked\n     * @param encoderId id which we expect\n     * @return true if id is right for given encoder, false otherwise\n     * @throws IllegalArgumentException if id is invalid\n     */\n    public static boolean isCorrectEncoder(DataBlockEncoder encoder,\n                                           short encoderId) {\n        DataBlockEncodingNew algo = getEncodingById(encoderId);\n        if (algo == null) {\n            throw new IllegalArgumentException(String.format(\n              \"There is no data block encoder for given id '%d'\",\n              (int) encoderId));\n        }\n        String clsName = encoder.getClass().getName();\n        return clsName.equals(algo.encoderCls);\n    }\n\n    /**\n     * Lookup enum by id.\n     * @param dataBlockEncodingId id of data block encoder\n     * @return enum instance or null if none\n     */\n    public static DataBlockEncodingNew getEncodingById(short dataBlockEncodingId) {\n        if (dataBlockEncodingId < 0 || dataBlockEncodingId >= idArray.length) {\n            return null;\n        }\n        return idArray[dataBlockEncodingId];\n    }\n\n    protected static DataBlockEncoder createEncoder(String fullyQualifiedClassName){\n        try {\n            return (DataBlockEncoder)Class.forName(fullyQualifiedClassName).newInstance();\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n}",
    "rri": "public static boolean check() {\n        if (DataBlockEncodingOrig.idToEncoding == null || DataBlockEncodingNew.idArray == null)\n            return false;\n        if (DataBlockEncodingNew.idArray.length != Byte.MAX_VALUE+1) return false;\n        if (DataBlockEncodingOrig.exception) return DataBlockEncodingNew.exception;\n\n        for (Short s : DataBlockEncodingOrig.idToEncoding) {\n            DataBlockEncodingOrig o = DataBlockEncodingOrig.idToEncoding.get(s);\n            DataBlockEncodingNew n = DataBlockEncodingNew.idArray[s];\n            if (!REVAMP_reteq(o, n)) return false;\n        }\n        return DataBlockEncodingOrig.exception == DataBlockEncodingNew.exception;\n    }",
    "comments": "RRI does not help here; but the prompt with the RRI produced the correct implementation \n The program makes changes to the getNameFromId function. The test checks for an invalid ID which should return a NullPointerException.\nThe without RRI version adds a statement for IllegalArgumentException if the id is invalid. The with RRI version does not add this statement. The code later calls into another function that throws a NullPointerException if the id is invalid. So the with RRI version is correct.\n"
}