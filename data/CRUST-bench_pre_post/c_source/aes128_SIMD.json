{
    "name": "aes128_SIMD",
    "aes.c": "#include \"aes.h\"\n\n/*\n * theses functions are used to shift the rows of the state matrix\n * the Shift function shifts the rows to the left\n * the InvShift function shifts the rows to the right\n * the state matrix is a 4x4 matrix\n * the rows are shifted by the row number\n */\n\n\n__attribute__((always_inline))\ninline void Shift(uint8_t state[4][Nb]) {\n    for (int i = 1; i < 4; i++) {\n        uint8_t temp[Nb];\n        for (int j = 0; j < Nb; j++)\n            temp[j] = state[i][(j + i) % Nb];\n\t\tmemcpy(state[i], temp, Nb);    \n\t}\n\t_mm_sfence();\n}\n\n\n__attribute__((always_inline))\ninline void InvShift(uint8_t state[4][Nb]) {\n    for (int i = 1; i < 4; i++) {\n        uint8_t temp[Nb];\n        for (int j = 0; j < Nb; j++) {\n            temp[j] = state[i][(j - i + Nb) % Nb];\n        }\n\t\tmemcpy(state[i], temp, Nb);\t\n    }\n\t_mm_sfence();\n}\n",
    "aes.h": "#ifndef AES_H\n# define AES_H\n\n#include <stdint.h>\n#include <stdio.h>\n#include <immintrin.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define Nb 4\n#define Nk 4\n#define Nr 10\n\n__attribute__((aligned(16)))\nstatic const uint8_t sbox[256] = {\n\t0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,\n\t0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,\n\t0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,\n\t0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,\n\t0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,\n\t0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,\n\t0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,\n\t0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,\n\t0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,\n\t0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,\n\t0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,\n\t0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,\n\t0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,\n\t0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,\n\t0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,\n\t0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16\n};\n\n__attribute__((aligned(16)))\nstatic const uint8_t rsbox[256] = {\n\t0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n\t0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n\t0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n\t0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n\t0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n\t0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n\t0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n\t0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n\t0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n\t0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n\t0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n\t0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n\t0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n\t0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n\t0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n\t0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d\n};\n\n__attribute__((aligned(16)))\nstatic const uint8_t Rcon[11] = {\n\t0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36\n};\n\n/* aes utils */ \n\nuint8_t g_mult(uint8_t a, uint8_t b);\nvoid InvSub(uint8_t state[4][Nb]);\nvoid Sub(uint8_t state[4][Nb]);\n\n/* aes */\n\nvoid Shift(uint8_t state[4][Nb]);\nvoid InvShift(uint8_t state[4][Nb]);\n\n/* matrix */\n\nvoid Columns(uint8_t state[4][Nb]);\nvoid InvColumns(uint8_t state[4][Nb]);\n\n/* keys */\n\nvoid Add(uint8_t state[4][Nb], uint8_t RoundKey[4][Nb]);\nvoid Expansion(uint8_t Key[4 * Nk], uint8_t w[4 * Nb * (Nr + 1)]);\n\n/* padding */\n\nvoid PadBuffer(uint8_t *input, size_t inputLen, uint8_t **output, size_t *outputLen);\nsize_t RemovePadding(uint8_t *input, size_t inputLen); \n\n/* cipher */\n\nvoid Cipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]);\nvoid InvCipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]);\n\n/* base64 */\n\nchar* base64_encode(const unsigned char *input, int len);\n__m128i g_mult_sse(__m128i first, __m128i second);\nvoid Columns_sse(uint8_t state[4][Nb]); \nuint8_t g_mult_sse_byte(uint8_t first, uint8_t second); \n#endif\n",
    "base64.c": "#include \"aes.h\"\n\nconst char base64_table[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nchar* base64_encode(const unsigned char *input, int len) {\n    int output_len = 4 * ((len + 2) / 3);\n    char *output = (char*)malloc(output_len + 1); \n    \n    if (output == NULL) {\n        return NULL;\n    }\n\n    int i, j;\n    for (i = 0, j = 0; i < len; ) {\n        uint32_t octet_a = i < len ? input[i++] : 0;\n        uint32_t octet_b = i < len ? input[i++] : 0;\n        uint32_t octet_c = i < len ? input[i++] : 0;\n\n        uint32_t triple = (octet_a << 16) | (octet_b << 8) | octet_c;\n\n        output[j++] = base64_table[(triple >> 18) & 0x3F];\n        output[j++] = base64_table[(triple >> 12) & 0x3F];\n        output[j++] = base64_table[(triple >> 6) & 0x3F]; \n        output[j++] = base64_table[triple & 0x3F]; \n    }\n\n    for (int k = 0; k < (3 - (len % 3)) % 3; k++) {\n        output[--j] = '=';\n    }\n\n    output[output_len] = '\\0';\n    return output;\n}\n\n",
    "cipher.c": "#include \"aes.h\"\n\n/*\n\t* the Cipher and InvCipher functions are the main functions of the AES algorithm\n\t* they encrypt and decrypt the input respectively\n\t* the input is a 4xNb matrix\n\t* the output is a 4xNb matrix\n\t* the key is a 4xNk matrix\n\t* the w matrix is the expanded key\n\t* the expanded key is a 4xNb*(Nr+1) matrix\n\t* the w matrix is generated using the KeyExpansion function\n*/\n\nvoid Cipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]) {\n\tuint8_t state[4][Nb];\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tstate[i % 4][i / 4] = in[i];\n\tAdd(state, (uint8_t(*)[Nb])&w[0]);\n\tfor (int round = 1; round < Nr; ++round) {\n\t\tSub(state);\n\t\tShift(state);\n\t\tColumns(state);\n\t\tAdd(state, (uint8_t(*)[Nb])&w[round * 4 * Nb]);\n\t}\n\tSub(state);\n\tShift(state);\n\tAdd(state, (uint8_t(*)[Nb])&w[Nr * 4 * Nb]);\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tout[i] = state[i % 4][i / 4];\n}\n\nvoid InvCipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]) {\n\tuint8_t state[4][Nb];\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tstate[i % 4][i / 4] = in[i];\n\tAdd(state, (uint8_t(*)[Nb])&w[Nr * 4 * Nb]);\n\tfor (int round = Nr - 1; round > 0; --round) {\n\t\tInvShift(state);\n\t\tInvSub(state);\n\t\tAdd(state, (uint8_t(*)[Nb])&w[round * 4 * Nb]);\n\t\tInvColumns(state);\n\t}\n\tInvShift(state);\n\tInvSub(state);\n\tAdd(state, (uint8_t(*)[Nb])&w[0]);\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tout[i] = state[i % 4][i / 4];\n}\n",
    "cipher_utils.c": "#include \"aes.h\"\n\n/*\n\t* g_mult is first function that multiplies two polynomials in GF(2^8) \n\t* the polynomials are represented as 8-bit integers\n\t* the result is also an 8-bit integer\n\t* the function is used in the MixColumns and InvMixColumns functions\n*/\n\n__attribute__((always_inline))\ninline uint8_t g_mult(uint8_t first, uint8_t second) {\n    uint8_t p = 0; \n    uint8_t hi_bit_set;\n    __m128i vec_p = _mm_setzero_si128();      \n    __m128i vec_first = _mm_set1_epi8(first);\n\t_mm_prefetch(&vec_first, _MM_HINT_T0);\n    for (int i = 0; i < 8; ++i) {\n        if (second & 1) {\n            __m128i vec_p_part = _mm_set1_epi8(p);\n            vec_p = _mm_xor_si128(vec_p_part, vec_first);\n            p = _mm_extract_epi8(vec_p, 0);\n        }\n\n        hi_bit_set = first & 0x80; \n        first <<= 1; \n        \n        if (hi_bit_set) {\n            first ^= 0x1b; \n        }\n\n        second >>= 1; \n        vec_first = _mm_set1_epi8(first); \n    }\n\n    return p;\n}\n\n/*\n\t* Sub and InvSub are functions that substitute the bytes of the state matrix \n\t* the Sub function uses the sbox table\n\t* the InvSub function uses the rsbox table\n\t* the state matrix is first 4xNb matrix\n\t* the sbox and rsbox tables are 256-byte arrays\n*/\n__attribute__((always_inline))\ninline void Sub(uint8_t state[4][Nb]) {\n    for (int i = 0; i < 4; ++i) {\n        __m128i row = _mm_loadu_si128((__m128i*) &state[i][0]); \n        uint8_t *row_bytes = (uint8_t*)&row;\n        for (int j = 0; j < Nb; ++j) {\n            _mm_prefetch(&sbox[row_bytes[j]], _MM_HINT_T0); \n            row_bytes[j] = sbox[row_bytes[j]]; \n        }\n        _mm_storeu_si128((__m128i*) &state[i][0], row);\n    }\n    _mm_sfence();  \n}\n\n__attribute__((always_inline))\ninline void InvSub(uint8_t state[4][Nb]) {\n    for (int i = 0; i < 4; ++i) {\n        __m128i row = _mm_loadu_si128((__m128i*) &state[i][0]);\n\n        uint8_t *row_bytes = (uint8_t*)&row;\n        for (int j = 0; j < Nb; ++j) {\n            _mm_prefetch(&rsbox[row_bytes[j]], _MM_HINT_T0); \n            row_bytes[j] = rsbox[row_bytes[j]];\n        }\n        _mm_storeu_si128((__m128i*) &state[i][0], row);\n    }\n    _mm_sfence(); \n}\n\n",
    "keys.c": "#include \"aes.h\"\n\nvoid Add(uint8_t state[4][Nb], uint8_t RoundKey[4][Nb]) {\n\tfor (int i = 0; i < 4; ++i)\n\t\tfor (int j = 0; j < Nb; ++j)\n\t\t{\n\t\t\t_mm_prefetch(&RoundKey[i][j], _MM_HINT_T0);\n\t\t\tstate[i][j] ^= RoundKey[i][j];\n\t\t}\n}\n\nvoid Expansion(uint8_t Key[4 * Nk], uint8_t w[4 * Nb * (Nr + 1)]) {\n\tint i;\n\t__m128i temp;\n\tuint8_t temp_bytes[16] = {0};\n\tmemset(w, 0, 4 * Nb * (Nr + 1));\n\tfor (i = 0; i < Nk * 4; i += 16) {\n\t\t_mm_prefetch(&Key[i] + 16, _MM_HINT_T0);\n\t\ttemp = _mm_loadu_si128((__m128i*)&Key[i]);\n\t\t_mm_storeu_si128((__m128i*)&w[i], temp);\n\t\t_mm_storeu_si128((__m128i*)&w[i + 4], temp);\n\t\t_mm_storeu_si128((__m128i*)&w[i + 8], temp);\n\t\t_mm_storeu_si128((__m128i*)&w[i + 12], temp);\n\t}\n\n\ti = Nk;\n\twhile (i < Nb * (Nr + 1)) {\n\t\ttemp = _mm_loadu_si128((__m128i*)&w[4 * (i - 1)]);\n\t\tif (i % Nk == 0) {\n\t\t\ttemp = _mm_shuffle_epi32(temp, _MM_SHUFFLE(3, 0, 1, 2));\n\t\t\t_mm_storeu_si128((__m128i*)temp_bytes, temp);\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t_mm_prefetch(&sbox[temp_bytes[j]], _MM_HINT_T0);\n\t\t\t\ttemp_bytes[j] = sbox[temp_bytes[j]];\n\t\t\t}\n\t\t\ttemp_bytes[0] ^= Rcon[i / Nk];\n\t\t\ttemp = _mm_loadu_si128((__m128i*)temp_bytes);\n\t\t} else if (Nk > 6 && (i % Nk == 4)) {\n\t\t\t_mm_storeu_si128((__m128i*)temp_bytes, temp);\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t_mm_prefetch(&sbox[temp_bytes[j]], _MM_HINT_T0);\n\t\t\t\ttemp_bytes[j] = sbox[temp_bytes[j]];\n\t\t\t\ttemp_bytes[j + 1] = sbox[temp_bytes[j + 1]];\n\t\t\t\ttemp_bytes[j + 2] = sbox[temp_bytes[j + 2]];\n\t\t\t\ttemp_bytes[j + 3] = sbox[temp_bytes[j + 3]];\n\t\t\t}\n\t\t\ttemp = _mm_loadu_si128((__m128i*)temp_bytes);\n\t\t}\n\n\t\t__m128i w_i_Nk = _mm_loadu_si128((__m128i*)&w[4 * (i - Nk)]);\n\t\ttemp = _mm_xor_si128(temp, w_i_Nk);\n\t\t_mm_storeu_si128((__m128i*)&w[4 * i], temp);\n\n\t\ti += 4; \n\t}\n}\n",
    "matrix.c": "#include \"aes.h\"\n\n__attribute__((always_inline))\ninline void Columns(uint8_t state[4][Nb]) {\n\tuint8_t temp_state[4][Nb];\n\tfor (int c = 0; c < Nb; ++c) {\n\t\t_mm_prefetch(&state[0][c] + Nb, _MM_HINT_T0);\n\t\ttemp_state[0][c] = g_mult(0x02, state[0][c]) ^ g_mult(0x03, state[1][c]) ^ state[2][c] ^ state[3][c];\n\t\ttemp_state[1][c] = state[0][c] ^ g_mult(0x02, state[1][c]) ^ g_mult(0x03, state[2][c]) ^ state[3][c];\n\t\ttemp_state[2][c] = state[0][c] ^ state[1][c] ^ g_mult(0x02, state[2][c]) ^ g_mult(0x03, state[3][c]);\n\t\ttemp_state[3][c] = g_mult(0x03, state[0][c]) ^ state[1][c] ^ state[2][c] ^ g_mult(0x02, state[3][c]);\n\t}\n\tfor (int i = 0; i < 4; ++i)\n\t\t_mm_prefetch(&temp_state[i][0], _MM_HINT_T0);\t\n\tmemcpy(state, temp_state, 4 * Nb);\n\t_mm_sfence();\n}\n\n\n__attribute__((always_inline))\ninline void InvColumns(uint8_t state[4][Nb]) {\n\tuint8_t temp_state[4][Nb];\n\tfor (int c = 0; c < Nb; ++c) {\n\t\t_mm_prefetch(&state[0][c] + Nb, _MM_HINT_T0);\n\t\ttemp_state[0][c] = g_mult(0x0e, state[0][c]) ^ g_mult(0x0b, state[1][c]) ^ g_mult(0x0d, state[2][c]) ^ g_mult(0x09, state[3][c]);\n\t\ttemp_state[1][c] = g_mult(0x09, state[0][c]) ^ g_mult(0x0e, state[1][c]) ^ g_mult(0x0b, state[2][c]) ^ g_mult(0x0d, state[3][c]);\n\t\ttemp_state[2][c] = g_mult(0x0d, state[0][c]) ^ g_mult(0x09, state[1][c]) ^ g_mult(0x0e, state[2][c]) ^ g_mult(0x0b, state[3][c]);\n\t\ttemp_state[3][c] = g_mult(0x0b, state[0][c]) ^ g_mult(0x0d, state[1][c]) ^ g_mult(0x09, state[2][c]) ^ g_mult(0x0e, state[3][c]);\n\t}\n\tfor (int i = 0; i < 4; ++i)\n\t\t_mm_prefetch(&temp_state[i][0], _MM_HINT_T0);\n\tmemcpy(state, temp_state, 4 * Nb);\n\t_mm_sfence();\n}\n\n\n\n",
    "padding.c": "#include \"aes.h\"\n\nvoid PadBuffer(uint8_t *input, size_t inputLen, uint8_t **output, size_t *outputLen) {\n    size_t blockSize = 16;\n    size_t paddedLen = ((inputLen / blockSize) + 1) * blockSize;\n    uint8_t *paddedData = _mm_malloc(paddedLen, 16);\n    memcpy(paddedData, input, inputLen);\n    uint8_t padValue = paddedLen - inputLen;\n    memset(paddedData + inputLen, padValue, padValue);\n    *output = paddedData;\n    *outputLen = paddedLen;\n}\n\nsize_t RemovePadding(uint8_t *input, size_t inputLen) {\n    if (inputLen == 0) return 0;\n    uint8_t padValue = input[inputLen - 1];\n    if (padValue < 1 || padValue > 16) {\n        return inputLen;\n    }\n    for (size_t i = inputLen - padValue; i < inputLen; ++i) {\n        if (input[i] != padValue) {\n            return inputLen;\n        }\n    }\n    return inputLen - padValue;\n}\n",
    "c": "",
    "c_pre_post_conditions": "Function: Shift\nPre-condition:\n  \u2022 state points to a fully initialized 4\u00d7Nb array (Nb == 4).  \nPost-condition:\n  \u2022 For each row i = 1..3 and column j = 0..Nb\u20131,\n      state[i][j] == old_state[i][(j + i) % Nb].\n  \u2022 Row 0 is unchanged.\n  \u2022 No other memory is modified.\n\nFunction: InvShift\nPre-condition:\n  \u2022 state points to a fully initialized 4\u00d7Nb array (Nb == 4).  \nPost-condition:\n  \u2022 For each row i = 1..3 and column j = 0..Nb\u20131,\n      state[i][j] == old_state[i][(j \u2013 i + Nb) % Nb].\n  \u2022 Row 0 is unchanged.\n  \u2022 No other memory is modified.\n\nFunction: base64_encode\nPre-condition:\n  \u2022 input points to an array of length len \u2265 0.  \n  \u2022 len is the exact number of bytes to encode.  \nPost-condition:\n  \u2022 Returns either\n      \u2013 NULL if malloc fails, or\n      \u2013 a freshly\u2010malloc\u2019d, null\u2010terminated string of length\n          output_len = 4 * ((len + 2) / 3),\n        containing the standard Base64 encoding of input[0..len\u20131],\n        with \u2018=\u2019 padding as needed.\n  \u2022 *output can be safely freed by the caller.\n\nFunction: g_mult\nPre-condition:\n  \u2022 first, second are arbitrary 8\u2010bit values.  \nPost-condition:\n  \u2022 Returns the product of first and second in GF(2^8)\n    with AES\u2019s irreducible polynomial x^8 + x^4 + x^3 + x + 1.\n  \u2022 The return value is an 8\u2010bit integer p such that\n      p = first \u00b7 second in GF(2^8).\n\nFunction: Sub\nPre-condition:\n  \u2022 state points to a fully initialized 4\u00d7Nb array (Nb == 4).  \nPost-condition:\n  \u2022 For each i in 0..3, j in 0..Nb\u20131,\n      state[i][j] == sbox[ old_state[i][j] ].\n  \u2022 No other memory is modified.\n\nFunction: InvSub\nPre-condition:\n  \u2022 state points to a fully initialized 4\u00d7Nb array (Nb == 4).  \nPost-condition:\n  \u2022 For each i in 0..3, j in 0..Nb\u20131,\n      state[i][j] == rsbox[ old_state[i][j] ].\n  \u2022 No other memory is modified.\n\nFunction: Add\nPre-condition:\n  \u2022 state and RoundKey each point to a 4\u00d7Nb array (Nb == 4),\n    fully initialized.  \nPost-condition:\n  \u2022 For each i in 0..3, j in 0..Nb\u20131,\n      state[i][j] == old_state[i][j] XOR RoundKey[i][j].\n  \u2022 RoundKey is not modified.\n\nFunction: Expansion\nPre-condition:\n  \u2022 Key points to 4*Nk bytes (Nk == 4).\n  \u2022 w points to a buffer of at least 4*Nb*(Nr+1) bytes\n    (Nb == 4, Nr == 10).  \nPost-condition:\n  \u2022 w[0..15] == Key[0..15].\n  \u2022 w contains the AES\u2010128 key schedule: for round r in 1..Nr,\n    the 16\u2010byte round key at w[16*r .. 16*r+15] is correctly\n    derived from w[16*(r\u20131) .. 16*(r\u20131)+15] by RotWord,\n    SubWord, Rcon, etc.\n  \u2022 All bytes of w outside these schedule entries remain zero.\n\nFunction: Columns\nPre-condition:\n  \u2022 state points to a fully initialized 4\u00d7Nb array (Nb == 4).  \nPost-condition:\n  \u2022 After execution, each column c of state is replaced by\n      MixColumns(old_column_c), i.e.:\n        new[0][c] = 2\u00b7old[0][c] \u2295 3\u00b7old[1][c] \u2295 old[2][c] \u2295 old[3][c],\n        new[1][c] = old[0][c] \u2295 2\u00b7old[1][c] \u2295 3\u00b7old[2][c] \u2295 old[3][c],\n        new[2][c] = old[0][c] \u2295 old[1][c] \u2295 2\u00b7old[2][c] \u2295 3\u00b7old[3][c],\n        new[3][c] = 3\u00b7old[0][c] \u2295 old[1][c] \u2295 old[2][c] \u2295 2\u00b7old[3][c].\n  \u2022 No other memory is modified.\n\nFunction: InvColumns\nPre-condition:\n  \u2022 state points to a fully initialized 4\u00d7Nb array (Nb == 4).  \nPost-condition:\n  \u2022 After execution, each column c of state is replaced by\n      InvMixColumns(old_column_c), i.e. multiplication by\n      the inverse polynomial matrix (0x0e,0x0b,0x0d,0x09).\n  \u2022 No other memory is modified.\n\nFunction: Cipher\nPre-condition:\n  \u2022 in, out each point to at least 4*Nb bytes (Nb == 4).\n  \u2022 w points to at least 4*Nb*(Nr+1) bytes (AES key schedule).\n  \u2022 in[0..15] is the plaintext block, w is a valid key schedule.\nPost-condition:\n  \u2022 out[0..15] is the AES\u2010128 encryption of in[0..15] under w:\n      \u2013 one AddRoundKey,\n      \u2013 Nr\u20131 full rounds of Sub, Shift, Columns, AddRoundKey,\n      \u2013 final round of Sub, Shift, AddRoundKey.\n  \u2022 in and w are unchanged.\n\nFunction: InvCipher\nPre-condition:\n  \u2022 in, out each point to at least 4*Nb bytes (Nb == 4).\n  \u2022 w points to at least 4*Nb*(Nr+1) bytes (AES key schedule).\n  \u2022 in[0..15] is the ciphertext block, w is the key schedule used for encryption.\nPost-condition:\n  \u2022 out[0..15] is the AES\u2010128 decryption of in[0..15] under w:\n      \u2013 initial AddRoundKey (round Nr),\n      \u2013 Nr\u20131 full inverse rounds of InvShift, InvSub, AddRoundKey, InvColumns,\n      \u2013 final InvShift, InvSub, AddRoundKey (round 0).\n  \u2022 in and w are unchanged.\n\nFunction: PadBuffer\nPre-condition:\n  \u2022 input points to inputLen bytes.\n  \u2022 output and outputLen are non\u2010NULL pointers.  \nPost-condition:\n  \u2022 *outputLen == ((inputLen/16)+1)*16.\n  \u2022 *output is an _mm_malloc\u2019d buffer, 16\u2010byte aligned, of length *outputLen.\n  \u2022 memcpy(*output, input, inputLen) has copied the data.\n  \u2022 The pad byte value pad = (*outputLen\u2013inputLen) \u2208 [1..16] is written\n    to (*output + inputLen) .. (*output + *outputLen\u20131].\n  \u2022 Caller must free(*output).\n\nFunction: RemovePadding\nPre-condition:\n  \u2022 input points to inputLen bytes (inputLen \u2265 0).  \nPost-condition:\n  \u2022 If inputLen == 0, returns 0.\n  \u2022 Else let pad = input[inputLen\u20131]:\n      \u2013 If pad \u2209 [1..16] or any of the last pad bytes \u2260 pad,\n          returns inputLen (no padding removed).\n      \u2013 Otherwise returns inputLen \u2013 pad (padding stripped).",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\nFunction: function_name\nPre-condition: description of the pre-condition\nPost-condition: description of the post-condition\n```\n\nHere is the code:\n{{aes.c}}\n```c\n// header file\n/*#ifndef AES_H\n# define AES_H\n\n#include <stdint.h>\n#include <stdio.h>\n#include <immintrin.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define Nb 4\n#define Nk 4\n#define Nr 10\n\n__attribute__((aligned(16)))\nstatic const uint8_t sbox[256] = {\n\t0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,\n\t0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,\n\t0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,\n\t0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,\n\t0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,\n\t0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,\n\t0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,\n\t0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,\n\t0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,\n\t0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,\n\t0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,\n\t0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,\n\t0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,\n\t0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,\n\t0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,\n\t0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16\n};\n\n__attribute__((aligned(16)))\nstatic const uint8_t rsbox[256] = {\n\t0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,\n\t0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,\n\t0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,\n\t0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,\n\t0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,\n\t0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,\n\t0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,\n\t0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,\n\t0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,\n\t0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,\n\t0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,\n\t0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,\n\t0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,\n\t0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,\n\t0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,\n\t0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d\n};\n\n__attribute__((aligned(16)))\nstatic const uint8_t Rcon[11] = {\n\t0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36\n};\n\n/* aes utils */ \n\nuint8_t g_mult(uint8_t a, uint8_t b);\nvoid InvSub(uint8_t state[4][Nb]);\nvoid Sub(uint8_t state[4][Nb]);\n\n/* aes */\n\nvoid Shift(uint8_t state[4][Nb]);\nvoid InvShift(uint8_t state[4][Nb]);\n\n/* matrix */\n\nvoid Columns(uint8_t state[4][Nb]);\nvoid InvColumns(uint8_t state[4][Nb]);\n\n/* keys */\n\nvoid Add(uint8_t state[4][Nb], uint8_t RoundKey[4][Nb]);\nvoid Expansion(uint8_t Key[4 * Nk], uint8_t w[4 * Nb * (Nr + 1)]);\n\n/* padding */\n\nvoid PadBuffer(uint8_t *input, size_t inputLen, uint8_t **output, size_t *outputLen);\nsize_t RemovePadding(uint8_t *input, size_t inputLen); \n\n/* cipher */\n\nvoid Cipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]);\nvoid InvCipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]);\n\n/* base64 */\n\nchar* base64_encode(const unsigned char *input, int len);\n__m128i g_mult_sse(__m128i first, __m128i second);\nvoid Columns_sse(uint8_t state[4][Nb]); \nuint8_t g_mult_sse_byte(uint8_t first, uint8_t second); \n#endif\n*/\n#include \"aes.h\"\n\n/*\n * theses functions are used to shift the rows of the state matrix\n * the Shift function shifts the rows to the left\n * the InvShift function shifts the rows to the right\n * the state matrix is a 4x4 matrix\n * the rows are shifted by the row number\n */\n\n\n__attribute__((always_inline))\ninline void Shift(uint8_t state[4][Nb]) {\n    for (int i = 1; i < 4; i++) {\n        uint8_t temp[Nb];\n        for (int j = 0; j < Nb; j++)\n            temp[j] = state[i][(j + i) % Nb];\n\t\tmemcpy(state[i], temp, Nb);    \n\t}\n\t_mm_sfence();\n}\n\n\n__attribute__((always_inline))\ninline void InvShift(uint8_t state[4][Nb]) {\n    for (int i = 1; i < 4; i++) {\n        uint8_t temp[Nb];\n        for (int j = 0; j < Nb; j++) {\n            temp[j] = state[i][(j - i + Nb) % Nb];\n        }\n\t\tmemcpy(state[i], temp, Nb);\t\n    }\n\t_mm_sfence();\n}\n```\n\n{{base64.c}}\n```c\n#include \"aes.c\"\n\nconst char base64_table[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nchar* base64_encode(const unsigned char *input, int len) {\n    int output_len = 4 * ((len + 2) / 3);\n    char *output = (char*)malloc(output_len + 1); \n    \n    if (output == NULL) {\n        return NULL;\n    }\n\n    int i, j;\n    for (i = 0, j = 0; i < len; ) {\n        uint32_t octet_a = i < len ? input[i++] : 0;\n        uint32_t octet_b = i < len ? input[i++] : 0;\n        uint32_t octet_c = i < len ? input[i++] : 0;\n\n        uint32_t triple = (octet_a << 16) | (octet_b << 8) | octet_c;\n\n        output[j++] = base64_table[(triple >> 18) & 0x3F];\n        output[j++] = base64_table[(triple >> 12) & 0x3F];\n        output[j++] = base64_table[(triple >> 6) & 0x3F]; \n        output[j++] = base64_table[triple & 0x3F]; \n    }\n\n    for (int k = 0; k < (3 - (len % 3)) % 3; k++) {\n        output[--j] = '=';\n    }\n\n    output[output_len] = '\\0';\n    return output;\n}\n\n```\n\n{{cipher.c}}\n```c\n#include \"aes.c\"\n\n/*\n\t* the Cipher and InvCipher functions are the main functions of the AES algorithm\n\t* they encrypt and decrypt the input respectively\n\t* the input is a 4xNb matrix\n\t* the output is a 4xNb matrix\n\t* the key is a 4xNk matrix\n\t* the w matrix is the expanded key\n\t* the expanded key is a 4xNb*(Nr+1) matrix\n\t* the w matrix is generated using the KeyExpansion function\n*/\n\nvoid Cipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]) {\n\tuint8_t state[4][Nb];\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tstate[i % 4][i / 4] = in[i];\n\tAdd(state, (uint8_t(*)[Nb])&w[0]);\n\tfor (int round = 1; round < Nr; ++round) {\n\t\tSub(state);\n\t\tShift(state);\n\t\tColumns(state);\n\t\tAdd(state, (uint8_t(*)[Nb])&w[round * 4 * Nb]);\n\t}\n\tSub(state);\n\tShift(state);\n\tAdd(state, (uint8_t(*)[Nb])&w[Nr * 4 * Nb]);\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tout[i] = state[i % 4][i / 4];\n}\n\nvoid InvCipher(uint8_t in[4 * Nb], uint8_t out[4 * Nb], uint8_t w[4 * Nb * (Nr + 1)]) {\n\tuint8_t state[4][Nb];\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tstate[i % 4][i / 4] = in[i];\n\tAdd(state, (uint8_t(*)[Nb])&w[Nr * 4 * Nb]);\n\tfor (int round = Nr - 1; round > 0; --round) {\n\t\tInvShift(state);\n\t\tInvSub(state);\n\t\tAdd(state, (uint8_t(*)[Nb])&w[round * 4 * Nb]);\n\t\tInvColumns(state);\n\t}\n\tInvShift(state);\n\tInvSub(state);\n\tAdd(state, (uint8_t(*)[Nb])&w[0]);\n\tfor (int i = 0; i < 4 * Nb; ++i)\n\t\tout[i] = state[i % 4][i / 4];\n}\n```\n\n{{cipher_utils.c}}\n```c\n#include \"aes.c\"\n\n/*\n\t* g_mult is first function that multiplies two polynomials in GF(2^8) \n\t* the polynomials are represented as 8-bit integers\n\t* the result is also an 8-bit integer\n\t* the function is used in the MixColumns and InvMixColumns functions\n*/\n\n__attribute__((always_inline))\ninline uint8_t g_mult(uint8_t first, uint8_t second) {\n    uint8_t p = 0; \n    uint8_t hi_bit_set;\n    __m128i vec_p = _mm_setzero_si128();      \n    __m128i vec_first = _mm_set1_epi8(first);\n\t_mm_prefetch(&vec_first, _MM_HINT_T0);\n    for (int i = 0; i < 8; ++i) {\n        if (second & 1) {\n            __m128i vec_p_part = _mm_set1_epi8(p);\n            vec_p = _mm_xor_si128(vec_p_part, vec_first);\n            p = _mm_extract_epi8(vec_p, 0);\n        }\n\n        hi_bit_set = first & 0x80; \n        first <<= 1; \n        \n        if (hi_bit_set) {\n            first ^= 0x1b; \n        }\n\n        second >>= 1; \n        vec_first = _mm_set1_epi8(first); \n    }\n\n    return p;\n}\n\n/*\n\t* Sub and InvSub are functions that substitute the bytes of the state matrix \n\t* the Sub function uses the sbox table\n\t* the InvSub function uses the rsbox table\n\t* the state matrix is first 4xNb matrix\n\t* the sbox and rsbox tables are 256-byte arrays\n*/\n__attribute__((always_inline))\ninline void Sub(uint8_t state[4][Nb]) {\n    for (int i = 0; i < 4; ++i) {\n        __m128i row = _mm_loadu_si128((__m128i*) &state[i][0]); \n        uint8_t *row_bytes = (uint8_t*)&row;\n        for (int j = 0; j < Nb; ++j) {\n            _mm_prefetch(&sbox[row_bytes[j]], _MM_HINT_T0); \n            row_bytes[j] = sbox[row_bytes[j]]; \n        }\n        _mm_storeu_si128((__m128i*) &state[i][0], row);\n    }\n    _mm_sfence();  \n}\n\n__attribute__((always_inline))\ninline void InvSub(uint8_t state[4][Nb]) {\n    for (int i = 0; i < 4; ++i) {\n        __m128i row = _mm_loadu_si128((__m128i*) &state[i][0]);\n\n        uint8_t *row_bytes = (uint8_t*)&row;\n        for (int j = 0; j < Nb; ++j) {\n            _mm_prefetch(&rsbox[row_bytes[j]], _MM_HINT_T0); \n            row_bytes[j] = rsbox[row_bytes[j]];\n        }\n        _mm_storeu_si128((__m128i*) &state[i][0], row);\n    }\n    _mm_sfence(); \n}\n\n```\n\n{{keys.c}}\n```c\n#include \"aes.c\"\n\nvoid Add(uint8_t state[4][Nb], uint8_t RoundKey[4][Nb]) {\n\tfor (int i = 0; i < 4; ++i)\n\t\tfor (int j = 0; j < Nb; ++j)\n\t\t{\n\t\t\t_mm_prefetch(&RoundKey[i][j], _MM_HINT_T0);\n\t\t\tstate[i][j] ^= RoundKey[i][j];\n\t\t}\n}\n\nvoid Expansion(uint8_t Key[4 * Nk], uint8_t w[4 * Nb * (Nr + 1)]) {\n\tint i;\n\t__m128i temp;\n\tuint8_t temp_bytes[16] = {0};\n\tmemset(w, 0, 4 * Nb * (Nr + 1));\n\tfor (i = 0; i < Nk * 4; i += 16) {\n\t\t_mm_prefetch(&Key[i] + 16, _MM_HINT_T0);\n\t\ttemp = _mm_loadu_si128((__m128i*)&Key[i]);\n\t\t_mm_storeu_si128((__m128i*)&w[i], temp);\n\t\t_mm_storeu_si128((__m128i*)&w[i + 4], temp);\n\t\t_mm_storeu_si128((__m128i*)&w[i + 8], temp);\n\t\t_mm_storeu_si128((__m128i*)&w[i + 12], temp);\n\t}\n\n\ti = Nk;\n\twhile (i < Nb * (Nr + 1)) {\n\t\ttemp = _mm_loadu_si128((__m128i*)&w[4 * (i - 1)]);\n\t\tif (i % Nk == 0) {\n\t\t\ttemp = _mm_shuffle_epi32(temp, _MM_SHUFFLE(3, 0, 1, 2));\n\t\t\t_mm_storeu_si128((__m128i*)temp_bytes, temp);\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t_mm_prefetch(&sbox[temp_bytes[j]], _MM_HINT_T0);\n\t\t\t\ttemp_bytes[j] = sbox[temp_bytes[j]];\n\t\t\t}\n\t\t\ttemp_bytes[0] ^= Rcon[i / Nk];\n\t\t\ttemp = _mm_loadu_si128((__m128i*)temp_bytes);\n\t\t} else if (Nk > 6 && (i % Nk == 4)) {\n\t\t\t_mm_storeu_si128((__m128i*)temp_bytes, temp);\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t_mm_prefetch(&sbox[temp_bytes[j]], _MM_HINT_T0);\n\t\t\t\ttemp_bytes[j] = sbox[temp_bytes[j]];\n\t\t\t\ttemp_bytes[j + 1] = sbox[temp_bytes[j + 1]];\n\t\t\t\ttemp_bytes[j + 2] = sbox[temp_bytes[j + 2]];\n\t\t\t\ttemp_bytes[j + 3] = sbox[temp_bytes[j + 3]];\n\t\t\t}\n\t\t\ttemp = _mm_loadu_si128((__m128i*)temp_bytes);\n\t\t}\n\n\t\t__m128i w_i_Nk = _mm_loadu_si128((__m128i*)&w[4 * (i - Nk)]);\n\t\ttemp = _mm_xor_si128(temp, w_i_Nk);\n\t\t_mm_storeu_si128((__m128i*)&w[4 * i], temp);\n\n\t\ti += 4; \n\t}\n}\n```\n\n{{matrix.c}}\n```c\n#include \"aes.c\"\n\n__attribute__((always_inline))\ninline void Columns(uint8_t state[4][Nb]) {\n\tuint8_t temp_state[4][Nb];\n\tfor (int c = 0; c < Nb; ++c) {\n\t\t_mm_prefetch(&state[0][c] + Nb, _MM_HINT_T0);\n\t\ttemp_state[0][c] = g_mult(0x02, state[0][c]) ^ g_mult(0x03, state[1][c]) ^ state[2][c] ^ state[3][c];\n\t\ttemp_state[1][c] = state[0][c] ^ g_mult(0x02, state[1][c]) ^ g_mult(0x03, state[2][c]) ^ state[3][c];\n\t\ttemp_state[2][c] = state[0][c] ^ state[1][c] ^ g_mult(0x02, state[2][c]) ^ g_mult(0x03, state[3][c]);\n\t\ttemp_state[3][c] = g_mult(0x03, state[0][c]) ^ state[1][c] ^ state[2][c] ^ g_mult(0x02, state[3][c]);\n\t}\n\tfor (int i = 0; i < 4; ++i)\n\t\t_mm_prefetch(&temp_state[i][0], _MM_HINT_T0);\t\n\tmemcpy(state, temp_state, 4 * Nb);\n\t_mm_sfence();\n}\n\n\n__attribute__((always_inline))\ninline void InvColumns(uint8_t state[4][Nb]) {\n\tuint8_t temp_state[4][Nb];\n\tfor (int c = 0; c < Nb; ++c) {\n\t\t_mm_prefetch(&state[0][c] + Nb, _MM_HINT_T0);\n\t\ttemp_state[0][c] = g_mult(0x0e, state[0][c]) ^ g_mult(0x0b, state[1][c]) ^ g_mult(0x0d, state[2][c]) ^ g_mult(0x09, state[3][c]);\n\t\ttemp_state[1][c] = g_mult(0x09, state[0][c]) ^ g_mult(0x0e, state[1][c]) ^ g_mult(0x0b, state[2][c]) ^ g_mult(0x0d, state[3][c]);\n\t\ttemp_state[2][c] = g_mult(0x0d, state[0][c]) ^ g_mult(0x09, state[1][c]) ^ g_mult(0x0e, state[2][c]) ^ g_mult(0x0b, state[3][c]);\n\t\ttemp_state[3][c] = g_mult(0x0b, state[0][c]) ^ g_mult(0x0d, state[1][c]) ^ g_mult(0x09, state[2][c]) ^ g_mult(0x0e, state[3][c]);\n\t}\n\tfor (int i = 0; i < 4; ++i)\n\t\t_mm_prefetch(&temp_state[i][0], _MM_HINT_T0);\n\tmemcpy(state, temp_state, 4 * Nb);\n\t_mm_sfence();\n}\n\n\n\n```\n\n{{padding.c}}\n```c\n#include \"aes.c\"\n\nvoid PadBuffer(uint8_t *input, size_t inputLen, uint8_t **output, size_t *outputLen) {\n    size_t blockSize = 16;\n    size_t paddedLen = ((inputLen / blockSize) + 1) * blockSize;\n    uint8_t *paddedData = _mm_malloc(paddedLen, 16);\n    memcpy(paddedData, input, inputLen);\n    uint8_t padValue = paddedLen - inputLen;\n    memset(paddedData + inputLen, padValue, padValue);\n    *output = paddedData;\n    *outputLen = paddedLen;\n}\n\nsize_t RemovePadding(uint8_t *input, size_t inputLen) {\n    if (inputLen == 0) return 0;\n    uint8_t padValue = input[inputLen - 1];\n    if (padValue < 1 || padValue > 16) {\n        return inputLen;\n    }\n    for (size_t i = inputLen - padValue; i < inputLen; ++i) {\n        if (input[i] != padValue) {\n            return inputLen;\n        }\n    }\n    return inputLen - padValue;\n}\n```\n\n\nPlease extract the invariants from the code.\n"
}