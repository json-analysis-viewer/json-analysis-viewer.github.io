{
    "name": "amp",
    "amp.c": "\n//\n// amp.c\n//\n// Copyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"amp.h\"\n\n/*\n * Read u32be.\n */\n\nstatic uint32_t\nread_u32_be(char *buf) {\n  uint32_t n = 0;\n  n |= buf[0] << 24;\n  n |= buf[1] << 16;\n  n |= buf[2] << 8;\n  n |= buf[3];\n  return n;\n}\n\n/*\n * Write u32be.\n */\n\nstatic void\nwrite_u32_be(char *buf, uint32_t n) {\n  buf[0] = n >> 24 & 0xff;\n  buf[1] = n >> 16 & 0xff;\n  buf[2] = n >> 8 & 0xff;\n  buf[3] = n & 0xff;\n}\n\n/*\n * Decode the `msg` header in `buf`.\n */\n\nvoid\namp_decode(amp_t *msg, char *buf) {\n  msg->version = buf[0] >> 4;\n  msg->argc = buf[0] & 0xf;\n  msg->buf = buf + 1;\n}\n\n/*\n * Decode `msg` argument, returning a buffer\n * that must be freed by the user and progressing\n * the msg->buf cursor.\n */\n\nchar *\namp_decode_arg(amp_t *msg) {\n  uint32_t len = read_u32_be(msg->buf);\n  msg->buf += 4;\n\n  char *buf = malloc(len);\n  if (!buf) return NULL;\n\n  memcpy(buf, msg->buf, len);\n  msg->buf += len;\n  return buf;\n}\n\n/*\n * Encode the AMP message argv.\n *\n *         0        1 2 3 4     <length>    ...\n *   +------------+----------+------------+\n *   | <ver/argc> | <length> | <data>     | additional arguments\n *   +------------+----------+------------+\n *\n */\n\nchar *\namp_encode(char **argv, int argc) {\n  size_t len = 1;\n  size_t lens[argc];\n\n  // length\n  for (int i = 0; i < argc; ++i) {\n    len += 4;\n    lens[i] = strlen(argv[i]);\n    len += lens[i];\n  }\n\n  // alloc\n  char *buf = malloc(len);\n  char *ret = buf;\n  if (!buf) return NULL;\n\n  // ver/argc\n  *buf++ = AMP_VERSION << 4 | argc;\n\n  // encode\n  for (int i = 0; i < argc; ++i) {\n    size_t len = lens[i];\n\n    write_u32_be(buf, len);\n    buf += 4;\n\n    memcpy(buf, argv[i], len);\n    buf += len;\n  }\n\n  return ret;\n}",
    "amp.h": "\n//\n// amp.h\n//\n// Copyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#ifndef AMP_H\n#define AMP_H\n\n/*\n * Protocol version.\n */\n\n#define AMP_VERSION 1\n\n/*\n * Message struct.\n */\n\ntypedef struct {\n  short version;\n  short argc;\n  char *buf;\n} amp_t;\n\n// prototypes\n\nchar *\namp_encode(char **argv, int argc);\n\nvoid\namp_decode(amp_t *msg, char *buf);\n\nchar *\namp_decode_arg(amp_t *msg);\n\n#endif",
    "c": "",
    "c_pre_post_conditions": "// Function: read_u32_be\n// Pre-condition: \n//   - buf != NULL\n//   - The caller-supplied buffer buf points to at least 4 bytes of readable memory.\n// Post-condition: \n//   - Returns the 32-bit unsigned integer obtained by treating buf[0..3] as a big-endian u32.\n//   - Does not modify the contents of buf.\n\n// Function: write_u32_be\n// Pre-condition: \n//   - buf != NULL\n//   - The caller-supplied buffer buf points to at least 4 bytes of writable memory.\n//   - n is any uint32_t value.\n// Post-condition: \n//   - Writes n into buf[0..3] in big-endian order:\n//       buf[0] == (n >> 24) & 0xFF\n//       buf[1] == (n >> 16) & 0xFF\n//       buf[2] == (n >>  8) & 0xFF\n//       buf[3] == (n      ) & 0xFF\n//   - Does not modify any memory outside buf[0..3].\n\n// Function: amp_decode\n// Pre-condition:\n//   - msg   != NULL\n//   - buf   != NULL\n//   - buf points to at least 1 byte of valid data.\n//   - The first byte of buf encodes <version> in its high 4 bits and <argc> in its low 4 bits.\n//     (Typically, <version> == AMP_VERSION and 0 <= <argc> <= 15.)\n// Post-condition:\n//   - msg->version == (buf[0] >> 4)\n//   - msg->argc    == (buf[0] & 0x0F)\n//   - msg->buf     == buf + 1\n//   - No other fields of *msg or memory at buf are modified.\n\n// Function: amp_decode_arg\n// Pre-condition:\n//   - msg != NULL\n//   - msg->buf points to a region containing at least:\n//       (a) 4 bytes of big-endian length L,\n//       (b) followed immediately by L bytes of argument data.\n//   - There is sufficient heap memory to allocate L bytes.\n// Post-condition (on success):\n//   - Reads uint32_t L = read_u32_be(old msg->buf).\n//   - Advances msg->buf by 4 + L bytes.\n//   - Returns a pointer p to a newly malloc()\u2019d buffer of size L.\n//   - p[0..L-1] is a memcpy copy of the L data bytes from the old msg->buf.\n//   - Caller is responsible for freeing the returned buffer.\n// Post-condition (on malloc failure):\n//   - Returns NULL.\n//   - msg->buf has already been advanced by 4 (length field) but not past the data.\n\n// Function: amp_encode\n// Pre-condition:\n//   - argv != NULL if argc > 0.\n//   - For each i in [0..argc):\n//       argv[i] != NULL and is a valid NUL-terminated string.\n//   - 0 <= argc <= 15  (fits in 4 bits of the header byte).\n//   - The total size computed as 1 + \u03a3_{i=0..argc-1}(4 + strlen(argv[i])) does not overflow size_t.\n//   - Heap has enough space for that total size.\n// Post-condition (on success):\n//   - Allocates a buffer of exactly total_len = 1 + \u03a3(4 + strlen(argv[i])) bytes.\n//   - Writes the header byte:\n//       buf[0] = (AMP_VERSION << 4) | (argc & 0x0F).\n//   - For each argument i, in order:\n//       \u2022 writes its length len_i = strlen(argv[i]) in big-endian form to the next 4 bytes,\n//       \u2022 then copies the len_i data bytes (excluding the NUL terminator).\n//   - Returns a pointer ret to the start of this buffer.\n//   - Caller is responsible for free(ret).\n// Post-condition (on malloc failure):\n//   - Returns NULL.\n//   - No side-effects (buf not modified because buf==NULL).",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\n// Function: function_name\n// Pre-condition: description of the pre-condition\n// Post-condition: description of the post-condition\n```\n\nHere is the code:\n{{amp.c}}\n```c\n// header file\n/*\n//\n// amp.h\n//\n// Copyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#ifndef AMP_H\n#define AMP_H\n\n/*\n * Protocol version.\n */\n\n#define AMP_VERSION 1\n\n/*\n * Message struct.\n */\n\ntypedef struct {\n  short version;\n  short argc;\n  char *buf;\n} amp_t;\n\n// prototypes\n\nchar *\namp_encode(char **argv, int argc);\n\nvoid\namp_decode(amp_t *msg, char *buf);\n\nchar *\namp_decode_arg(amp_t *msg);\n\n#endif*/\n\n//\n// amp.c\n//\n// Copyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"amp.h\"\n\n/*\n * Read u32be.\n */\n\nstatic uint32_t\nread_u32_be(char *buf) {\n  uint32_t n = 0;\n  n |= buf[0] << 24;\n  n |= buf[1] << 16;\n  n |= buf[2] << 8;\n  n |= buf[3];\n  return n;\n}\n\n/*\n * Write u32be.\n */\n\nstatic void\nwrite_u32_be(char *buf, uint32_t n) {\n  buf[0] = n >> 24 & 0xff;\n  buf[1] = n >> 16 & 0xff;\n  buf[2] = n >> 8 & 0xff;\n  buf[3] = n & 0xff;\n}\n\n/*\n * Decode the `msg` header in `buf`.\n */\n\nvoid\namp_decode(amp_t *msg, char *buf) {\n  msg->version = buf[0] >> 4;\n  msg->argc = buf[0] & 0xf;\n  msg->buf = buf + 1;\n}\n\n/*\n * Decode `msg` argument, returning a buffer\n * that must be freed by the user and progressing\n * the msg->buf cursor.\n */\n\nchar *\namp_decode_arg(amp_t *msg) {\n  uint32_t len = read_u32_be(msg->buf);\n  msg->buf += 4;\n\n  char *buf = malloc(len);\n  if (!buf) return NULL;\n\n  memcpy(buf, msg->buf, len);\n  msg->buf += len;\n  return buf;\n}\n\n/*\n * Encode the AMP message argv.\n *\n *         0        1 2 3 4     <length>    ...\n *   +------------+----------+------------+\n *   | <ver/argc> | <length> | <data>     | additional arguments\n *   +------------+----------+------------+\n *\n */\n\nchar *\namp_encode(char **argv, int argc) {\n  size_t len = 1;\n  size_t lens[argc];\n\n  // length\n  for (int i = 0; i < argc; ++i) {\n    len += 4;\n    lens[i] = strlen(argv[i]);\n    len += lens[i];\n  }\n\n  // alloc\n  char *buf = malloc(len);\n  char *ret = buf;\n  if (!buf) return NULL;\n\n  // ver/argc\n  *buf++ = AMP_VERSION << 4 | argc;\n\n  // encode\n  for (int i = 0; i < argc; ++i) {\n    size_t len = lens[i];\n\n    write_u32_be(buf, len);\n    buf += 4;\n\n    memcpy(buf, argv[i], len);\n    buf += len;\n  }\n\n  return ret;\n}```\n\n\nPlease extract the invariants from the code.\n"
}