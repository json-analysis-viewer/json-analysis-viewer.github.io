{
    "name": "bitset",
    "bitset.c": "/*\n * Copyright (c) 2020 Adil Benhlal <adil.benhlal@outlook.fr>\n *\n * bitset is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n */\n#include <errno.h>\n#include \"./include/cborg/bitset.h\"\n\nbitset_t *cb_bitset_new(size_t nb_bits) {\n  bitset_t *bs = (bitset_t *)calloc(1, sizeof(bitset_t));\n  bs->array = (uint8_t *)calloc(__bitset_size(nb_bits), sizeof(uint8_t));\n  bs->size = nb_bits;\n  return bs;\n}\n\nvoid cb_bitset_delete(bitset_t *bs) {\n  free(bs->array);\n  free(bs);\n}\n\nsize_t cb_bitset_count(bitset_t *bs) {\n  return (bs->flip ? (bs->size - bs->count) : bs->count);\n}\n\nsize_t cb_bitset_size(bitset_t *bs) { return bs->size; }\n\nbool cb_bitset_test(bitset_t *bs, size_t idx) {\n  return bs->flip ^\n         ((bs->array[__bitset_byte(idx)] & __bitset_bit_mask(idx)) != 0);\n}\n\nbool cb_bitset_any(bitset_t *bs) {\n  return (bs->flip ? (bs->count != bs->size) : (bs->count != 0));\n}\n\nbool cb_bitset_none(bitset_t *bs) { return !(cb_bitset_any(bs)); }\n\nbool cb_bitset_all(bitset_t *bs) {\n  return (bs->flip ? (bs->count == 0) : (bs->count == bs->size));\n}\n\nvoid cb_bitset_set(bitset_t *bs, size_t idx, bool value) {\n  bool flip_value = bs->flip ? !value : value;\n  size_t previous_count = __builtin_popcount(bs->array[__bitset_byte(idx)]);\n  if (flip_value) {\n    bs->array[__bitset_byte(idx)] |= __bitset_bit_mask(idx);\n  } else {\n    bs->array[__bitset_byte(idx)] &= ~__bitset_bit_mask(idx);\n  }\n  bs->count +=\n      (__builtin_popcount(bs->array[__bitset_byte(idx)]) - previous_count);\n}\n\nvoid cb_bitset_reset(bitset_t *bs) {\n  memset(bs->array, 0, __bitset_size(bs->size));\n  bs->flip = false;\n  bs->count = 0;\n}\n\nvoid cb_bitset_flip(bitset_t *bs) { bs->flip = !(bs->flip); }\n\nchar *cb_bitset_to_string(bitset_t *bs) {\n  char *res = (char *)malloc(sizeof(char) * (bs->size + 1));\n  for (size_t i = 0; i < bs->size; i++) {\n    res[i] = cb_bitset_test(bs, i) ? '1' : '0';\n  }\n  res[bs->size] = '\\0';\n  return res;\n}\n\nvoid cb_bitset_write(bitset_t *bs, const char *path) {\n  FILE *file = fopen(path, \"wb\");\n  size_t bytes_to_write = __bitset_size(bs->size);\n  size_t bytes_writen = 0;\n  size_t total_writen = 0;\n\n  if (file == NULL) {\n    fprintf(stdout, \"%s\\n\", strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n\n  fwrite(&(bs->size), sizeof(size_t), 1, file);\n  fwrite(&(bs->count), sizeof(size_t), 1, file);\n  fwrite(&(bs->flip), sizeof(bool), 1, file);\n  while ((bytes_writen = fwrite(bs->array + total_writen, sizeof(uint8_t),\n                                bytes_to_write - total_writen, file)) > 0) {\n    total_writen += bytes_writen;\n  }\n\n  fclose(file);\n}\n\nbitset_t *cb_bitset_read(const char *path) {\n  FILE *file = fopen(path, \"rb\");\n  size_t size = 0;\n\n  if (file == NULL) {\n    fprintf(stdout, \"%s\\n\", strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n\n  fread(&size, sizeof(size_t), 1, file);\n  bitset_t *bs = cb_bitset_new(size);\n  fread(&(bs->count), sizeof(size_t), 1, file);\n  fread(&(bs->flip), sizeof(bool), 1, file);\n  while (fread(bs->array, sizeof(uint8_t), bs->size, file) > 0);\n\n  fclose(file);\n  return bs;\n}\n",
    "bitset.h": "/*\n * Copyright (c) 2020 Adil Benhlal <adil.benhlal@outlook.fr>\n *\n * bitset is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n */\n\n#ifndef _CBORG_BITSET_H\n#define _CBORG_BITSET_H\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n// Returns the number of bytes needed to store a number of bits\n#define __bitset_size(nbits) ((nbits + 7) >> 3)\n\n// Returns the index of the bit in bitset->array (=idx/8)\n#define __bitset_byte(idx) ((idx) >> 3)\n\n// Returns the bit mask\n#define __bitset_bit_mask(idx) (1 << ((idx)&0x7))\n\n// TODO: format bitset using cbor\n// TODO: bitset thread-safe\n\ntypedef struct bitset_t {\n  bool flip;\n  size_t size;\n  size_t count;\n  uint8_t *array;\n} bitset_t;\n\nbitset_t *cb_bitset_new(size_t nb_bits);\n\nvoid cb_bitset_delete(bitset_t *bs);\n\nsize_t cb_bitset_count(bitset_t *bs);\n\nsize_t cb_bitset_size(bitset_t *bs);\n\nbool cb_bitset_test(bitset_t *bs, size_t idx);\n\nbool cb_bitset_any(bitset_t *bs);\n\nbool cb_bitset_none(bitset_t *bs);\n\nbool cb_bitset_all(bitset_t *bs);\n\nvoid cb_bitset_set(bitset_t *bs, size_t idx, bool value);\n\nvoid cb_bitset_reset(bitset_t *bs);\n\nvoid cb_bitset_flip(bitset_t *bs);\n\nchar *cb_bitset_to_string(bitset_t *bs);\n\nvoid cb_bitset_write(bitset_t *bs, const char *path);\n\nbitset_t *cb_bitset_read(const char *path);\n\n#endif\n",
    "c": "",
    "c_pre_post_conditions": "",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\nFunction: function_name\nPre-condition: description of the pre-condition\nPost-condition: description of the post-condition\n```\n\nHere is the code:\n{{bitset.c}}\n```c\n// header file\n/*/*\n * Copyright (c) 2020 Adil Benhlal <adil.benhlal@outlook.fr>\n *\n * bitset is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n */\n\n#ifndef _CBORG_BITSET_H\n#define _CBORG_BITSET_H\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n// Returns the number of bytes needed to store a number of bits\n#define __bitset_size(nbits) ((nbits + 7) >> 3)\n\n// Returns the index of the bit in bitset->array (=idx/8)\n#define __bitset_byte(idx) ((idx) >> 3)\n\n// Returns the bit mask\n#define __bitset_bit_mask(idx) (1 << ((idx)&0x7))\n\n// TODO: format bitset using cbor\n// TODO: bitset thread-safe\n\ntypedef struct bitset_t {\n  bool flip;\n  size_t size;\n  size_t count;\n  uint8_t *array;\n} bitset_t;\n\nbitset_t *cb_bitset_new(size_t nb_bits);\n\nvoid cb_bitset_delete(bitset_t *bs);\n\nsize_t cb_bitset_count(bitset_t *bs);\n\nsize_t cb_bitset_size(bitset_t *bs);\n\nbool cb_bitset_test(bitset_t *bs, size_t idx);\n\nbool cb_bitset_any(bitset_t *bs);\n\nbool cb_bitset_none(bitset_t *bs);\n\nbool cb_bitset_all(bitset_t *bs);\n\nvoid cb_bitset_set(bitset_t *bs, size_t idx, bool value);\n\nvoid cb_bitset_reset(bitset_t *bs);\n\nvoid cb_bitset_flip(bitset_t *bs);\n\nchar *cb_bitset_to_string(bitset_t *bs);\n\nvoid cb_bitset_write(bitset_t *bs, const char *path);\n\nbitset_t *cb_bitset_read(const char *path);\n\n#endif\n*/\n/*\n * Copyright (c) 2020 Adil Benhlal <adil.benhlal@outlook.fr>\n *\n * bitset is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n */\n#include <errno.h>\n#include \"./include/cborg/bitset.h\"\n\nbitset_t *cb_bitset_new(size_t nb_bits) {\n  bitset_t *bs = (bitset_t *)calloc(1, sizeof(bitset_t));\n  bs->array = (uint8_t *)calloc(__bitset_size(nb_bits), sizeof(uint8_t));\n  bs->size = nb_bits;\n  return bs;\n}\n\nvoid cb_bitset_delete(bitset_t *bs) {\n  free(bs->array);\n  free(bs);\n}\n\nsize_t cb_bitset_count(bitset_t *bs) {\n  return (bs->flip ? (bs->size - bs->count) : bs->count);\n}\n\nsize_t cb_bitset_size(bitset_t *bs) { return bs->size; }\n\nbool cb_bitset_test(bitset_t *bs, size_t idx) {\n  return bs->flip ^\n         ((bs->array[__bitset_byte(idx)] & __bitset_bit_mask(idx)) != 0);\n}\n\nbool cb_bitset_any(bitset_t *bs) {\n  return (bs->flip ? (bs->count != bs->size) : (bs->count != 0));\n}\n\nbool cb_bitset_none(bitset_t *bs) { return !(cb_bitset_any(bs)); }\n\nbool cb_bitset_all(bitset_t *bs) {\n  return (bs->flip ? (bs->count == 0) : (bs->count == bs->size));\n}\n\nvoid cb_bitset_set(bitset_t *bs, size_t idx, bool value) {\n  bool flip_value = bs->flip ? !value : value;\n  size_t previous_count = __builtin_popcount(bs->array[__bitset_byte(idx)]);\n  if (flip_value) {\n    bs->array[__bitset_byte(idx)] |= __bitset_bit_mask(idx);\n  } else {\n    bs->array[__bitset_byte(idx)] &= ~__bitset_bit_mask(idx);\n  }\n  bs->count +=\n      (__builtin_popcount(bs->array[__bitset_byte(idx)]) - previous_count);\n}\n\nvoid cb_bitset_reset(bitset_t *bs) {\n  memset(bs->array, 0, __bitset_size(bs->size));\n  bs->flip = false;\n  bs->count = 0;\n}\n\nvoid cb_bitset_flip(bitset_t *bs) { bs->flip = !(bs->flip); }\n\nchar *cb_bitset_to_string(bitset_t *bs) {\n  char *res = (char *)malloc(sizeof(char) * (bs->size + 1));\n  for (size_t i = 0; i < bs->size; i++) {\n    res[i] = cb_bitset_test(bs, i) ? '1' : '0';\n  }\n  res[bs->size] = '\\0';\n  return res;\n}\n\nvoid cb_bitset_write(bitset_t *bs, const char *path) {\n  FILE *file = fopen(path, \"wb\");\n  size_t bytes_to_write = __bitset_size(bs->size);\n  size_t bytes_writen = 0;\n  size_t total_writen = 0;\n\n  if (file == NULL) {\n    fprintf(stdout, \"%s\\n\", strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n\n  fwrite(&(bs->size), sizeof(size_t), 1, file);\n  fwrite(&(bs->count), sizeof(size_t), 1, file);\n  fwrite(&(bs->flip), sizeof(bool), 1, file);\n  while ((bytes_writen = fwrite(bs->array + total_writen, sizeof(uint8_t),\n                                bytes_to_write - total_writen, file)) > 0) {\n    total_writen += bytes_writen;\n  }\n\n  fclose(file);\n}\n\nbitset_t *cb_bitset_read(const char *path) {\n  FILE *file = fopen(path, \"rb\");\n  size_t size = 0;\n\n  if (file == NULL) {\n    fprintf(stdout, \"%s\\n\", strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n\n  fread(&size, sizeof(size_t), 1, file);\n  bitset_t *bs = cb_bitset_new(size);\n  fread(&(bs->count), sizeof(size_t), 1, file);\n  fread(&(bs->flip), sizeof(bool), 1, file);\n  while (fread(bs->array, sizeof(uint8_t), bs->size, file) > 0);\n\n  fclose(file);\n  return bs;\n}\n```\n\n\nPlease extract the invariants from the code.\n"
}