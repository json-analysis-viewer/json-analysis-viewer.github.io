{
    "name": "bhshell",
    "bhshell.c": "#include <linux/limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <strings.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <stdbool.h>\n\n#include \"include/dynamicarr.h\"\n#include \"include/input.h\"\n#include \"include/bhshell.h\"\n#include \"include/xalloc.h\"\n\n#define BUF_SIZE 64\n\nchar* bhshell_builtin_str[] = {\n\t\"cd\",\n\t\"help\",\n\t\"exit\",\n};\n\nint (*bhshell_builtin_func[]) (char**) = {\n\t&bhshell_cd,\n\t&bhshell_help,\n\t&bhshell_exit,\n};\n\nvoid bhshell_loop() {\n\tchar** args; \n\tint status = 1;\n\n\tdo {\n\t\tchar* dir = getcwd(NULL, 0);\n\t\tif (!dir) exit(EXIT_FAILURE);\n\n\t\tprintf(\"[%s] $ \", dir);\n\n\t\tchar* line = bhshell_read_line();\n\t\tcommand* cmd = bhshell_parse(line);\n\t\tif (cmd == NULL) {\n\t\t\tprintf(\"Invalid Command\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = bhshell_execute(cmd); \n\t\t\n\t\tfree(dir);\n\t\tfree(line);\n\t\tdestroy_command(cmd);\n\t} while(status); \n}\n\nint bhshell_execute(command* cmd) {\n\tif (cmd->args[0] == NULL) {\n\t\treturn 1;\n\t}\n\n\tfor (int i = 0; i < bhshell_num_builtins(); i++) {\n\t\tif (strcmp(cmd->args[0], bhshell_builtin_str[i]) == 0) {\n\t\t\treturn (*bhshell_builtin_func[i])(cmd->args);\n\t\t}\n\t}\n\treturn bhshell_launch(cmd);\n}\n\nint bhshell_launch(command* cmd) {\n\tpid_t pid;\n\tint status;\n\n\tint redirect_fd[2];\n\tif (cmd->redirect_file_name != NULL) {\n\t\tif (pipe(redirect_fd) == -1) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\t\n\tint pipe_fd[2];\n\tif (cmd->pipe_args != NULL) {\n\t\tif (pipe(pipe_fd) == -1) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tpid = fork();\n\tif (pid == 0) {\n\t\tif (cmd->pipe_args != NULL) {\n\t\t\tclose(pipe_fd[0]);\n\t\t\tif (dup2(pipe_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(pipe_fd[1]);\n\t\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\t\tclose(redirect_fd[0]);\n\t\t\t\tclose(redirect_fd[1]);\n\t\t\t}\n\t\t}\n\t\tif (cmd->pipe_args == NULL && cmd->redirect_file_name != NULL) {\n\t\t\tclose(redirect_fd[0]);\n\t\t\tif (dup2(redirect_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout to file\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(redirect_fd[1]);\n\t\t} \n\t\t\n\t\tif (execvp(cmd->args[0], cmd->args) == -1) {\n\t\t\tperror(\"bhshell\");\n\t\t}\n\t\t// execvp takes over the entire process\n\t\t// so if return backs to the child process\n\t\texit(EXIT_FAILURE);\n\n\t} else if (pid < 0) {\n\t\t// error forking\n\t\tperror(\"bhshell: Could not create child process\");\n\t\texit(EXIT_FAILURE);\n\t} \n\t// Main process\n\tif (cmd->pipe_args != NULL) {\n\t\tpid_t pid_pipe = fork();\n\t\tint pipe_status;\n\t\tif (pid_pipe == 0) {\n\t\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\t\tclose(redirect_fd[0]);\n\t\t\t\tif (dup2(redirect_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout to file\\n\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tclose(redirect_fd[1]);\n\t\t\t}\n\n\t\t\tclose(pipe_fd[1]);\n\t\t\tif (dup2(pipe_fd[0], STDIN_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdin\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(pipe_fd[0]);\n\n\n\t\t\tif (execvp(cmd->pipe_args[0], cmd->pipe_args) == -1) {\n\t\t\t\tperror(\"bhshell\");\n\t\t\t}\n\t\t\texit(EXIT_FAILURE);\n\t\t} else if (pid_pipe < 0) {\n\t\t\tperror(\"bhshell: Could not create child process\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tclose(pipe_fd[0]);\n\t\tclose(pipe_fd[1]);\n\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\twrite_to_redirect(redirect_fd, cmd);\n\t\t}\n\t\tdo {\n\t\t\twaitpid(pid_pipe, &pipe_status, WUNTRACED);\n\t\t\twaitpid(pid, &status, WUNTRACED);\n\t\t} while(!WIFEXITED(status) && !WIFSIGNALED(status) && !WIFEXITED(pipe_status) && !WIFSIGNALED(pipe_status));\n\t\n\t\treturn 1;\n\t} else if (cmd->redirect_file_name != NULL) {\n\t\twrite_to_redirect(redirect_fd, cmd);\n\t}\n\tdo {\n\t\twaitpid(pid, &status, WUNTRACED);\n\t} while(!WIFEXITED(status) && !WIFSIGNALED(status));\n\treturn 1;\n}\n\nint bhshell_cd(char** args) {\n\tif (args[1] == NULL) {\n\t\tfprintf(stderr, \"bhshell: expected argument to \\\"cd\\\" into\\n\");\n\t} else {\n\t\tif (chdir(args[1]) != 0) {\n\t\t\tperror(\"bhshell\");\n\t\t}\n\t}\n\treturn 1;\n}\n\nint bhshell_help(char** args) {\n\tprintf(\"A simple shell built to understand how processes work.\\n\");\n\tprintf(\"The following functions are builtin:\\n\");\n\n\tint count = bhshell_num_builtins();\n\tfor (int i = 0; i < count; i++) {\n\t\tprintf(\"\\t %d. %s\\n\", i + 1, bhshell_builtin_str[i]);\n\t}\n\treturn 1;\n}\n\nint bhshell_exit(char** args) {\n\treturn 0;\n}\n\nint bhshell_num_builtins() {\n\treturn sizeof(bhshell_builtin_str) / sizeof(char*);\n}\n\nvoid write_to_redirect(int redirect_fd[2], command* cmd) {\n\tstr s = { DA_NULL };\n\n\tchar temp;\n\t\n\tclose(redirect_fd[1]);\n\tint finished = read(redirect_fd[0], &temp, sizeof(char));\n\tif (finished == -1) {\n\t\tclose(redirect_fd[0]);\n\t\tclose(redirect_fd[1]);\n\t\tfree(s.items);\n\t\texit(EXIT_FAILURE);\n\t}\n\twhile (finished != 0) {\n\t\tda_append(&s, temp);\n\n\t\tfinished = read(redirect_fd[0], &temp, sizeof(char));\n\t}\n\tchar* string = get_string(&s);\n\t\n\tclose(redirect_fd[0]);\n\n\tFILE* f = fopen(cmd->redirect_file_name, \"w\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open file\\n\");\n\t\tfree(s.items);\n\t\texit(EXIT_FAILURE);\n\t}\n\tsize_t written = fwrite(string, strlen(string), 1, f);\n\tif (written == 0) {\n\t\tfprintf(stderr, \"Could not write to file\\n\");\n\t\tfree(string);\n\t\texit(EXIT_FAILURE);\n\t}\n\tfree(string); \n\tfclose(f);\n}\n",
    "bhshell.h": "#ifndef BHSHELL_H\n#define BHSHELL_H\n\n#include \"input.h\"\n\nvoid bhshell_loop();\nint bhshell_execute(command* cmd);\nint bhshell_launch(command* cmd); \nint bhshell_cd(char** args);\nint bhshell_help(char** args);\nint bhshell_exit(char** args);\nint bhshell_num_builtins();\nvoid write_to_redirect(int redirect_fd[2], command* cmd);\n\n#endif // !BHSHELL_H\n",
    "dynamicarr.c": "#include <string.h>\n\n#include \"include/dynamicarr.h\"\n#include \"include/xalloc.h\"\n//\nchar* get_string(str* s) {\n\tda_append(s, '\\0');\n\tchar* string = xmalloc(sizeof(char) * (s->position));\n\tmemcpy(string, s->items, sizeof(char) * s->position);\n\tfree(s->items);\n\ts->position = 0; s->items = NULL; s->bufsize = 0;\n\treturn string;\n}\n\n\nvoid destroy_args(char** args) {\n\tif (!args) return;\n\tsize_t i = 0;\n\twhile(args[i] != NULL) {\n\t\tfree(args[i]);\n\t\ti++;\n\t}\n}\n\nchar** get_args(arg_list* l) {\n\tif (l->position == 0) {\n\t\treturn NULL;\n\t}\n\tda_append(l, NULL);\n\tchar** args = xmalloc(sizeof(char*) * (l->position));\n\tfor (size_t i = 0; i < l->position - 1; i++) {\n\t\tsize_t length = strlen(l->items[i]);\n\t\targs[i] = xmalloc(sizeof(char) * (length + 1));\n\t\tmemcpy(args[i], l->items[i], length + 1);\n\t}\n\targs[l->position - 1] = NULL;\n\treturn args;\n}\n",
    "dynamicarr.h": "#include \"xalloc.h\"\n\n#ifndef DYNAMICARR_H\n#define DYNAMICARR_H\n\n#define DA_BUFFER_SIZE 16\n#define DA_NULL .items = NULL, .position = 0, .bufsize = 0\n\n#define da_append(l, x) \\\n\tdo {\\\n\t\tif ((l)->position >= (l)->bufsize) {\\\n\t\t\tif ((l)->bufsize == 0) (l)->bufsize = DA_BUFFER_SIZE;\\\n\t\t\telse (l)->bufsize *= 2;\\\n\t\t\t(l)->items = xrealloc((l)->items, ((l)->bufsize)*sizeof(*(l)->items));\\\n\t\t}\\\n\t\t(l)->items[(l)->position++] = x;\\\n\t} while(0)\n\ntypedef struct str {\n\tchar* items;\n\tsize_t position;\n\tsize_t bufsize;\n} str;\n\nchar* get_string(str* s);\n\ntypedef struct arg_list {\n\tchar** items;\n\tsize_t position;\n\tsize_t bufsize;\n} arg_list;\n\nchar** get_args(arg_list* l);\nvoid destroy_args(char** args);\n\n#endif\n",
    "input.c": "#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#include \"include/input.h\"\n#include \"include/dynamicarr.h\"\n#include \"include/xalloc.h\"\n\nenum ARG_TYPE {\n\tARG,\n\tPIPE_ARG,\n\tREDIRECT\n};\n\nchar* bhshell_read_line() {\n\tstr s = { DA_NULL };\n\twhile(1) {\n\t\tint c = getchar();\n\t\tif (c == '\\n' || c == EOF) {\n\t\t\tchar* string = get_string(&s);\n\t\t\treturn string;\n\t\t} else {\n\t\t\tda_append(&s, c);\n\t\t}\n\t}\n}\n\ncommand* bhshell_parse(char* line) {\n\tsize_t length = strlen(line);\n\targ_list args = { DA_NULL };\n\targ_list pipe_args = { DA_NULL };\n\tstr s = { DA_NULL };\n\tchar* redirect = NULL;\n\tenum ARG_TYPE current = ARG;\n\tcommand* cmd = new_command();\n\n\tfor (size_t i = 0; i < length; i++) {\n\t\tif (line[i] == '\\n' || line[i] == '\\t' || line[i] == ' ') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t} else if (current == PIPE_ARG) {\n\t\t\t\t\tda_append(&pipe_args, string);\n\t\t\t\t} else {\n\t\t\t\t\tredirect = string;\t\n\t\t\t\t}\n\t\t\t} \n\t\t\tcontinue;\n\t\t} else if (line[i] == '|') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t\tda_append(&args, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i + 1 < length && line[i] == '>') {\n\t\t\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcurrent = PIPE_ARG;\n\t\t} else if (line[i] == '>') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t\tda_append(&args, NULL);\n\t\t\t\t} else if (current == PIPE_ARG) {\n\t\t\t\t\tda_append(&pipe_args, string);\n\t\t\t\t\tda_append(&pipe_args, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = REDIRECT;\n\t\t} else {\n\t\t\tda_append(&s, line[i]);\n\t\t}\n\t}\n\tif (s.position == 0) {\n\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\treturn NULL;\n\t}\n\tif (s.position > 0) {\n\t\tchar* string = get_string(&s);\n\t\tif (current == ARG) {\n\t\t\tda_append(&args, string);\n\t\t\tda_append(&args, NULL);\n\t\t} else if (current == PIPE_ARG) {\n\t\t\tda_append(&pipe_args, string);\n\t\t\tda_append(&pipe_args, NULL);\n\t\t} else {\n\t\t\tredirect = string;\n\t\t}\n\t} \n\tif (args.position == 0) {\n\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\treturn NULL;\n\t}\n\tcmd->args = args.items;\n\tif (pipe_args.position > 0) {\n\t\tcmd->pipe_args = pipe_args.items;\n\t}\n\tif (redirect != NULL) {\n\t\tcmd->redirect_file_name = redirect;\n\t}\n\treturn cmd;\n}\n\ncommand* new_command() {\n\tcommand* cmd = xmalloc(sizeof(command));\n\t\n\tcmd->args = NULL;\n\tcmd->pipe_args = NULL;\n\tcmd->redirect_file_name = NULL;\n\treturn cmd;\n}\n\nvoid destroy_command(command* cmd) {\n\tdestroy_args(cmd->args);\n\tdestroy_args(cmd->pipe_args);\n\tfree(cmd->redirect_file_name);\n\tfree(cmd);\n}\n",
    "input.h": "#include <stdlib.h>\n\n#ifndef INPUT_H\n#define INPUT_H\n\n#define FREE_ON_INVALID(ARGS, PIPE_ARGS, REDIRECT) \\\n\tdo {\\\n\t\tif ((ARGS).position > 0) destroy_args(args.items);\\\n\t\tif ((PIPE_ARGS).position > 0) destroy_args(pipe_args.items);\\\n\t\tif ((REDIRECT)!= NULL) free(redirect);\\\n\t} while(0)\n\ntypedef struct command {\n\tchar** args;\n\tchar** pipe_args;\n\tchar* redirect_file_name;\n} command;\n\nchar* bhshell_read_line();\ncommand* bhshell_parse(char* line);\nvoid destroy_command(command* cmd);\ncommand* new_command();\n#endif\n",
    "main.c": "#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdbool.h>\n\n#include \"include/bhshell.h\"\n#include \"include/input.h\"\n\nint main(void) {\n\tbhshell_loop();\t\n\treturn EXIT_SUCCESS;\n}\n",
    "xalloc.c": "#include <stdlib.h>\n#include <stdio.h>\n\n#include \"include/xalloc.h\"\n\nvoid* xmalloc(size_t size) {\n\tvoid* ptr = malloc(size);\n\tif (!ptr) {\n\t\tfprintf(stderr, \"bhshell: allocation error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn ptr;\n}\n\nvoid* xrealloc(void* ptr, size_t size) {\n\tptr = realloc(ptr, size);\n\tif (!ptr) {\n\t\tfprintf(stderr, \"bhshell: allocation error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn ptr;\n}\n",
    "xalloc.h": "#include <stdlib.h>\n\nvoid* xmalloc(size_t size);\nvoid* xrealloc(void* ptr, size_t size);\n",
    "c": "",
    "c_pre_post_conditions": "",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\nFunction: function_name\nPre-condition: description of the pre-condition\nPost-condition: description of the post-condition\n```\n\nHere is the code:\n{{bhshell.c}}\n```c\n// header file\n/*#ifndef BHSHELL_H\n#define BHSHELL_H\n\n#include \"input.c\"\n\nvoid bhshell_loop();\nint bhshell_execute(command* cmd);\nint bhshell_launch(command* cmd); \nint bhshell_cd(char** args);\nint bhshell_help(char** args);\nint bhshell_exit(char** args);\nint bhshell_num_builtins();\nvoid write_to_redirect(int redirect_fd[2], command* cmd);\n\n#endif // !BHSHELL_H\n*/\n#include <linux/limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <strings.h>\n#include <unistd.h>\n#include <stdbool.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n#include <stdbool.h>\n\n#include \"include/dynamicarr.c\"\n#include \"include/input.c\"\n#include \"include/bhshell.h\"\n#include \"include/xalloc.c\"\n\n#define BUF_SIZE 64\n\nchar* bhshell_builtin_str[] = {\n\t\"cd\",\n\t\"help\",\n\t\"exit\",\n};\n\nint (*bhshell_builtin_func[]) (char**) = {\n\t&bhshell_cd,\n\t&bhshell_help,\n\t&bhshell_exit,\n};\n\nvoid bhshell_loop() {\n\tchar** args; \n\tint status = 1;\n\n\tdo {\n\t\tchar* dir = getcwd(NULL, 0);\n\t\tif (!dir) exit(EXIT_FAILURE);\n\n\t\tprintf(\"[%s] $ \", dir);\n\n\t\tchar* line = bhshell_read_line();\n\t\tcommand* cmd = bhshell_parse(line);\n\t\tif (cmd == NULL) {\n\t\t\tprintf(\"Invalid Command\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = bhshell_execute(cmd); \n\t\t\n\t\tfree(dir);\n\t\tfree(line);\n\t\tdestroy_command(cmd);\n\t} while(status); \n}\n\nint bhshell_execute(command* cmd) {\n\tif (cmd->args[0] == NULL) {\n\t\treturn 1;\n\t}\n\n\tfor (int i = 0; i < bhshell_num_builtins(); i++) {\n\t\tif (strcmp(cmd->args[0], bhshell_builtin_str[i]) == 0) {\n\t\t\treturn (*bhshell_builtin_func[i])(cmd->args);\n\t\t}\n\t}\n\treturn bhshell_launch(cmd);\n}\n\nint bhshell_launch(command* cmd) {\n\tpid_t pid;\n\tint status;\n\n\tint redirect_fd[2];\n\tif (cmd->redirect_file_name != NULL) {\n\t\tif (pipe(redirect_fd) == -1) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\t\n\tint pipe_fd[2];\n\tif (cmd->pipe_args != NULL) {\n\t\tif (pipe(pipe_fd) == -1) {\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tpid = fork();\n\tif (pid == 0) {\n\t\tif (cmd->pipe_args != NULL) {\n\t\t\tclose(pipe_fd[0]);\n\t\t\tif (dup2(pipe_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(pipe_fd[1]);\n\t\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\t\tclose(redirect_fd[0]);\n\t\t\t\tclose(redirect_fd[1]);\n\t\t\t}\n\t\t}\n\t\tif (cmd->pipe_args == NULL && cmd->redirect_file_name != NULL) {\n\t\t\tclose(redirect_fd[0]);\n\t\t\tif (dup2(redirect_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout to file\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(redirect_fd[1]);\n\t\t} \n\t\t\n\t\tif (execvp(cmd->args[0], cmd->args) == -1) {\n\t\t\tperror(\"bhshell\");\n\t\t}\n\t\t// execvp takes over the entire process\n\t\t// so if return backs to the child process\n\t\texit(EXIT_FAILURE);\n\n\t} else if (pid < 0) {\n\t\t// error forking\n\t\tperror(\"bhshell: Could not create child process\");\n\t\texit(EXIT_FAILURE);\n\t} \n\t// Main process\n\tif (cmd->pipe_args != NULL) {\n\t\tpid_t pid_pipe = fork();\n\t\tint pipe_status;\n\t\tif (pid_pipe == 0) {\n\t\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\t\tclose(redirect_fd[0]);\n\t\t\t\tif (dup2(redirect_fd[1], STDOUT_FILENO) == -1) {\n\t\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdout to file\\n\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tclose(redirect_fd[1]);\n\t\t\t}\n\n\t\t\tclose(pipe_fd[1]);\n\t\t\tif (dup2(pipe_fd[0], STDIN_FILENO) == -1) {\n\t\t\t\tfprintf(stderr, \"bhshell: Could not redirect stdin\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tclose(pipe_fd[0]);\n\n\n\t\t\tif (execvp(cmd->pipe_args[0], cmd->pipe_args) == -1) {\n\t\t\t\tperror(\"bhshell\");\n\t\t\t}\n\t\t\texit(EXIT_FAILURE);\n\t\t} else if (pid_pipe < 0) {\n\t\t\tperror(\"bhshell: Could not create child process\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tclose(pipe_fd[0]);\n\t\tclose(pipe_fd[1]);\n\t\tif (cmd->redirect_file_name != NULL) {\n\t\t\twrite_to_redirect(redirect_fd, cmd);\n\t\t}\n\t\tdo {\n\t\t\twaitpid(pid_pipe, &pipe_status, WUNTRACED);\n\t\t\twaitpid(pid, &status, WUNTRACED);\n\t\t} while(!WIFEXITED(status) && !WIFSIGNALED(status) && !WIFEXITED(pipe_status) && !WIFSIGNALED(pipe_status));\n\t\n\t\treturn 1;\n\t} else if (cmd->redirect_file_name != NULL) {\n\t\twrite_to_redirect(redirect_fd, cmd);\n\t}\n\tdo {\n\t\twaitpid(pid, &status, WUNTRACED);\n\t} while(!WIFEXITED(status) && !WIFSIGNALED(status));\n\treturn 1;\n}\n\nint bhshell_cd(char** args) {\n\tif (args[1] == NULL) {\n\t\tfprintf(stderr, \"bhshell: expected argument to \\\"cd\\\" into\\n\");\n\t} else {\n\t\tif (chdir(args[1]) != 0) {\n\t\t\tperror(\"bhshell\");\n\t\t}\n\t}\n\treturn 1;\n}\n\nint bhshell_help(char** args) {\n\tprintf(\"A simple shell built to understand how processes work.\\n\");\n\tprintf(\"The following functions are builtin:\\n\");\n\n\tint count = bhshell_num_builtins();\n\tfor (int i = 0; i < count; i++) {\n\t\tprintf(\"\\t %d. %s\\n\", i + 1, bhshell_builtin_str[i]);\n\t}\n\treturn 1;\n}\n\nint bhshell_exit(char** args) {\n\treturn 0;\n}\n\nint bhshell_num_builtins() {\n\treturn sizeof(bhshell_builtin_str) / sizeof(char*);\n}\n\nvoid write_to_redirect(int redirect_fd[2], command* cmd) {\n\tstr s = { DA_NULL };\n\n\tchar temp;\n\t\n\tclose(redirect_fd[1]);\n\tint finished = read(redirect_fd[0], &temp, sizeof(char));\n\tif (finished == -1) {\n\t\tclose(redirect_fd[0]);\n\t\tclose(redirect_fd[1]);\n\t\tfree(s.items);\n\t\texit(EXIT_FAILURE);\n\t}\n\twhile (finished != 0) {\n\t\tda_append(&s, temp);\n\n\t\tfinished = read(redirect_fd[0], &temp, sizeof(char));\n\t}\n\tchar* string = get_string(&s);\n\t\n\tclose(redirect_fd[0]);\n\n\tFILE* f = fopen(cmd->redirect_file_name, \"w\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Could not open file\\n\");\n\t\tfree(s.items);\n\t\texit(EXIT_FAILURE);\n\t}\n\tsize_t written = fwrite(string, strlen(string), 1, f);\n\tif (written == 0) {\n\t\tfprintf(stderr, \"Could not write to file\\n\");\n\t\tfree(string);\n\t\texit(EXIT_FAILURE);\n\t}\n\tfree(string); \n\tfclose(f);\n}\n```\n\n{{dynamicarr.c}}\n```c\n// header file\n/*#include \"xalloc.c\"\n\n#ifndef DYNAMICARR_H\n#define DYNAMICARR_H\n\n#define DA_BUFFER_SIZE 16\n#define DA_NULL .items = NULL, .position = 0, .bufsize = 0\n\n#define da_append(l, x) \\\n\tdo {\\\n\t\tif ((l)->position >= (l)->bufsize) {\\\n\t\t\tif ((l)->bufsize == 0) (l)->bufsize = DA_BUFFER_SIZE;\\\n\t\t\telse (l)->bufsize *= 2;\\\n\t\t\t(l)->items = xrealloc((l)->items, ((l)->bufsize)*sizeof(*(l)->items));\\\n\t\t}\\\n\t\t(l)->items[(l)->position++] = x;\\\n\t} while(0)\n\ntypedef struct str {\n\tchar* items;\n\tsize_t position;\n\tsize_t bufsize;\n} str;\n\nchar* get_string(str* s);\n\ntypedef struct arg_list {\n\tchar** items;\n\tsize_t position;\n\tsize_t bufsize;\n} arg_list;\n\nchar** get_args(arg_list* l);\nvoid destroy_args(char** args);\n\n#endif\n*/\n#include <string.h>\n\n#include \"include/dynamicarr.h\"\n#include \"include/xalloc.c\"\n//\nchar* get_string(str* s) {\n\tda_append(s, '\\0');\n\tchar* string = xmalloc(sizeof(char) * (s->position));\n\tmemcpy(string, s->items, sizeof(char) * s->position);\n\tfree(s->items);\n\ts->position = 0; s->items = NULL; s->bufsize = 0;\n\treturn string;\n}\n\n\nvoid destroy_args(char** args) {\n\tif (!args) return;\n\tsize_t i = 0;\n\twhile(args[i] != NULL) {\n\t\tfree(args[i]);\n\t\ti++;\n\t}\n}\n\nchar** get_args(arg_list* l) {\n\tif (l->position == 0) {\n\t\treturn NULL;\n\t}\n\tda_append(l, NULL);\n\tchar** args = xmalloc(sizeof(char*) * (l->position));\n\tfor (size_t i = 0; i < l->position - 1; i++) {\n\t\tsize_t length = strlen(l->items[i]);\n\t\targs[i] = xmalloc(sizeof(char) * (length + 1));\n\t\tmemcpy(args[i], l->items[i], length + 1);\n\t}\n\targs[l->position - 1] = NULL;\n\treturn args;\n}\n```\n\n{{input.c}}\n```c\n// header file\n/*#include <stdlib.h>\n\n#ifndef INPUT_H\n#define INPUT_H\n\n#define FREE_ON_INVALID(ARGS, PIPE_ARGS, REDIRECT) \\\n\tdo {\\\n\t\tif ((ARGS).position > 0) destroy_args(args.items);\\\n\t\tif ((PIPE_ARGS).position > 0) destroy_args(pipe_args.items);\\\n\t\tif ((REDIRECT)!= NULL) free(redirect);\\\n\t} while(0)\n\ntypedef struct command {\n\tchar** args;\n\tchar** pipe_args;\n\tchar* redirect_file_name;\n} command;\n\nchar* bhshell_read_line();\ncommand* bhshell_parse(char* line);\nvoid destroy_command(command* cmd);\ncommand* new_command();\n#endif\n*/\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#include \"include/input.h\"\n#include \"include/dynamicarr.c\"\n#include \"include/xalloc.c\"\n\nenum ARG_TYPE {\n\tARG,\n\tPIPE_ARG,\n\tREDIRECT\n};\n\nchar* bhshell_read_line() {\n\tstr s = { DA_NULL };\n\twhile(1) {\n\t\tint c = getchar();\n\t\tif (c == '\\n' || c == EOF) {\n\t\t\tchar* string = get_string(&s);\n\t\t\treturn string;\n\t\t} else {\n\t\t\tda_append(&s, c);\n\t\t}\n\t}\n}\n\ncommand* bhshell_parse(char* line) {\n\tsize_t length = strlen(line);\n\targ_list args = { DA_NULL };\n\targ_list pipe_args = { DA_NULL };\n\tstr s = { DA_NULL };\n\tchar* redirect = NULL;\n\tenum ARG_TYPE current = ARG;\n\tcommand* cmd = new_command();\n\n\tfor (size_t i = 0; i < length; i++) {\n\t\tif (line[i] == '\\n' || line[i] == '\\t' || line[i] == ' ') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t} else if (current == PIPE_ARG) {\n\t\t\t\t\tda_append(&pipe_args, string);\n\t\t\t\t} else {\n\t\t\t\t\tredirect = string;\t\n\t\t\t\t}\n\t\t\t} \n\t\t\tcontinue;\n\t\t} else if (line[i] == '|') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t\tda_append(&args, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i + 1 < length && line[i] == '>') {\n\t\t\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcurrent = PIPE_ARG;\n\t\t} else if (line[i] == '>') {\n\t\t\tif (s.position > 0) {\n\t\t\t\tchar* string = get_string(&s);\n\t\t\t\tif (current == ARG) {\n\t\t\t\t\tda_append(&args, string);\n\t\t\t\t\tda_append(&args, NULL);\n\t\t\t\t} else if (current == PIPE_ARG) {\n\t\t\t\t\tda_append(&pipe_args, string);\n\t\t\t\t\tda_append(&pipe_args, NULL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = REDIRECT;\n\t\t} else {\n\t\t\tda_append(&s, line[i]);\n\t\t}\n\t}\n\tif (s.position == 0) {\n\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\treturn NULL;\n\t}\n\tif (s.position > 0) {\n\t\tchar* string = get_string(&s);\n\t\tif (current == ARG) {\n\t\t\tda_append(&args, string);\n\t\t\tda_append(&args, NULL);\n\t\t} else if (current == PIPE_ARG) {\n\t\t\tda_append(&pipe_args, string);\n\t\t\tda_append(&pipe_args, NULL);\n\t\t} else {\n\t\t\tredirect = string;\n\t\t}\n\t} \n\tif (args.position == 0) {\n\t\tFREE_ON_INVALID(args, pipe_args, redirect);\n\t\treturn NULL;\n\t}\n\tcmd->args = args.items;\n\tif (pipe_args.position > 0) {\n\t\tcmd->pipe_args = pipe_args.items;\n\t}\n\tif (redirect != NULL) {\n\t\tcmd->redirect_file_name = redirect;\n\t}\n\treturn cmd;\n}\n\ncommand* new_command() {\n\tcommand* cmd = xmalloc(sizeof(command));\n\t\n\tcmd->args = NULL;\n\tcmd->pipe_args = NULL;\n\tcmd->redirect_file_name = NULL;\n\treturn cmd;\n}\n\nvoid destroy_command(command* cmd) {\n\tdestroy_args(cmd->args);\n\tdestroy_args(cmd->pipe_args);\n\tfree(cmd->redirect_file_name);\n\tfree(cmd);\n}\n```\n\n{{main.c}}\n```c\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdbool.h>\n\n#include \"include/bhshell.c\"\n#include \"include/input.c\"\n\nint main(void) {\n\tbhshell_loop();\t\n\treturn EXIT_SUCCESS;\n}\n```\n\n{{xalloc.c}}\n```c\n// header file\n/*#include <stdlib.h>\n\nvoid* xmalloc(size_t size);\nvoid* xrealloc(void* ptr, size_t size);\n*/\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"include/xalloc.h\"\n\nvoid* xmalloc(size_t size) {\n\tvoid* ptr = malloc(size);\n\tif (!ptr) {\n\t\tfprintf(stderr, \"bhshell: allocation error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn ptr;\n}\n\nvoid* xrealloc(void* ptr, size_t size) {\n\tptr = realloc(ptr, size);\n\tif (!ptr) {\n\t\tfprintf(stderr, \"bhshell: allocation error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\treturn ptr;\n}\n```\n\n\nPlease extract the invariants from the code.\n"
}