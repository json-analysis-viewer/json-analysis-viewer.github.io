{
    "name": "bitset",
    "bitset.c": "/*\n * Copyright (c) 2020 Adil Benhlal <adil.benhlal@outlook.fr>\n *\n * bitset is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n */\n#include <errno.h>\n#include \"./include/cborg/bitset.h\"\n\nbitset_t *cb_bitset_new(size_t nb_bits) {\n  bitset_t *bs = (bitset_t *)calloc(1, sizeof(bitset_t));\n  bs->array = (uint8_t *)calloc(__bitset_size(nb_bits), sizeof(uint8_t));\n  bs->size = nb_bits;\n  return bs;\n}\n\nvoid cb_bitset_delete(bitset_t *bs) {\n  free(bs->array);\n  free(bs);\n}\n\nsize_t cb_bitset_count(bitset_t *bs) {\n  return (bs->flip ? (bs->size - bs->count) : bs->count);\n}\n\nsize_t cb_bitset_size(bitset_t *bs) { return bs->size; }\n\nbool cb_bitset_test(bitset_t *bs, size_t idx) {\n  return bs->flip ^\n         ((bs->array[__bitset_byte(idx)] & __bitset_bit_mask(idx)) != 0);\n}\n\nbool cb_bitset_any(bitset_t *bs) {\n  return (bs->flip ? (bs->count != bs->size) : (bs->count != 0));\n}\n\nbool cb_bitset_none(bitset_t *bs) { return !(cb_bitset_any(bs)); }\n\nbool cb_bitset_all(bitset_t *bs) {\n  return (bs->flip ? (bs->count == 0) : (bs->count == bs->size));\n}\n\nvoid cb_bitset_set(bitset_t *bs, size_t idx, bool value) {\n  bool flip_value = bs->flip ? !value : value;\n  size_t previous_count = __builtin_popcount(bs->array[__bitset_byte(idx)]);\n  if (flip_value) {\n    bs->array[__bitset_byte(idx)] |= __bitset_bit_mask(idx);\n  } else {\n    bs->array[__bitset_byte(idx)] &= ~__bitset_bit_mask(idx);\n  }\n  bs->count +=\n      (__builtin_popcount(bs->array[__bitset_byte(idx)]) - previous_count);\n}\n\nvoid cb_bitset_reset(bitset_t *bs) {\n  memset(bs->array, 0, __bitset_size(bs->size));\n  bs->flip = false;\n  bs->count = 0;\n}\n\nvoid cb_bitset_flip(bitset_t *bs) { bs->flip = !(bs->flip); }\n\nchar *cb_bitset_to_string(bitset_t *bs) {\n  char *res = (char *)malloc(sizeof(char) * (bs->size + 1));\n  for (size_t i = 0; i < bs->size; i++) {\n    res[i] = cb_bitset_test(bs, i) ? '1' : '0';\n  }\n  res[bs->size] = '\\0';\n  return res;\n}\n\nvoid cb_bitset_write(bitset_t *bs, const char *path) {\n  FILE *file = fopen(path, \"wb\");\n  size_t bytes_to_write = __bitset_size(bs->size);\n  size_t bytes_writen = 0;\n  size_t total_writen = 0;\n\n  if (file == NULL) {\n    fprintf(stdout, \"%s\\n\", strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n\n  fwrite(&(bs->size), sizeof(size_t), 1, file);\n  fwrite(&(bs->count), sizeof(size_t), 1, file);\n  fwrite(&(bs->flip), sizeof(bool), 1, file);\n  while ((bytes_writen = fwrite(bs->array + total_writen, sizeof(uint8_t),\n                                bytes_to_write - total_writen, file)) > 0) {\n    total_writen += bytes_writen;\n  }\n\n  fclose(file);\n}\n\nbitset_t *cb_bitset_read(const char *path) {\n  FILE *file = fopen(path, \"rb\");\n  size_t size = 0;\n\n  if (file == NULL) {\n    fprintf(stdout, \"%s\\n\", strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n\n  fread(&size, sizeof(size_t), 1, file);\n  bitset_t *bs = cb_bitset_new(size);\n  fread(&(bs->count), sizeof(size_t), 1, file);\n  fread(&(bs->flip), sizeof(bool), 1, file);\n  while (fread(bs->array, sizeof(uint8_t), bs->size, file) > 0);\n\n  fclose(file);\n  return bs;\n}\n",
    "bitset.h": "/*\n * Copyright (c) 2020 Adil Benhlal <adil.benhlal@outlook.fr>\n *\n * bitset is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n */\n\n#ifndef _CBORG_BITSET_H\n#define _CBORG_BITSET_H\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n// Returns the number of bytes needed to store a number of bits\n#define __bitset_size(nbits) ((nbits + 7) >> 3)\n\n// Returns the index of the bit in bitset->array (=idx/8)\n#define __bitset_byte(idx) ((idx) >> 3)\n\n// Returns the bit mask\n#define __bitset_bit_mask(idx) (1 << ((idx)&0x7))\n\n// TODO: format bitset using cbor\n// TODO: bitset thread-safe\n\ntypedef struct bitset_t {\n  bool flip;\n  size_t size;\n  size_t count;\n  uint8_t *array;\n} bitset_t;\n\nbitset_t *cb_bitset_new(size_t nb_bits);\n\nvoid cb_bitset_delete(bitset_t *bs);\n\nsize_t cb_bitset_count(bitset_t *bs);\n\nsize_t cb_bitset_size(bitset_t *bs);\n\nbool cb_bitset_test(bitset_t *bs, size_t idx);\n\nbool cb_bitset_any(bitset_t *bs);\n\nbool cb_bitset_none(bitset_t *bs);\n\nbool cb_bitset_all(bitset_t *bs);\n\nvoid cb_bitset_set(bitset_t *bs, size_t idx, bool value);\n\nvoid cb_bitset_reset(bitset_t *bs);\n\nvoid cb_bitset_flip(bitset_t *bs);\n\nchar *cb_bitset_to_string(bitset_t *bs);\n\nvoid cb_bitset_write(bitset_t *bs, const char *path);\n\nbitset_t *cb_bitset_read(const char *path);\n\n#endif\n",
    "c": "",
    "c_pre_post_conditions": "// Function: cb_bitset_new\n// Pre-condition: nb_bits is any non\u2010negative size_t; sufficient memory is available.\n// Post-condition: Returns a non\u2010NULL pointer bs to a newly allocated bitset_t such that\n//   \u2022 bs->size == nb_bits\n//   \u2022 bs->flip == false\n//   \u2022 bs->count == 0\n//   \u2022 bs->array points to a zero\u2010initialized buffer of length __bitset_size(nb_bits)\n//   \u2022 All bits in the new bitset are logically 0.\n\n// Function: cb_bitset_delete\n// Pre-condition: bs is non\u2010NULL and was returned by cb_bitset_new or cb_bitset_read.\n// Post-condition: bs->array and bs itself have been freed; no bitset state remains valid.\n\n// Function: cb_bitset_count\n// Pre-condition: bs is non\u2010NULL.\n// Post-condition: Returns the number of bits that are logically set in bs, computed as\n//   (bs->flip ? bs->size - bs->count : bs->count).\n//   bs is not modified.\n\n// Function: cb_bitset_size\n// Pre-condition: bs is non\u2010NULL.\n// Post-condition: Returns bs->size; bs is not modified.\n\n// Function: cb_bitset_test\n// Pre-condition: bs is non\u2010NULL and 0 \u2264 idx < bs->size.\n// Post-condition: Returns true iff the logical bit at position idx is set, i.e.\n//   (bs->flip XOR ((bs->array[ idx/8 ] & (1 << (idx%8))) != 0)). bs is not modified.\n\n// Function: cb_bitset_any\n// Pre-condition: bs is non\u2010NULL.\n// Post-condition: Returns true iff at least one logical bit is set.\n//   (equivalently, cb_bitset_count(bs) > 0). bs is not modified.\n\n// Function: cb_bitset_none\n// Pre-condition: bs is non\u2010NULL.\n// Post-condition: Returns true iff no logical bit is set (i.e. !cb_bitset_any(bs)). bs is not modified.\n\n// Function: cb_bitset_all\n// Pre-condition: bs is non\u2010NULL.\n// Post-condition: Returns true iff all bs->size logical bits are set\n//   (i.e. cb_bitset_count(bs) == bs->size). bs is not modified.\n\n// Function: cb_bitset_set\n// Pre-condition: bs is non\u2010NULL and 0 \u2264 idx < bs->size.\n//   Invariant on entry: bs->count equals the popcount of the bytes in bs->array.\n// Post-condition:\n//   \u2022 The logical bit at idx is set to `value`. Concretely, the underlying bit is written to\n//       flip_value = (bs->flip ? !value : value)\n//     by masking bs->array[idx/8].\n//   \u2022 bs->count is incremented or decremented by the change in the popcount of the affected byte.\n//   \u2022 For all j \u2260 idx, the logical bit j and the popcount of their containing bytes are unchanged.\n//   \u2022 After return, cb_bitset_test(bs, idx) == value and bs->count again equals the popcount of bs->array.\n\n// Function: cb_bitset_reset\n// Pre-condition: bs is non\u2010NULL.\n// Post-condition:\n//   \u2022 All bytes of bs->array are zeroed (no underlying bits set).\n//   \u2022 bs->flip is set to false.\n//   \u2022 bs->count is set to 0.\n//   \u2022 Logically, every bit tests false.\n\n// Function: cb_bitset_flip\n// Pre-condition: bs is non\u2010NULL.\n// Post-condition: bs->flip is toggled (true \u2194 false). bs->size, bs->count, and the contents of bs->array are unchanged.\n//   Logically, every bit\u2019s value is inverted w.r.t. its prior value.\n\n// Function: cb_bitset_to_string\n// Pre-condition: bs is non\u2010NULL.\n// Post-condition: Returns a malloc\u2010allocated, NUL\u2010terminated C\u2010string of length bs->size+1 such that\n//   str[i] == '1' if cb_bitset_test(bs, i) is true, else '0'. bs is not modified.\n//   Caller is responsible for free(str).\n\n// Function: cb_bitset_write\n// Pre-condition: bs and path are non\u2010NULL; the file at path can be opened for binary write.\n// Post-condition:\n//   \u2022 The file contains, in order: bs->size (size_t), bs->count (size_t), bs->flip (bool),\n//     then exactly __bitset_size(bs->size) bytes of bs->array.\n//   \u2022 bs is not modified.\n//   \u2022 On I/O error, prints errno message and exits the process.\n\n// Function: cb_bitset_read\n// Pre-condition: path is non\u2010NULL; the file exists and was written by cb_bitset_write.\n// Post-condition: Returns a newly allocated bitset_t *bs such that\n//   \u2022 bs->size, bs->count, bs->flip are populated from the first three fields in the file,\n//   \u2022 bs->array is allocated at length __bitset_size(bs->size) and filled with the following bytes,\n//   \u2022 bs->array, bs->size, bs->count, bs->flip exactly reflect the serialized state.\n//   Caller must eventually call cb_bitset_delete(bs).",
    "rri_prompt": "\nYou are given a program in C. You must reason carefully about how the program behaves.\nOnce you have reasoned about the program behavior, your task is to determine the pre and post-conditions for each function in the program.\nYou must consider each function in the C code and determine the invariants that hold true before and after the execution of each function.\n\nPlease provide the invariants for each function in the following format:\n```c\n// Function: function_name\n// Pre-condition: description of the pre-condition\n// Post-condition: description of the post-condition\n```\n\nHere is the code:\n{{bitset.c}}\n```c\n// header file\n/*/*\n * Copyright (c) 2020 Adil Benhlal <adil.benhlal@outlook.fr>\n *\n * bitset is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n */\n\n#ifndef _CBORG_BITSET_H\n#define _CBORG_BITSET_H\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n// Returns the number of bytes needed to store a number of bits\n#define __bitset_size(nbits) ((nbits + 7) >> 3)\n\n// Returns the index of the bit in bitset->array (=idx/8)\n#define __bitset_byte(idx) ((idx) >> 3)\n\n// Returns the bit mask\n#define __bitset_bit_mask(idx) (1 << ((idx)&0x7))\n\n// TODO: format bitset using cbor\n// TODO: bitset thread-safe\n\ntypedef struct bitset_t {\n  bool flip;\n  size_t size;\n  size_t count;\n  uint8_t *array;\n} bitset_t;\n\nbitset_t *cb_bitset_new(size_t nb_bits);\n\nvoid cb_bitset_delete(bitset_t *bs);\n\nsize_t cb_bitset_count(bitset_t *bs);\n\nsize_t cb_bitset_size(bitset_t *bs);\n\nbool cb_bitset_test(bitset_t *bs, size_t idx);\n\nbool cb_bitset_any(bitset_t *bs);\n\nbool cb_bitset_none(bitset_t *bs);\n\nbool cb_bitset_all(bitset_t *bs);\n\nvoid cb_bitset_set(bitset_t *bs, size_t idx, bool value);\n\nvoid cb_bitset_reset(bitset_t *bs);\n\nvoid cb_bitset_flip(bitset_t *bs);\n\nchar *cb_bitset_to_string(bitset_t *bs);\n\nvoid cb_bitset_write(bitset_t *bs, const char *path);\n\nbitset_t *cb_bitset_read(const char *path);\n\n#endif\n*/\n/*\n * Copyright (c) 2020 Adil Benhlal <adil.benhlal@outlook.fr>\n *\n * bitset is free software; you can redistribute it and/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n */\n#include <errno.h>\n#include \"./include/cborg/bitset.h\"\n\nbitset_t *cb_bitset_new(size_t nb_bits) {\n  bitset_t *bs = (bitset_t *)calloc(1, sizeof(bitset_t));\n  bs->array = (uint8_t *)calloc(__bitset_size(nb_bits), sizeof(uint8_t));\n  bs->size = nb_bits;\n  return bs;\n}\n\nvoid cb_bitset_delete(bitset_t *bs) {\n  free(bs->array);\n  free(bs);\n}\n\nsize_t cb_bitset_count(bitset_t *bs) {\n  return (bs->flip ? (bs->size - bs->count) : bs->count);\n}\n\nsize_t cb_bitset_size(bitset_t *bs) { return bs->size; }\n\nbool cb_bitset_test(bitset_t *bs, size_t idx) {\n  return bs->flip ^\n         ((bs->array[__bitset_byte(idx)] & __bitset_bit_mask(idx)) != 0);\n}\n\nbool cb_bitset_any(bitset_t *bs) {\n  return (bs->flip ? (bs->count != bs->size) : (bs->count != 0));\n}\n\nbool cb_bitset_none(bitset_t *bs) { return !(cb_bitset_any(bs)); }\n\nbool cb_bitset_all(bitset_t *bs) {\n  return (bs->flip ? (bs->count == 0) : (bs->count == bs->size));\n}\n\nvoid cb_bitset_set(bitset_t *bs, size_t idx, bool value) {\n  bool flip_value = bs->flip ? !value : value;\n  size_t previous_count = __builtin_popcount(bs->array[__bitset_byte(idx)]);\n  if (flip_value) {\n    bs->array[__bitset_byte(idx)] |= __bitset_bit_mask(idx);\n  } else {\n    bs->array[__bitset_byte(idx)] &= ~__bitset_bit_mask(idx);\n  }\n  bs->count +=\n      (__builtin_popcount(bs->array[__bitset_byte(idx)]) - previous_count);\n}\n\nvoid cb_bitset_reset(bitset_t *bs) {\n  memset(bs->array, 0, __bitset_size(bs->size));\n  bs->flip = false;\n  bs->count = 0;\n}\n\nvoid cb_bitset_flip(bitset_t *bs) { bs->flip = !(bs->flip); }\n\nchar *cb_bitset_to_string(bitset_t *bs) {\n  char *res = (char *)malloc(sizeof(char) * (bs->size + 1));\n  for (size_t i = 0; i < bs->size; i++) {\n    res[i] = cb_bitset_test(bs, i) ? '1' : '0';\n  }\n  res[bs->size] = '\\0';\n  return res;\n}\n\nvoid cb_bitset_write(bitset_t *bs, const char *path) {\n  FILE *file = fopen(path, \"wb\");\n  size_t bytes_to_write = __bitset_size(bs->size);\n  size_t bytes_writen = 0;\n  size_t total_writen = 0;\n\n  if (file == NULL) {\n    fprintf(stdout, \"%s\\n\", strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n\n  fwrite(&(bs->size), sizeof(size_t), 1, file);\n  fwrite(&(bs->count), sizeof(size_t), 1, file);\n  fwrite(&(bs->flip), sizeof(bool), 1, file);\n  while ((bytes_writen = fwrite(bs->array + total_writen, sizeof(uint8_t),\n                                bytes_to_write - total_writen, file)) > 0) {\n    total_writen += bytes_writen;\n  }\n\n  fclose(file);\n}\n\nbitset_t *cb_bitset_read(const char *path) {\n  FILE *file = fopen(path, \"rb\");\n  size_t size = 0;\n\n  if (file == NULL) {\n    fprintf(stdout, \"%s\\n\", strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n\n  fread(&size, sizeof(size_t), 1, file);\n  bitset_t *bs = cb_bitset_new(size);\n  fread(&(bs->count), sizeof(size_t), 1, file);\n  fread(&(bs->flip), sizeof(bool), 1, file);\n  while (fread(bs->array, sizeof(uint8_t), bs->size, file) > 0);\n\n  fclose(file);\n  return bs;\n}\n```\n\n\nPlease extract the invariants from the code.\n"
}