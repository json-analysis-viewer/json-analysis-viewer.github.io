{
    "name": "amp",
    "amp.c": "\n//\n// amp.c\n//\n// Copyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"amp.h\"\n\n/*\n * Read u32be.\n */\n\nstatic uint32_t\nread_u32_be(char *buf) {\n  uint32_t n = 0;\n  n |= buf[0] << 24;\n  n |= buf[1] << 16;\n  n |= buf[2] << 8;\n  n |= buf[3];\n  return n;\n}\n\n/*\n * Write u32be.\n */\n\nstatic void\nwrite_u32_be(char *buf, uint32_t n) {\n  buf[0] = n >> 24 & 0xff;\n  buf[1] = n >> 16 & 0xff;\n  buf[2] = n >> 8 & 0xff;\n  buf[3] = n & 0xff;\n}\n\n/*\n * Decode the `msg` header in `buf`.\n */\n\nvoid\namp_decode(amp_t *msg, char *buf) {\n  msg->version = buf[0] >> 4;\n  msg->argc = buf[0] & 0xf;\n  msg->buf = buf + 1;\n}\n\n/*\n * Decode `msg` argument, returning a buffer\n * that must be freed by the user and progressing\n * the msg->buf cursor.\n */\n\nchar *\namp_decode_arg(amp_t *msg) {\n  uint32_t len = read_u32_be(msg->buf);\n  msg->buf += 4;\n\n  char *buf = malloc(len);\n  if (!buf) return NULL;\n\n  memcpy(buf, msg->buf, len);\n  msg->buf += len;\n  return buf;\n}\n\n/*\n * Encode the AMP message argv.\n *\n *         0        1 2 3 4     <length>    ...\n *   +------------+----------+------------+\n *   | <ver/argc> | <length> | <data>     | additional arguments\n *   +------------+----------+------------+\n *\n */\n\nchar *\namp_encode(char **argv, int argc) {\n  size_t len = 1;\n  size_t lens[argc];\n\n  // length\n  for (int i = 0; i < argc; ++i) {\n    len += 4;\n    lens[i] = strlen(argv[i]);\n    len += lens[i];\n  }\n\n  // alloc\n  char *buf = malloc(len);\n  char *ret = buf;\n  if (!buf) return NULL;\n\n  // ver/argc\n  *buf++ = AMP_VERSION << 4 | argc;\n\n  // encode\n  for (int i = 0; i < argc; ++i) {\n    size_t len = lens[i];\n\n    write_u32_be(buf, len);\n    buf += 4;\n\n    memcpy(buf, argv[i], len);\n    buf += len;\n  }\n\n  return ret;\n}",
    "amp.h": "\n//\n// amp.h\n//\n// Copyright (c) 2014 TJ Holowaychuk <tj@vision-media.ca>\n//\n\n#ifndef AMP_H\n#define AMP_H\n\n/*\n * Protocol version.\n */\n\n#define AMP_VERSION 1\n\n/*\n * Message struct.\n */\n\ntypedef struct {\n  short version;\n  short argc;\n  char *buf;\n} amp_t;\n\n// prototypes\n\nchar *\namp_encode(char **argv, int argc);\n\nvoid\namp_decode(amp_t *msg, char *buf);\n\nchar *\namp_decode_arg(amp_t *msg);\n\n#endif",
    "c_rust": "",
    "c_rust_pre_post_conditions": "// Generated pre\u2010 and post\u2010conditions for the Rust interface to amp.c\n\n// Function: Amp::decode\n//\n// Precondition:\n// - `buf.len() >= 1`: there must be at least one byte to read the version/argc header.\n// - `buf` must be a valid AMP\u2010encoded message (i.e. produced by `amp_encode`).\n//\n// Postcondition:\n// - `self.version == (buf.as_bytes()[0] >> 4) as i16`\n// - `self.argc    == (buf.as_bytes()[0] & 0x0F) as i16`\n// - `self.buf     == buf[1..].to_string()`: the remainder of the input buffer, starting\n//                  immediately after the 1\u2010byte header.\n\nimpl Amp {\n    pub fn decode(&mut self, buf: &str) {\n        // pre: buf.len() >= 1\n        // post:\n        //   self.version == (buf.as_bytes()[0] >> 4) as i16\n        //   self.argc    == (buf.as_bytes()[0] & 0x0F) as i16\n        //   self.buf     == buf[1..].to_string()\n        unimplemented!()\n    }\n}\n\n// Function: Amp::decode_arg\n//\n// Precondition:\n// - `self.buf.len() >= 4`: there must be at least 4 bytes to read the next argument length.\n// - let `n = read_u32_be(self.buf.as_bytes()[0..4])`; then `self.buf.len() >= 4 + n`.\n// - Number of calls to `decode_arg` must not exceed the original `self.argc`.\n//\n// Postcondition:\n// - let `n = (self.buf.as_bytes()[0] as u32) << 24\n//                 | (self.buf.as_bytes()[1] as u32) << 16\n//                 | (self.buf.as_bytes()[2] as u32) <<  8\n//                 | (self.buf.as_bytes()[3] as u32);`\n// - returns a `&str` corresponding exactly to `&self.buf[4 .. 4 + n]`\n// - advances `self.buf` so that after the call,\n//   `self.buf` is its old contents starting at byte index `4 + n`\n//   (i.e. the next unread argument, if any).\n\nimpl Amp {\n    pub fn decode_arg(&mut self) -> &str {\n        // pre:\n        //   self.buf.len() >= 4 &&\n        //   let n = read_u32_be(self.buf.as_bytes()[0..4]) <= self.buf.len() - 4\n        // post:\n        //   returns &self.buf[4..4+n] as &str\n        //   self.buf = old_self.buf[4+n..].to_string()\n        unimplemented!()\n    }\n}\n\n// Function: amp_encode\n//\n// Precondition:\n// - `argv.len() <= 0x0F` (since `argc` is encoded in 4 bits).\n// - each `&str` in `argv` is valid UTF\u20108.\n//\n// Postcondition:\n// - returns a `String` `s` of length\n//     1                      // header\n//   + sum_i (4 + argv[i].len()) // 4\u2010byte length + data\n// - `s.as_bytes()[0] == (AMP_VERSION as u8) << 4 | (argv.len() as u8 & 0x0F)`\n// - For each argument `i`:\n//     let offset_i = 1 + \u2211_{j < i}(4 + argv[j].len());\n//     The 4 bytes `s.as_bytes()[offset_i .. offset_i+4]` are\n//       the big\u2010endian u32 of `argv[i].len()`,\n//     and `s[offset_i+4 .. offset_i+4+argv[i].len()] == argv[i].as_bytes()`.\n\npub fn amp_encode(argv: &[&str]) -> String {\n    // pre: argv.len() <= 0x0F\n    // post:\n    //   let s = result;\n    //   s.len() == 1 + sum_i(4 + argv[i].len())\n    //   s.as_bytes()[0] == (AMP_VERSION as u8) << 4 | (argv.len() as u8 & 0x0F)\n    //   for each i:\n    //     let off = 1 + sum_{j<i}(4+argv[j].len());\n    //     big_endian_u32(s.as_bytes()[off..off+4]) == argv[i].len() as u32\n    //     &s[off+4..off+4+argv[i].len()] == argv[i]\n    unimplemented!()\n}",
    "rri_prompt": ""
}